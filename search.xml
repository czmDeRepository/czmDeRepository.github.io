<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker常用命令笔记</title>
      <link href="2021/02/07/%E9%83%A8%E7%BD%B2/docker/"/>
      <url>2021/02/07/%E9%83%A8%E7%BD%B2/docker/</url>
      
        <content type="html"><![CDATA[<p>查看容器的挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名 | grep Mounts -A 20</span><br><span class="line"><span class="comment"># -A 20（显示Mounts往下20行）</span></span><br><span class="line"><span class="comment"># docker inspect 获取容器/镜像的元数据</span></span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看所有镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>重命名容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rename 原容器名  新容器名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>创建并运行MySQL容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run </span><br><span class="line">-p 3307:3306 <span class="comment">#端口映射</span></span><br><span class="line">--name mysql-master1 <span class="comment"># 容器名</span></span><br><span class="line"><span class="comment">#挂载路径</span></span><br><span class="line">-v /usr/<span class="built_in">local</span>/mysql_cluster/master1/conf/my.cnf:/etc/mysql/my.cnf <span class="comment">#配置文件</span></span><br><span class="line">-v /usr/<span class="built_in">local</span>/mysql_cluster/master1/data/:/var/lib/mysql  <span class="comment">#数据库数据</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD= root用户密码</span><br><span class="line">-d <span class="comment">#后台运行</span></span><br><span class="line">mysql <span class="comment">#镜像名</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mycat搭建MySQL集群实现高可用，读写分离</title>
      <link href="2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/"/>
      <url>2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建MySQL集群一主一从"><a href="#搭建MySQL集群一主一从" class="headerlink" title="搭建MySQL集群一主一从"></a>搭建MySQL集群一主一从</h2><h3 id="1-修改master的配置文件-etc-my-cnf"><a href="#1-修改master的配置文件-etc-my-cnf" class="headerlink" title="1.修改master的配置文件/etc/my.cnf"></a>1.修改master的配置文件/etc/my.cnf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个), 入系统库等</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库，如果有多个数据库，可重复此参数，每个数据库一行</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure><h3 id="2-重启服务"><a href="#2-重启服务" class="headerlink" title="2.重启服务"></a>2.重启服务</h3><h3 id="3-在主服务上授权slave"><a href="#3-在主服务上授权slave" class="headerlink" title="3.在主服务上授权slave"></a>3.在主服务上授权slave</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;授权密码，下面用到&#x27;</span>;</span><br><span class="line"><span class="comment">#可授权给具体ip &#x27;slave&#x27;@&#x27;ip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql8用下面</span></span><br><span class="line">CREATE USER <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;授权密码，下面用到&#x27;</span>;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="4-查询master状态（记下File与Position值，主机不再操作）"><a href="#4-查询master状态（记下File与Position值，主机不再操作）" class="headerlink" title="4.查询master状态（记下File与Position值，主机不再操作）"></a>4.查询master状态（记下File与Position值，主机不再操作）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207162725895.png" alt="image-20210207162725895"></p><h3 id="5-修改slave的配置文件"><a href="#5-修改slave的配置文件" class="headerlink" title="5.修改slave的配置文件"></a>5.修改slave的配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><h3 id="6-重启从机mysql"><a href="#6-重启从机mysql" class="headerlink" title="6.重启从机mysql"></a>6.重启从机mysql</h3><h3 id="7-从机执行复制主机命令"><a href="#7-从机执行复制主机命令" class="headerlink" title="7.从机执行复制主机命令"></a>7.从机执行复制主机命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;主机的IP地址&#x27;</span>,</span><br><span class="line">MASTER_USER=<span class="string">&#x27;slave&#x27;</span>, <span class="comment"># 用户名，与上面一致</span></span><br><span class="line">MASTER_PASSWORD=<span class="string">&#x27;密码&#x27;</span>, <span class="comment">#与上面一致</span></span><br><span class="line">MASTER_PORT=3306, <span class="comment">#主机端口</span></span><br><span class="line">MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=653;(pisition的值)</span><br></pre></td></tr></table></figure><h3 id="8-启动从服务器复制功能"><a href="#8-启动从服务器复制功能" class="headerlink" title="8.启动从服务器复制功能"></a>8.启动从服务器复制功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#之前有开启的话要先停止</span></span><br><span class="line">stop slave;</span><br><span class="line"></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><h3 id="9-查看从服务器状态"><a href="#9-查看从服务器状态" class="headerlink" title="9.查看从服务器状态"></a>9.查看从服务器状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G; <span class="comment"># \G:将查询到的横向表格纵向输出，方便阅读</span></span><br><span class="line"><span class="comment">#Slave_IO_Running: Yes</span></span><br><span class="line"><span class="comment">#Slave_SQL_Running: Yes</span></span><br><span class="line"><span class="comment">#说明配置成功</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207164123829.png" alt="image-20210207164123829"></p><h3 id="10-测试是否同步"><a href="#10-测试是否同步" class="headerlink" title="10.测试是否同步"></a>10.测试是否同步</h3><p>注：数据库必须是主配置文件中binlog-do-db配置的数据库才会同步</p><p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207170933867.png" alt="image-20210207170933867"></p><h2 id="搭建双主双从"><a href="#搭建双主双从" class="headerlink" title="搭建双主双从"></a>搭建双主双从</h2><h3 id="主机master1配置"><a href="#主机master1配置" class="headerlink" title="主机master1配置"></a>主机master1配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates </span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2 </span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure><h3 id="主机master2配置"><a href="#主机master2配置" class="headerlink" title="主机master2配置"></a>主机master2配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=3 <span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates </span><br><span class="line"></span><br><span class="line"><span class="comment">#防止插入时自增主键与master1冲突</span></span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2 </span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=2</span><br></pre></td></tr></table></figure><h3 id="slave1配置"><a href="#slave1配置" class="headerlink" title="slave1配置"></a>slave1配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><h3 id="slave2配置"><a href="#slave2配置" class="headerlink" title="slave2配置"></a>slave2配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=4 </span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><h3 id="接下来操作与上面一主一从差不多，就是两个master也要互相复制对方"><a href="#接下来操作与上面一主一从差不多，就是两个master也要互相复制对方" class="headerlink" title="接下来操作与上面一主一从差不多，就是两个master也要互相复制对方"></a>接下来操作与上面一主一从差不多，就是两个master也要互相复制对方</h3><h2 id="Mycat配置"><a href="#Mycat配置" class="headerlink" title="Mycat配置"></a>Mycat配置</h2><p>！注：Mycat1.6连接mysql8时需修改mysql的加密策略</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 修改密码为用不过期</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER; </span><br><span class="line">-- 修改密码并指定加密规则为mysql_native_password</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">-- 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>schema.xml：定义逻辑库，表、分片节点等内容。</p><p>rule.xml：定义分片相关规则。</p><p>server.xml：定义用户以及系统相关变量，如端口等。</p><h3 id="schema-xml写MySQL连接信息"><a href="#schema-xml写MySQL连接信息" class="headerlink" title="schema.xml写MySQL连接信息"></a>schema.xml写MySQL连接信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM <span class="string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;schema name=<span class="string">&quot;TESTDB&quot;</span> checkSQLschema=<span class="string">&quot;false&quot;</span> sqlMaxLimit=<span class="string">&quot;100&quot;</span> dataNode=<span class="string">&quot;dn1&quot;</span>&gt;</span><br><span class="line">&lt;/schema&gt;</span><br><span class="line">&lt;!--database为mysql的数据库名 --&gt;</span><br><span class="line">&lt;dataNode name=<span class="string">&quot;dn1&quot;</span> dataHost=<span class="string">&quot;host1&quot;</span> database=<span class="string">&quot;testMycat&quot;</span> /&gt;</span><br><span class="line">&lt;dataHost name=<span class="string">&quot;host1&quot;</span> maxCon=<span class="string">&quot;1000&quot;</span> minCon=<span class="string">&quot;10&quot;</span> balance=<span class="string">&quot;1&quot;</span></span><br><span class="line">  writeType=<span class="string">&quot;0&quot;</span> dbType=<span class="string">&quot;mysql&quot;</span> dbDriver=<span class="string">&quot;native&quot;</span> switchType=<span class="string">&quot;1&quot;</span>  slaveThreshold=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">&lt;!-- can have multi write hosts --&gt;</span><br><span class="line">&lt;writeHost host=<span class="string">&quot;hostM1&quot;</span> url=<span class="string">&quot;主机1IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span></span><br><span class="line">   password=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">&lt;!-- can have multi <span class="built_in">read</span> hosts --&gt;</span><br><span class="line">&lt;readHost host=<span class="string">&quot;hostS2&quot;</span> url=<span class="string">&quot;从机1IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span> password=<span class="string">&quot;密码&quot;</span> /&gt;</span><br><span class="line">&lt;/writeHost&gt;</span><br><span class="line">&lt;writeHost host=<span class="string">&quot;hostS1&quot;</span> url=<span class="string">&quot;主机2IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span></span><br><span class="line">   password=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">&lt;readHost host=<span class="string">&quot;hostS3&quot;</span> url=<span class="string">&quot;从机2IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span> password=<span class="string">&quot;密码&quot;</span> /&gt;</span><br><span class="line">&lt;/writeHost&gt;</span><br><span class="line">&lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#balance=&quot;1&quot;: 全部的readHost与stand by writeHost参与select语句的负载均衡。</span></span><br><span class="line"><span class="comment">#balance配置负载均衡类型：</span></span><br><span class="line"><span class="comment">#&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。</span></span><br><span class="line"><span class="comment">#&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均#衡。</span></span><br><span class="line"><span class="comment">#balance=&quot;2&quot;，所有读操作都随机的在 writeHost、readhost 上分发。</span></span><br><span class="line"><span class="comment">#balance=&quot;3&quot;，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#writeType=&quot;0&quot;: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个</span></span><br><span class="line"><span class="comment">#writeType=&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐</span></span><br><span class="line"><span class="comment">#writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties 。 #switchType=&quot;1&quot;: 1 默认值，自动切换。</span></span><br><span class="line"><span class="comment"># -1 表示不自动切换</span></span><br><span class="line"><span class="comment"># 2 基于 MySQL 主从同步的状态决定是否切换。</span></span><br></pre></td></tr></table></figure><h3 id="server-xml里添加Mycat登陆用户信息"><a href="#server-xml里添加Mycat登陆用户信息" class="headerlink" title="server.xml里添加Mycat登陆用户信息"></a>server.xml里添加Mycat登陆用户信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;user name=<span class="string">&quot;my用户名&quot;</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;mycat密码&quot;</span>&gt;密码&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">&quot;schemas&quot;</span>&gt;TESTDB&lt;/property&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><h3 id="在bin，目录下启动Mycat"><a href="#在bin，目录下启动Mycat" class="headerlink" title="在bin，目录下启动Mycat"></a>在bin，目录下启动Mycat</h3><p>./mycat console ： 控制台运行</p><p>./mycat start ： 后台运行</p><p>（图中可知，Mycat是用Java写的）</p><p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207200845130.png" alt="image-20210207200845130"></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#与mysql连接一样</span></span><br><span class="line"><span class="comment">#8066是数据连接端口，即应用程序连此端口</span></span><br><span class="line"><span class="comment">#9066是Mycat管理端口</span></span><br><span class="line">mysql -u[上面server配置的用户名] -p[密码] -P [端口] -h[ip]</span><br></pre></td></tr></table></figure><h3 id="创建表并测试"><a href="#创建表并测试" class="headerlink" title="创建表并测试"></a>创建表并测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user(id int, name varchar(11),address varchar(11));</span><br><span class="line">insert into user values(1,<span class="string">&#x27;张三&#x27;</span>,@@hostname);</span><br><span class="line"><span class="comment">#不同mysql的主机名不同@@hostname</span></span><br></pre></td></tr></table></figure><p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207211246172.png" alt="image-20210207211246172"></p><h2 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h2><h3 id="垂直拆分（分库分表）"><a href="#垂直拆分（分库分表）" class="headerlink" title="垂直拆分（分库分表）"></a>垂直拆分（分库分表）</h3><p>指按照业务将表进行分类，分布到不同的数据库上面，有紧密关联关系的表应该在一个库里，相互没有关联关系的表可以分到不同的库里。将数据或者说压力分担到不同的库上面。（不同库中表不同）</p><h3 id="水平拆分（分表）"><a href="#水平拆分（分表）" class="headerlink" title="水平拆分（分表）"></a>水平拆分（分表）</h3><p>按照某个字段的某种规则来分散到多个库之中，不同库的表中包含一部分数据。（不同库拥有相同表）</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/01/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/01/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统（operation system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与配置<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>​        内核是操作系统的基础模块，用于管理系统资源。例如提供对软件层面的抽象（例如对进程、文件系统、同步、内存、网络协议等对象的操作和权限控制），和对硬件访问的抽象（例如磁盘，显示，网络接口卡（NIC））；操作系统，在内核的基础上有延伸，包括了提供基础服务的系统组件。</p><p>​        内核就是计算机学科意义上的操作系统，直接与硬件交互，提供CPU时间片管理、中断、内存管理、IO管理等等；一般意义上的操作系统包含的东西要更多一些，至少要有用户交互的基本程序，比如一个命令行界面和基本的指令（文件遍历、进程管理等等），或者图形界面的桌面和文件浏览器。</p><p><a href="https://blog.csdn.net/qq_26849233/article/details/74527779">参考链接</a></p><p>……</p><h2 id="常见进程调度算法"><a href="#常见进程调度算法" class="headerlink" title="常见进程调度算法"></a>常见进程调度算法</h2><ol><li>先来先服务调度算法</li><li>短作业优先调度算法</li><li>时间片轮转法</li><li>多级反馈队列调度算法</li><li>优先权调度算法的类型</li><li>高响应比优先调度算法</li></ol><p><a href="https://blog.csdn.net/luyafei_89430/article/details/12971171?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161432243216780265447720%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161432243216780265447720&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-5-12971171.first_rank_v2_pc_rank_v29&utm_term=%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">详情链接</a></p><p><a href="https://www.cnblogs.com/smuxiaolei/p/7544086.html">各种调度算法</a></p><h2 id="硬盘基本知识"><a href="#硬盘基本知识" class="headerlink" title="硬盘基本知识"></a>硬盘基本知识</h2><ol><li>盘片（platter）</li><li>磁头（head）</li><li>磁道（track）</li><li>扇区（sector）</li><li>柱面（cylinder）</li></ol><p><a href="https://www.cnblogs.com/jswang/p/9071847.html">详情链接</a></p><h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><p>操作系统内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。<strong>操作系统内存管理包括物理内存管理和虚拟内存管理。</strong></p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><a href="https://juejin.cn/post/6844903507594575886">链接1</a></p><p><a href="https://zhuanlan.zhihu.com/p/96098896">链接2</a></p><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ol><li>块式管理</li><li>页式管理</li><li>段式管理</li><li>段页式管理</li></ol><p><a href="https://blog.csdn.net/hguisu/article/details/5713164?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161432520816780262540622%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161432520816780262540622&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-5713164.first_rank_v2_pc_rank_v29&utm_term=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&spm=1018.2226.3001.4187">详情链接</a></p><p><a href="https://blog.csdn.net/ChaunceyChen/article/details/86672415">链接</a></p><p><a href="https://developer.aliyun.com/article/636086?spm=a2c6h.13813017.0.dArticle738638.4e383df7rJCRtx">详细链接</a></p><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>为了区分不同进程的不同权限，衍生出内核态（系统态）和用户态的概念。计算机通过CUP的一个状态字来区分当前进程属于哪个状态，内核态和用户态分别对应CUP的特权态（0级）和普通态（3级）。（注：intel CPU提供Ring0-Ring3四种级别的运行模式）</p><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>CPU可以访问内存几乎所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序。</p><h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>所有的用户程序都运行在用户态，有时需要执行内核态才能执行的操作（如：文件操作，IO处理，设备驱动等），这时需要一种机制，让用户态进程切换到内核态，但不能控制在内核中执行的指令，这种机制称为<strong>系统调用</strong>。CUP实现称为陷阱指令。</p><h3 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h3><ol><li>系统调用</li><li>异常</li><li>外围设备中断（常见：缺页中断）</li></ol><p><a href="https://blog.csdn.net/qq_42022528/article/details/87860311">参考链接</a></p><p><a href="https://blog.csdn.net/qq_34170700/article/details/106996450?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161588207916780255238783%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161588207916780255238783&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-5-106996450.first_rank_v2_pc_rank_v29&utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81+%E5%8E%9F%E7%90%86">参考链接</a></p><h2 id="进程间的通讯"><a href="#进程间的通讯" class="headerlink" title="进程间的通讯"></a>进程间的通讯</h2><ol><li>管道（匿名管道、有名管道、流管道）</li><li>信号量</li><li>消息队列</li><li>信号</li><li>共享内存</li><li>套接字</li></ol><p><a href="https://www.cnblogs.com/wanjianjun777/p/10483861.html">参考链接</a></p><p><a href="https://blog.csdn.net/armlinuxww/article/details/92803381">Epoll原理</a></p><h2 id="OSI模型七层协议"><a href="#OSI模型七层协议" class="headerlink" title="OSI模型七层协议"></a>OSI模型七层协议</h2><p><img src="/2021/01/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1440999-20200220113229985-1726588670.png" alt="1440999-20200220113229985-1726588670"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li>二层负载均衡</li></ul><p>负载均衡服务器对外提供一个VIP（虚拟IP），集群内部各主机拥有<strong>相同</strong>的IP地址，但是拥有不同MAC地址，负载均衡服务器通过改写请求报文中的<strong>目标MAC地址实现负载均衡</strong>。</p><ul><li>三层负载均衡</li></ul><p>负载均衡服务器对外提供一个VIP，集群内各主机IP地址<strong>不同</strong>，服务器接收到请求后，根据负载均衡算法，通过IP将请求发送至不同的主机。</p><ul><li>四层负载均衡</li></ul><p>位于OSI模型的第四层——传输层。有TCP/UDP协议，这两协议都包含了源端口/目标端口，负载均衡服务器通过修改报文的地址信息{IP（网络层IP）+端口}实现负载均衡。</p><ul><li>七层负载均衡</li></ul><p>位于第七层——应用层。常用协议：HTTP、RADIUS、DNS等。七层负载可以基于这些协议，如根据UPL、浏览器类别、语言、地理位置进行负载均衡。</p><p><a href="https://mp.weixin.qq.com/s/9POrwe3jrE1kChps6r-osQ">参考链接</a></p><h2 id="select、poll和epoll区别"><a href="#select、poll和epoll区别" class="headerlink" title="select、poll和epoll区别"></a>select、poll和epoll区别</h2><p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811">参考链接</a></p><p><a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610">参考链接</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>框架学习</title>
      <link href="2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring是一个轻量级的IOC和AOP容器框架，是为Java应用程序提供基础性服务的一套框架，目的是简化企业应用程序的开发，使开发者只需关心业务需求，将对象之间的依赖关系交由框架处理，减低组件的耦合性。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><ol><li>Spring Core：核心类库，所有功能都依赖与它，主要组件是BeanFactory，提供IOC（控制反转）和DI（依赖注入）服务。</li><li>Spring Contenxt：提供上下文信息，框架式Bean访问方式，以及企业级功能（JNDI、定时任务、添加国际化的使用、事件传播等）。</li><li>Spring AOP： 提供面向切面的编程功能。</li><li>Spring Web：提供基本面向Web的综合特性，提供对常见框架（Struts2,SpringMVC）的支持，能够管理这些框架，将Spring资源注入其中，也能在这些框架前后添加拦截器。</li><li>Spring MVC ：提供面向Web应用的MVC三层架构（Model-View-Controller）。</li><li>Spring Dao：操作数据库模块，对JDBC的抽象封装，简化数据库访问异常处理，并能统一管理JDBC事务。</li><li>Spring ORM：对现有ORM（Object Relational Mapping对象关系映射）框架的支持。</li></ol><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/115629-c2e1e90a738b75f9.png" alt="核心组件"></p><h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a><a href="https://www.cnblogs.com/joy99/p/10941543.html">SpringAOP</a></h3><p><a href="https://blog.csdn.net/jiankunking/article/details/52143504">JDK动态代理</a></p><p><a href="https://blog.csdn.net/yhl_jxy/article/details/80633194">CGLIB动态代理</a></p><h3 id="spring启动流程"><a href="#spring启动流程" class="headerlink" title="spring启动流程"></a>spring启动流程</h3><h4 id="配置形式"><a href="#配置形式" class="headerlink" title="配置形式"></a>配置形式</h4><ol><li>启动代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationConfig.xml&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>ClassPathXmlApplicationContext内部</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先加载ContextClosedEvent类</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// Eagerly load the ContextClosedEvent class to avoid weird classloader issues</span></span><br><span class="line"><span class="comment">// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)</span></span><br><span class="line">    <span class="comment">//急切地加载ContextClosedEvent类以避免奇怪的类加载器问题</span></span><br><span class="line"><span class="comment">//weblogic8.1中的应用程序关闭。（达斯汀·伍兹报道）</span></span><br><span class="line">ContextClosedEvent.class.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);<span class="comment">//初始化父类</span></span><br><span class="line"><span class="comment">//设置配置文件目录configLocations数组</span></span><br><span class="line">    setConfigLocations(configLocations); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh(); <span class="comment">//IOC真正初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20210401145150319.png" alt="image-20210401145150319"></p><ol start="3"><li>初始化AbstractApplicationContext 父类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line">setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//this();无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在这之前会初始化实例字段必要，如</span></span><br><span class="line">        <span class="comment">//logger（日志记录）</span></span><br><span class="line">        <span class="comment">//id（容器id），displayName（展示名） 两者值一样，都是</span></span><br><span class="line">        <span class="comment">//ObjectUtils.identityToString(this);</span></span><br><span class="line">        <span class="comment">//初始化BeanFactoryPostProcessor集合（空ArrayList），</span></span><br><span class="line">        <span class="comment">//原子boolean类active、closed</span></span><br><span class="line">        <span class="comment">//初始化监听器集合，（LinkedList）等</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化资源加载器</span></span><br><span class="line"><span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Ant模式通配符的ResourceLoader子类资源查找器</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>调用refresh()正真初始化IOC</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">//预处理，设置开始时间以及容器状态，属性验证等</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">//初始化BeanFactory：销毁存在的并新建新的</span></span><br><span class="line">        <span class="comment">//调用loadBeanDefinitions方法使用XmlBeanDefinitionReader加载Bean定义，</span></span><br><span class="line">        <span class="comment">//initBeanDefinitionReader方法通过读取配置文件configLocations数组，解析xml文件，</span></span><br><span class="line">        <span class="comment">//通过beanDefinitionRegistry将BeanDefinition存放到</span></span><br><span class="line">        <span class="comment">//DefaultListableBeanFactory类的Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256)中;</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">//为Bean工厂添加类加载器，表达式解析器（StandardBeanExpressionResolver）、资源编辑器（ResourceEditorRegistrar）、自动装配、</span></span><br><span class="line">        <span class="comment">//Bean工厂早期后置处理器（用以将内部bean检测为ApplicationListeners。）等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">//提供给想要实现BeanPostProcessor的三方框架使用的。谁要使用谁就去实现。作用是在BeanFactory准备工作完成后做一些定制化的处理，一般结合BeanPostProcessor接口的实现类一起使用，注入一些重要资源（类似Application的属性和ServletContext的属性）</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">//在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">//注册Bean后置处理器</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">//初始化MessageSource组件，负责国际功能</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">//初始化事件派发器，在注册监听器时会用到</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">//留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">//查找所有的ApplicationListener监听器并注册到广播器中</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">//初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">//完成其他工作如清除缓存、发布BeanFactory容器刷新完成事件等，IOC容器初始化结束</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            <span class="comment">//设置active状态为false</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            <span class="comment">//清空非必要缓存如单例元数据</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解加载"><a href="#注解加载" class="headerlink" title="注解加载"></a>注解加载</h4><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="spring启动流程"></p><p><a href="https://blog.csdn.net/a745233700/article/details/113761271">参考链接</a></p><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/ceef00b5c21677e9c0ec4bfbe400a3c5.png" alt="ceef00b5c21677e9c0ec4bfbe400a3c5"></p><p><a href="https://daimingzhi.blog.csdn.net/article/details/107164508">参考链接1</a></p><p><a href="https://www.jb51.net/article/197450.htm">参考链接2</a></p><p><a href="https://cloud.tencent.com/developer/article/1497692">参考链接3</a></p><p><a href="https://blog.csdn.net/f641385712/article/details/92801300?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161513539016780266291183%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161513539016780266291183&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-11-92801300.first_rank_v2_pc_rank_v29&utm_term=spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98">参考链接4</a></p><h3 id="BeanWrapper及类型转换"><a href="#BeanWrapper及类型转换" class="headerlink" title="BeanWrapper及类型转换"></a>BeanWrapper及类型转换</h3><p>BeanWrapper其实就是一个Bean的包装器，它对Bean包装的目的是为了能操纵Bean中的属性，所以它同时需要具备获取、设置Bean中的属性能力，所以它也必须是一个属性访问器（PropertyAccessor），另外为了将各种不同类型的配置数据绑定到Bean的属性上，那么它还得具备属性转换的能力，因为它还得是一个类型转换器（TypeConverter）。</p><p>Spring中将类型转换的功能都委托给了一个TypeConverterDelegate，这个委托类在进行类型转换时会有两套方案：</p><ol><li><strong>PropertyEditor</strong>，这是Spring最初提供的方案，扩展了java中的PropertyEditor（java原先提供这个接口的目的更多是为了进行图形化编程）。</li><li>Spring后来提供的一个进行类型转换的<strong>ConversionService</strong>体系，用来取代PropertyEditor，因为PropertyEditor有很大的局限性，只能进行String-&gt;Object的转换。</li></ol><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/20200331082247233.png" alt="20200331082247233"></p><p><a href="https://blog.csdn.net/qq_41907991/article/details/105214244">参考链接</a></p><h3 id="Spring容器加载Bean流程"><a href="#Spring容器加载Bean流程" class="headerlink" title="Spring容器加载Bean流程"></a>Spring容器加载Bean流程</h3><ol><li><p>ResourceLoader从配置文件中加载Spring配置信息，并使用Resource表示这个配置文件的资源。</p></li><li><p>XXXBeanDefinitionReader（XXX可以是Xml、Properties、Annotated根据不同配置类型选择），读取并解析Resource所指向的配置文件，生成BeanDefinition对象（用于存储配置元信息：创建对象所需要的必要信息）。如xml配置中一个&lt; bean &gt;&lt; /bean &gt;标签话就对应一个BeanDefinition对象。所有的BeanDefinition对象会被注册到BeanDefinitionRegistry（底层使用key-value存储，如下）。</p><p> <img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20210315141623519.png" alt="image-20210315141623519"></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;(<span class="number">64</span>);</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接操作DefaultListableBeanFactory的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>容器扫描BeanDefinitionRegistry中的BeanDefinition，利用反射识别出实现BeanFactoryPostProcessor工厂后置处理接口的Bean。并调用工厂后置处理器对BeanDefinition进行加工处理。</p><p> 注：<strong>BeanFactoryPostProcessor</strong>是容器启动阶段Spring提供的一个扩展点，主要负责对注册到BeanDefinationRegistry中BeanDefination进行一定程度上的修改与替换。主要完成以下两项工作：</p><ul><li><p>将配置文件中的占位符”${xx}”替换为最终配置值。</p></li><li><p>通过Java反射机制找出所有实现java.beans.PropertyEditor接口的Bean，并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）。</p></li></ul></li><li><p>Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，调用InstantiationStrategy类将其实例化。</p></li><li><p>在实例化Bean时，Spring容器会使用BeanWrapper对Bean进行封装。（BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作）</p></li><li><p>最后利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。</p></li></ol><p><a href="https://blog.csdn.net/xingxing513234072/article/details/78247480?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161572101216780274183660%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161572101216780274183660&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78247480.first_rank_v2_pc_rank_v29&utm_term=spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">参考链接</a></p><h3 id="Bean实例化执行流程。"><a href="#Bean实例化执行流程。" class="headerlink" title="Bean实例化执行流程。"></a>Bean实例化执行流程。</h3><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/20210222011843360.png" alt="20210222011843360"></p><p><a href="https://blog.csdn.net/a745233700/article/details/113840727">参考链接</a></p><p><a href="https://blog.csdn.net/qq_36697880/article/details/113836822">参考链接</a></p><h3 id="Resource与-Autowried区别"><a href="#Resource与-Autowried区别" class="headerlink" title="@Resource与@Autowried区别"></a>@Resource与@Autowried区别</h3><p><strong>相同</strong></p><ul><li>都可以标注在字段或属性的setter方法上，都可以实现对象注入。</li></ul><p><strong>不同</strong></p><ul><li>@Autowired 注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</li><li>@Resource注解默认按名称装配。名称可以通过@Resource的name属性指定，如果没有指定默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。 若设置了type属性则按照类型注入。</li><li>@Resources是JDK自带的，@Autowired是Spring提供的。</li></ul><h3 id="Spring常见面试题总结"><a href="#Spring常见面试题总结" class="headerlink" title="Spring常见面试题总结"></a><a href="https://blog.csdn.net/a745233700/article/details/80959716">Spring常见面试题总结</a></h3><p><a href="https://blog.csdn.net/qq_41907991/category_9907747.html">Spring源码解析</a></p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="/2020/12/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/660329-20190922093835529-1159443997.png" alt="img"></p><p><a href="https://www.cnblogs.com/myitnews/p/11565941.html">SpringMVC执行流程</a></p><p><a href="https://blog.csdn.net/a745233700/article/details/80963758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161216387316780264093649%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161216387316780264093649&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-3-80963758.pc_search_result_before_js&utm_term=%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187">常见面试题参考</a></p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p><a href="https://blog.csdn.net/a745233700/article/details/80977133">参考链接</a></p><p><a href="http://www.mybatis.cn/category/interview/">参考链接2</a></p><p><a href="https://blog.csdn.net/luanlouis/category_9263284.html">深入理解</a></p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="/2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p><h2 id="java创建运行线程"><a href="#java创建运行线程" class="headerlink" title="java创建运行线程"></a>java创建运行线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//todo^</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// 要执行的任务</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</span></span><br><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字</span></span><br><span class="line"><span class="keyword">new</span> Thread(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">Integer result = task3.get();</span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），<strong>不会释放锁</strong> 。</p><p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 异常。 </p><p>可使用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>让出执行权，<strong>不会释放锁</strong>。</p><p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程。</p><p>具体的实现依赖于操作系统的任务调度器。</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>等待线程执行完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"> sleep(<span class="number">2</span>);</span><br><span class="line"> r1 = <span class="number">10</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"> t1.start();</span><br><span class="line"> <span class="comment">// 线程执行结束会导致 join 提前结束</span></span><br><span class="line"> t1.join(<span class="number">1500</span>);<span class="comment">//无参为阻塞等待</span></span><br><span class="line"> <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"> log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br></pre></td></tr></table></figure><h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h2><p>obj.wait()指令就会释放锁，进入阻塞等待（WAITING）状态。等待其他线程调用锁对象obj.notify()/notifyAll()唤醒或者执行该线程对象的interrupt()方法中断他。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasWater = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasFruits = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!hasWater) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;没水等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//让出锁</span></span><br><span class="line">                        lock.wait(); <span class="comment">//lock.wait(time); 等待time时间，0或空参为无限等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;成功拿到水&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!hasFruits) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;没水果等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//让出锁</span></span><br><span class="line">                        lock.wait(); <span class="comment">//lock.wait(time); 等待time时间，0或空参为无限等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;成功拿到水果&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        giveWater();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        giveFriuits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;水来了&quot;</span>);</span><br><span class="line">            hasWater = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();<span class="comment">//唤醒所有释放lock锁的等待线程</span></span><br><span class="line"><span class="comment">//            lock.notify();//随机唤醒一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveFriuits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;水果来了&quot;</span>);</span><br><span class="line">            hasFruits = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[thread1] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">19</span> - -- 没水等待</span><br><span class="line">[thread2] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">35</span> - -- 没水果等待</span><br><span class="line">[main] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">57</span> - -- 水来了</span><br><span class="line">[thread2] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">35</span> - -- 没水果等待 <span class="comment">//等待水果的也被唤醒，再次等待</span></span><br><span class="line">[thread1] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">27</span> - -- 成功拿到水</span><br><span class="line">[main] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">65</span> - -- 水果来了</span><br><span class="line">[thread2] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">43</span> - -- 成功拿到水果</span><br></pre></td></tr></table></figure><h2 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h2><p>暂停当前线程 LockSupport.park(); </p><p> 恢复某个线程的运行 LockSupport.unpark(暂停线程对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkAndUnpark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;parking...&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(<span class="string">&quot;继续运行parking2&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        log.info(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;unpark2&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="锁粗化与锁消除"><a href="#锁粗化与锁消除" class="headerlink" title="锁粗化与锁消除"></a><a href="https://blog.csdn.net/qq_26222859/article/details/80546917">锁粗化与锁消除</a></h2><h2 id="MESI协议（缓存一致性协议）"><a href="#MESI协议（缓存一致性协议）" class="headerlink" title="MESI协议（缓存一致性协议）"></a><a href="https://blog.csdn.net/xiaowenmu1/article/details/89705740">MESI协议（缓存一致性协议）</a></h2><h2 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a><a href="https://www.cnblogs.com/deltadeblog/p/9559035.html">偏向锁、轻量级锁、重量级锁</a></h2><h2 id="volatile（jdk1-5及其以后版本生效）"><a href="#volatile（jdk1-5及其以后版本生效）" class="headerlink" title="volatile（jdk1.5及其以后版本生效）"></a>volatile（jdk1.5及其以后版本生效）</h2><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存，保证该变量的可见性（一个线程对变量的修改对另一个线程可见）。</p><p>注：线程可能从自己工作内存中的高速缓存中读取一个共享变量，没法及时知道其他线程对该变量的修改。导致对该变量的不可见现象。</p><h3 id="volatie保证可见性与有序性"><a href="#volatie保证可见性与有序性" class="headerlink" title="volatie保证可见性与有序性"></a>volatie保证可见性与有序性</h3><h4 id="写屏障（sfence）"><a href="#写屏障（sfence）" class="headerlink" title="写屏障（sfence）"></a>写屏障（sfence）</h4><p>保证在该屏障之前的，对共享变量的改动，都同步到主存当中（可见性），</p><p>会确保指令重排序（JVM的JIT优化实现指令级并行）时，不会将写屏障之前的代码排在写屏障之后（有序性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//todo修改其他共享变量</span></span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 写屏障，在这之前的所有共享变量被修改的将会被同步到内存中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="读屏障（lfence）"><a href="#读屏障（lfence）" class="headerlink" title="读屏障（lfence）"></a>读屏障（lfence）</h4><p>保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据（可见性），</p><p>会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前（有序性）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 读屏障，在这之后的所有共享变量的读取都会加载内存中的值</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">     num++;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java内存模型 JMM(Java Memory Mode)</p><p><a href="https://zhuanlan.zhihu.com/p/29881777">链接1</a></p><p><a href="https://www.jianshu.com/p/8a58d8335270">链接2</a></p><h2 id="jdk提供的原子类型"><a href="#jdk提供的原子类型" class="headerlink" title="jdk提供的原子类型"></a>jdk提供的原子类型</h2><p><a href="https://blog.csdn.net/qq_37989738/article/details/106053608">链接</a></p><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul><li>AtomicReference (无法解决ABA问题)</li><li>AtomicMarkableReference（带版本号的原子应用，解决ABA问题，可追踪修改）</li><li>AtomicStampedReference （带修改标记，只辨别是否存在ABA）</li></ul><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 （java.lang.IllegalArgumentException: Must be volatile type）。</p><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><p>在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p><p><a href="https://segmentfault.com/a/1190000015865714">链接</a></p><h2 id="JDK提供的线程池"><a href="#JDK提供的线程池" class="headerlink" title="JDK提供的线程池"></a>JDK提供的线程池</h2><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量。目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值。</p><table><thead><tr><th>状态名</th><th>高三位</th><th>是否执行阻塞队列任务</th><th>是否接收新任务</th><th>说明</th></tr></thead><tbody><tr><td>RUNNABLE</td><td>111</td><td>是</td><td>是</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>是</td><td>否</td><td>不会接收新任务，<br> 但会处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>否</td><td>否</td><td>会中断正在执行的任务，<br>并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>否</td><td>否</td><td>任务全执行完毕，<br>活动线程为 0 即将进入终结状态</td></tr><tr><td>TERMINATED</td><td>011</td><td>否</td><td>否</td><td>终结状态</td></tr></tbody></table><p><img src="/2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210125223403356.png" alt="image-20210125223403356"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime, // 急救线程生存时间</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit, //时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory, //创建线程的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler //拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span></span></span><br></pre></td></tr></table></figure><h3 id="Executors类中用工厂方法提供以下常用线程池"><a href="#Executors类中用工厂方法提供以下常用线程池" class="headerlink" title="Executors类中用工厂方法提供以下常用线程池"></a>Executors类中用工厂方法提供以下常用线程池</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程数固定，核心线程数 == 最大线程数（没有救急线程被创建），阻塞队列是无界的，可以放任意数量的任务.</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，全部都是救急线程（空闲60s 后可以回收），队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）适合任务数比较密集，但每个任务执行时间较短的情况。</p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><p><strong>比自己创建一个线程的优势：</strong></p><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一</p><p>个线程，保证池的正常工作。</p><p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改。（Executors.newFixedThreadPool(1) 初始时为1 ，可以强转ThreadPoolExecutor 对象后调用 setCorePoolSize 等方法进行修改。）</p><p>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因</p><p>此不能调用 ThreadPoolExecutor 中特有的方法。</p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行定时/延时任务。</p><h2 id="ThreadPoolExecutor原理分析"><a href="#ThreadPoolExecutor原理分析" class="headerlink" title="ThreadPoolExecutor原理分析"></a>ThreadPoolExecutor原理分析</h2><p><a href="https://blog.csdn.net/z_s_z2016/article/details/81674893?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161598942116780265477107%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161598942116780265477107&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-6-81674893.first_rank_v2_pc_rank_v29&utm_term=ThreadPoolExecutor">参考链接</a></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>底层是由内部类Node组成的<strong>单向</strong>链表，虚拟头节点。内部维护两个ReentrantLock，入队出队使用不同的锁，大大提高<strong>吞吐量</strong>。初始化时可指定其容量大小，没有默认Integer.MAX_VALUE（当入队速度大于出队速度时，有OOM风险）。</p><p><a href="https://blog.csdn.net/tonywu1992/article/details/83419448">参考链接</a></p><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>底层是一个<strong>双向</strong>链表，内部只有一个ReentrantLock。容量规则和LinkedBlockingQueue一致，但比它多了更多出队入队方法。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。<br><a href="https://blog.csdn.net/yanyan19880509/article/details/52562039">参考链接</a></p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>用数组实现的有界阻塞队列，初始化时必须指定容量。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>有优先级的阻塞队列，有个PriorityQueue优先队列的字段。添加元素必须实现Delayed接口。</p><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。我们称这种节点操作为“匹配”方式。<strong>和SynchronousQueue相比，LinkedTransferQueue多了一个可以存储的队列，与LinkedBlockingQueue相比，LinkedTransferQueue多了直接传递元素，少了用锁来同步。</strong></p><p><a href="https://blog.csdn.net/qq_38293564/article/details/80593821">参考链接</a></p><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p><code>Fork/Join</code>框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><p><a href="https://blog.csdn.net/qq_33404395/article/details/88879579?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161158892316780264071188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161158892316780264071188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88879579.first_rank_v2_pc_rank_v29&utm_term=Fork/Join&spm=1018.2226.3001.4187">链接1</a></p><h2 id="其他重要知识链接"><a href="#其他重要知识链接" class="headerlink" title="其他重要知识链接"></a>其他重要知识链接</h2><p><a href="https://blog.csdn.net/qq_35190492/article/details/104691668?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160881941716780277881196%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160881941716780277881196&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-104691668.first_rank_v2_pc_rank_v29&utm_term=juc">理解乐观锁与悲观锁</a></p><p><a href="https://blog.csdn.net/javazejian/category_6940462.html">java并发</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html">jdk线程使用</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘复习</title>
      <link href="2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
      <url>2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><p>数据挖掘一般是指从大量数据中通过算法搜索隐藏于其中的信息的过程（数据采矿）。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="数据挖掘的定义"><a href="#数据挖掘的定义" class="headerlink" title="数据挖掘的定义"></a>数据挖掘的定义</h2><h3 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h3><p>数据挖掘就是从<strong>大量</strong>数据中， 提取<strong>潜在的有用</strong>信息和知识的过程。</p><h4 id="商业层面"><a href="#商业层面" class="headerlink" title="商业层面"></a>商业层面</h4><p>数据挖掘就是一种商业信息处理技术。其主要特点是对大量业务数据进行<strong>抽取、转换、分析和建模处理，</strong>从中<strong>提取</strong>辅助商业决策的关键性数据。</p><h2 id="数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别"><a href="#数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别" class="headerlink" title="数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别"></a>数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别</h2><p><strong>本质区别:</strong>  数据挖掘是在<strong>没有明确假设</strong>的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有<strong>先前未知、有效和实用</strong>三个特征。其主要目标就是<strong>提高决策能力，能在过去的经验基础上预言未来趋势</strong>等。</p><h2 id="数据挖掘任务"><a href="#数据挖掘任务" class="headerlink" title="数据挖掘任务"></a>数据挖掘任务</h2><h3 id="预测任务"><a href="#预测任务" class="headerlink" title="预测任务"></a>预测任务</h3><p>根据其它属性的值<strong>预测</strong>特定属性的值，如<strong>分类</strong>、回归、<strong>离群点检测。</strong></p><h4 id="描述任务"><a href="#描述任务" class="headerlink" title="描述任务"></a>描述任务</h4><p>寻找概括数据中潜在联系的模式，如<strong>聚类分析、关联分析、演化分析、序列模式挖掘。</strong></p><h2 id="数据挖掘-入侵检查"><a href="#数据挖掘-入侵检查" class="headerlink" title="数据挖掘-入侵检查"></a>数据挖掘-入侵检查</h2><ul><li>入侵可以定义为任何**威胁网络资源(**如用户账号、文件系统、系统内核等)的完整性、机密性和可用性的行为。</li><li>大多数商业入侵检测系统主要使用<strong>误用检测策略</strong>，这种策略对已知类型的攻击通过规则可以较好地检测，但对新的未知攻击或已知攻击的变种则难以检测。</li><li>异常检测通过构建<strong>正常网络行为模型</strong>(称为特征描述)，来检测与特征描述<strong>严重偏离</strong>的新的模式。</li></ul><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><ul><li><p>数据清理：填写空缺数据，平滑噪声数据，识别、删除孤立点，解决不一致性。</p></li><li><p>数据集成：集成<strong>多个</strong>数据库，数据立方体或文件中的数据，存放到一个<strong>一致的数据存储设备</strong>中（需考虑<strong>一致性</strong>和<strong>冗余</strong>问题）。</p></li><li><p>数据变换： <strong>规范化</strong>和特征构造。</p></li></ul><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226175507783.png" alt="image-20201226175507783"></p><ul><li>数据归约：得到数据集的压缩表示及特征选择（从<strong>记录</strong>和<strong>维度</strong>两方面减少数据量）。</li><li>离散化：通过将属性域划分为区间，减少给定连续属性值的个数。</li></ul><h2 id="相似性度量"><a href="#相似性度量" class="headerlink" title="相似性度量"></a>相似性度量</h2><ul><li>曼哈顿（Manhattan）。</li><li>欧几（Euclidean）里得距离。</li><li>切比雪夫（Chebyshev）距离。</li></ul><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226172043250.png" alt="image-20201226172043250"></p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>分类的任务是对数据集进行学习并构造<strong>一个拥有预测功能的分类模型</strong>，用于预测未知样本的类标号。</p><ol><li>首先将数据集划分为2部分: <strong>训练集和测试集</strong>。</li><li>第一步:对训练集学习，<strong>构建分类模型</strong>。</li><li>第二步:用建好的分类模型<strong>对测试集分类</strong>。</li><li>最后，使用分类准确度高的分类模型对类标号未知的未来样本数据进行分类。</li></ol><h2 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h2><ul><li><strong>基于决策树的分类方法</strong></li><li><strong>贝叶斯分类方法</strong></li><li><strong>K-最近邻分类方法</strong></li><li>神经网络方法</li><li>支持向量机方法</li><li>集成学习方法</li><li>……</li></ul><h3 id="基于决策树的分类方法"><a href="#基于决策树的分类方法" class="headerlink" title="基于决策树的分类方法"></a>基于决策树的分类方法</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226204310765.png" alt="image-20201226204310765"></p><p><strong>注：信息增益越大，说明使用属性A划分后得样本子集越纯，越有利于分类。</strong></p><h3 id="贝叶斯分类方法（Bayes）"><a href="#贝叶斯分类方法（Bayes）" class="headerlink" title="贝叶斯分类方法（Bayes）"></a>贝叶斯分类方法（Bayes）</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226204425822.png" alt="image-20201226204425822"></p><h3 id="K-最近邻分类方法"><a href="#K-最近邻分类方法" class="headerlink" title="K-最近邻分类方法"></a>K-最近邻分类方法</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226204601861.png" alt="image-20201226204601861"></p><h2 id="其他度量指标"><a href="#其他度量指标" class="headerlink" title="其他度量指标"></a>其他度量指标</h2><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226210820366.png" alt="image-20201226210820366"></p><h3 id="精度-Precision"><a href="#精度-Precision" class="headerlink" title="精度(Precision)"></a>精度(Precision)</h3><p>正确分类的正例个数占<strong>分类为正例</strong>的样本个数的比例。</p><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226210831124.png" alt="image-20201226210831124"></p><h3 id="召回率-Recall"><a href="#召回率-Recall" class="headerlink" title="召回率(Recall)"></a>召回率(Recall)</h3><p>正确分类的正例个数占<strong>实际正例</strong>个数的比例。</p><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226210844810.png" alt="image-20201226210844810"></p><h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>聚类(Clustering)是将数据集划分为若干相似对象组成的多个组(group)或簇(cluster)的过程，使得同一组中对象间的相似度最大化，不同组中对象间的相似度最小化。或者说一个簇(clustc)就是由彼此相似的一组对象所构成的集合，不同簇中的对象通常不相似或相似度很低。</p><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226215550678.png" alt="image-20201226215550678"></p><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226220917508.png" alt="image-20201226220917508"></p><h1 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h1><p>发现对象与特征之间相互依赖的关系，通常是从给定的数据集中发现频繁出现的模式知识（又称为关联规则）。关联分析广泛用于市场营销、事务分析等领域。</p><h2 id="项集"><a href="#项集" class="headerlink" title="项集"></a>项集</h2><p>在关联分析中，包含0个或多个项的集合，称为项集，一个包含k个数据项的项集称为k-项集。</p><h2 id="频繁项集"><a href="#频繁项集" class="headerlink" title="频繁项集"></a>频繁项集</h2><p>一个项集的支持度<strong>大于或等于</strong>某个阈值，则称为频繁项集。</p><h2 id="支持度计数"><a href="#支持度计数" class="headerlink" title="支持度计数"></a>支持度计数</h2><p>一个项集的出现次数就是整个交易数据集中包含该项集的事务数，也称为该项集的支持度计数。</p><h2 id="支持度"><a href="#支持度" class="headerlink" title="支持度"></a>支持度</h2><p>一个项集的出现次数与数据集所有事务数的百分比称为该项集的支持度。</p><p>support(A -&gt; B) = support_count(A ∪ B) / N; (N表示数据集的事务数)</p><h2 id="置信度"><a href="#置信度" class="headerlink" title="置信度"></a>置信度</h2><p>置信度是一个数据集中包含A事务同时包含B事务的百分比，置信度确定B在包含A事务中出现的频繁程度，表示规则在数据集上的可靠性。</p><p>confidence(A-&gt;B) = support_count(A ∪ B) / support_count(A);</p><h2 id="强关联规则"><a href="#强关联规则" class="headerlink" title="强关联规则"></a>强关联规则</h2><p><strong>大于</strong>最<strong>小支持度阈值</strong>和最<strong>小置信度阈值</strong>的关联规则称为强关联规则。</p><h2 id="提升度"><a href="#提升度" class="headerlink" title="提升度"></a>提升度</h2><p>提升度（lift）是一种简单的相关度量。对于项集A和项集B，如果P(A ∪B) = P(A)P(B)，则A和B相互独立，否则存在某种依赖关系关联规则的前件项集A和后件项集B之间的<strong>依赖关系通过提升度计算</strong>。提升度可以评估项集A的出现是否能够促进项集B的出现。</p><p>lift(A,B) = confidence(A-&gt;B)/support(B);</p><p>lift(A,B) &gt; 1 ，表示A，B正相关。</p><p>lift(A,B) &lt; 1， 表示A， B负相关。</p><p>lift(A,B) = 1，表示A，B无关系。</p><h1 id="离群点挖掘"><a href="#离群点挖掘" class="headerlink" title="离群点挖掘"></a>离群点挖掘</h1><h2 id="离群点"><a href="#离群点" class="headerlink" title="离群点"></a>离群点</h2><p>离群点代表着数据集中少数“与众不同”的点。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>发现与大部分其他对象显著不同的对象，大部分数据挖掘方法都将这种差异信息视为噪声而丢弃。然而在一些应用中，<strong>罕见的数据可能蕴含着更大的研究价值。</strong>离群点挖掘就是<strong>分析数据并及时发现异常</strong>，比如:<strong>及时发现欺诈行</strong>为并采集必要措施，从而避免损失!</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>欺诈检查</li><li>天机预报</li><li>公共安全</li><li>医疗</li><li>入侵检测</li><li>电子商务</li></ul><h2 id="研究的主要问题"><a href="#研究的主要问题" class="headerlink" title="研究的主要问题"></a>研究的主要问题</h2><p>离群点挖掘就是通过某种方法<strong>找出</strong>数据集中“与众不同”的数据。</p><p>定义：如何定义和度量离群点。</p><p>方法：①基于统计的方法。②基于距离的方法。③基于密度的方法。</p><h3 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h3><p>离群点定义：一个点远离数据集中大部分点，就认为它是离群点。</p><p>离群点挖掘：定义一种度量方式，找出远离数据集中大部分点的数据点。</p><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201227165954007.png" alt="image-20201227165954007"></p><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201227165857067.png" alt="image-20201227165857067"></p><h3 id="基于相对密度的方法"><a href="#基于相对密度的方法" class="headerlink" title="基于相对密度的方法"></a>基于相对密度的方法</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201227164020839.png" alt="image-20201227164020839"></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      <categories>
          
          <category> 大学科目复习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2020/12/22/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/12/22/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>设计模式用于在特定条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>提高面向对象的软件系统的<strong>可维护性</strong>和<strong>可复用性</strong>是面向对象设计的核心问题之一。而面向对象的设计原则就是为支持可维护性和复用性而诞生。</p><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h3><p>一个类只负责一个功能领域中的相应职责。是实现<strong>高内聚、低耦合</strong>的指导方针。</p><h3 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h3><p>软件实体应该对扩展开放（可复用性），对修改关闭。</p><h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle, LSP)"></a>里氏代换原则(Liskov Substitution Principle, LSP)</h3><p>所有引用基类<strong>（父类）</strong>对象的地方都能透明地使用其子类的对象。<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</strong></p><h3 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle, DIP)"></a>依赖倒转原则(Dependence Inversion Principle, DIP)</h3><p>抽象类不应该依赖于细节，细节应该依赖于抽象。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><p>使用多个专门的接口。而不使用单一的总接口。</p><h3 id="合成复用原则-Composite-Reuse-Principle-CRP"><a href="#合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="合成复用原则(Composite Reuse Principle, CRP)"></a>合成复用原则(Composite Reuse Principle, CRP)</h3><p>尽量使用对象组合，而不是继承来达到复用的目的</p><h3 id="迪米特法则-Law-of-Demeter-LoD"><a href="#迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="迪米特法则(Law of Demeter, LoD)"></a>迪米特法则(Law of Demeter, LoD)</h3><p>一个软件实体应该尽可能少的与其他实体发生相互作用。</p><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p><a href="https://blog.csdn.net/LoveLion/article/details/17517213?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160854156216780308343733%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160854156216780308343733&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-17517213.first_rank_v2_pc_rank_v29&utm_term=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">参考链接1</a></p><p><a href="https://blog.csdn.net/jason0539/article/details/44956775">参考链接2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="2020/12/22/java/java%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/22/java/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>底层是Object[] elementData数组，默认大小DEFAULT_CAPACITY=10，使用空参构造时只是将默认的空数组赋值给elementData。在添加数据时先执行ensureCapacityInternal(size+1)方法判断容量是否够，先判断elementData是否等于默认空数组，若是，则容量初始化为Math.max(DEFAULT_CAPACITY【默认大小10】, minCapacity【当前所需容量最小大小】);否则若minCapacity大于当前容量，则调用grow方法以1.5倍扩容。</p><p><a href="https://www.cnblogs.com/zhangyinhua/p/7687377.html">链接</a></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>底层是使用静态内部类Node实现的双向链表。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层使用数组+链表/红黑二叉树。桶数组默认长度DEFAULT_INITIAL_CAPACITY是16，负载因子loadFactor默认是0.75，数组长度大于阈值会以两倍形式增长。添加数据哈希冲突时采用尾插法（注：jdk1.7及以前采用头插法，在多线程下可能导致死循环）。当链表的长度大于8，同时桶数组长度大于等于64时，将链表转为红黑二叉树。当桶中元素小于等于6时转为链表。</p><h3 id="哈希值计算"><a href="#哈希值计算" class="headerlink" title="哈希值计算"></a>哈希值计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">//用高16位参与异或运算，为了降低 hash 冲突的概率。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将(tab.length - 1) 与 hash值进行&amp;运算定位桶数组索引</span></span><br><span class="line"><span class="comment">// 注：对于2的n次方的求余，与2的n次方-1进行与运算结果相等，位运算效率更快</span></span><br><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash; </span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>底层直接使用HashMap的key存值。map的value统一存入一个不可变的object对象。</p><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>继承HashMap，每个结点在其基础上多了before, after。保证元素的有序性。还可以通过设置accessOrder为true将最近获取的元素移动至链表尾部。可用作简单缓存。也可通过继承自定义removeEldestEntry（）方法实现LRU算法实现新增数据时移除最久未使用元素。</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>线程安全。底层使用数组+链表。使用synchronized修饰方法。默认容量为11，rehash方法以2倍加1形式扩容。key/value也无法为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash值直接使用key的hash值</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">//&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ns_code/article/details/36191279">参考链接</a></p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>底层使用红黑二叉树。初始化时可指定排序规则。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>key/value都不允许为空。</strong></p><p>1.5~1.7前使用<strong>分段锁</strong>，把Map分成了N个Segment（相当于把Map拆分成N个小的HashTable），put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中，操作不同Segment不会锁冲突。<strong>扩容时不会对Segmengt数组增大，只会增加Segmengt 后面的链表容量的大小。即对每个Segmengt 的元素进行的ReHash操作。</strong></p><p>1.8后用cas+synchronized。</p><p><a href="%5Bhttps://blog.csdn.net/jjc120074203/article/details/78625433?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161295910616780264080489%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161295910616780264080489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-4-78625433.pc_search_result_before_js&utm_term=ConcurrentHashMap&spm=1018.2226.3001.4187%5D(https://blog.csdn.net/jjc120074203/article/details/78625433?ops_request_misc=%7B%22request_id%22:%22161295910616780264080489%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=161295910616780264080489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-4-78625433.pc_search_result_before_js&utm_term=ConcurrentHashMap&spm=1018.2226.3001.4187)">参考链接</a></p><p><a href="https://blog.csdn.net/sihai12345/article/details/79383766?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161295910616780264080489%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161295910616780264080489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-5-79383766.pc_search_result_before_js&utm_term=ConcurrentHashMap&spm=1018.2226.3001.4187">参考链接</a></p><h3 id="sizeCtl-定义理解"><a href="#sizeCtl-定义理解" class="headerlink" title="sizeCtl 定义理解"></a>sizeCtl 定义理解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">     * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">     * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">     * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">     * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">     * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line">源码注释翻译</span><br><span class="line">sizeCtl ：默认为<span class="number">0</span>，用来控制table的初始化和扩容操作</span><br><span class="line">-<span class="number">1</span> 代表table正在初始化</span><br><span class="line">-N 表示有N-<span class="number">1</span>个线程正在进行扩容操作（注：这里有问题）</span><br><span class="line">其余情况：</span><br><span class="line"><span class="number">1</span>、如果table未初始化，表示table需要初始化的大小。</span><br><span class="line"><span class="number">2</span>、如果table初始化完成，表示table的容量，默认是table大小的<span class="number">0.75</span>倍</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ConcurrentHashMap中有个大写的sizeCtl</span></span><br><span class="line">    <span class="comment">//这个大写的sizectl存的是sizeCtl的偏移量，在sizeCtl进行cas使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">     SIZECTL = U.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>这里-N的定义是有问题的，应该取-N对应的二进制的低16位数值为M，此时有M-1个线程进行扩容。</strong></p><p><a href="https://blog.csdn.net/Unknownfuture/article/details/105350537">参考链接</a></p><h2 id="集合相关参考链接"><a href="#集合相关参考链接" class="headerlink" title="集合相关参考链接"></a>集合相关参考链接</h2><p><a href="https://blog.csdn.net/woshimaxiao1/category_8298930.html">链接</a></p><p><a href="https://blog.csdn.net/v123411739/category_7410582.html">链接</a></p><h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><p><a href="https://blog.csdn.net/javazejian/article/details/71333103">链接</a></p><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><a href="https://blog.csdn.net/javazejian/article/details/70768369">链接</a></p><h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html#1java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">泛型擦除与多态冲突</a></p><p><a href="https://blog.csdn.net/hao_yan_bing/article/details/89447792">桥方法</a></p><h2 id="Java总结"><a href="#Java总结" class="headerlink" title="Java总结"></a>Java总结</h2><p><a href="https://blog.csdn.net/guorui_java/article/details/112391105">Java知识体系总结</a></p><p><a href="https://thinkwon.blog.csdn.net/article/details/104390612">面试参考</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>注：</strong></p><p><strong>非静态内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法。</strong></p><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>定义在一个类的内部，外部类的每个对象都会加载一次，不可以定义<strong>静态</strong>成员和方法，可访问外部类的所有私有字段/方法,</p><p><strong>对于私有字段，访问，编译器会生成一个access函数提供调用。</strong></p><p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215210428834.png" alt="image-20201215210428834"></p><p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215210440082.png" alt="image-20201215210440082"></p><p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215210446377.png" alt="image-20201215210446377"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;默认名&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> field = <span class="number">2.1f</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">也可用protected、private修饰内部类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Internal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name = <span class="string">&quot;内部类的默认name&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Internal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Internal</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印外部与内部字段</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//内部类也有重名字段时</span></span><br><span class="line">            <span class="comment">//默认访问内部类字段</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内部age：&quot;</span> + age); <span class="comment">//内部age：0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内部name：&quot;</span> + name); <span class="comment">//内部name：内部类的默认name</span></span><br><span class="line">            <span class="comment">// 访问外部类</span></span><br><span class="line">            System.out.println(<span class="string">&quot;外部age：&quot;</span> + InternalClass.age); <span class="comment">//外部age：9</span></span><br><span class="line">            System.out.println(<span class="string">&quot;外部name：&quot;</span> + InternalClass.<span class="keyword">this</span>.name); <span class="comment">//外部name：默认名</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回外部实例</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> InternalClass <span class="title">getOutClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> InternalClass.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Internal&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Internal internal = <span class="keyword">new</span> Internal();</span><br><span class="line">        <span class="comment">//外部类可以访问，修改内部类private字段</span></span><br><span class="line">        internal.age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(internal); <span class="comment">//Internal&#123;age=2, name=&#x27;内部类的默认name&#x27;&#125;</span></span><br><span class="line">        internal.name = <span class="string">&quot;修改后的内部name&quot;</span>;</span><br><span class="line">        System.out.println(internal.name); <span class="comment">// 修改后的内部name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InternalClass internalClass = <span class="keyword">new</span> InternalClass();</span><br><span class="line">        internalClass.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化内部类前必须先实例化外部类</span></span><br><span class="line">        Internal internal = internalClass.<span class="function">new <span class="title">Internal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        internal.printOut();</span><br><span class="line">        System.out.println(internalClass == internal.getOutClass());</span><br><span class="line"></span><br><span class="line">        Class1 class1 = <span class="keyword">new</span> Class1();</span><br><span class="line">        System.out.println(class1.age1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>定义载方法内部或作用域内，不能被public、private、static修饰。可以直接访问外部类的成员。外部类无法直接创建局部内部类的实例，局部内部类可直接使用成员内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outNUm = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义在方法内</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.8之后java隐式的将x修饰为final</span></span><br><span class="line">        <span class="keyword">int</span> test1Field = <span class="number">111</span>;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Method</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> num1 = outNUm * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//可直接访问成员内部类</span></span><br><span class="line">            InClass inClass = <span class="keyword">new</span> InClass();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问本地方法的变量：&quot;</span>+test1Field);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Method method = <span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(method.num1);</span><br><span class="line">        System.out.println(<span class="string">&quot;外部num2&quot;</span>+MethodClass.<span class="keyword">this</span>.num2);</span><br><span class="line">        System.out.println(method.num2);</span><br><span class="line"></span><br><span class="line">        method.method1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义在作用域内</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Partial</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                <span class="function"><span class="keyword">private</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Partial ts = <span class="keyword">new</span> Partial();</span><br><span class="line">            ts.id = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">            System.out.println(ts.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodClass methodClass = <span class="keyword">new</span> MethodClass();</span><br><span class="line">        methodClass.test1();</span><br><span class="line">        methodClass.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>局部内部类访问局部变量，局部变量必须加final修饰。</p><p>因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，局部对象还要使用这个局部变量。为了让数据还能继续被使用，就用fian1修饰局部变量，这样，在堆内存里面存储的其实是一个常量值。</p><p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215213854116.png" alt="image-20201215213854116"></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>一个接口的实现类，或者是继承于某个父类的子类，我们只使用一次。就可以使用匿名内部类。匿名内部类使用方法的本地变量也是要final修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.classes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.Parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Parents</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    Parents father = <span class="keyword">new</span> Parents() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匿名内部类：&quot;</span>+flag);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部字段&quot;</span>+num1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//lamber表达式</span></span><br><span class="line">    Parents mothor =  (e)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lamber实例化的匿名内部类：&quot;</span>+e);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Persion persion = <span class="keyword">new</span> Persion()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重写父类方法&quot;</span>);</span><br><span class="line">            <span class="keyword">super</span>.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">12</span>;</span><br><span class="line">        Persion p = <span class="keyword">new</span> Persion()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;在方法中使用后匿名内部类&quot;</span>);</span><br><span class="line">                System.out.println(tt);</span><br><span class="line">                <span class="keyword">super</span>.work();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnonymousInnerClass anonymousInnerClass = <span class="keyword">new</span> AnonymousInnerClass();</span><br><span class="line">        anonymousInnerClass.father.print(<span class="keyword">true</span>);</span><br><span class="line">        anonymousInnerClass.mothor.print(<span class="keyword">true</span>);</span><br><span class="line">        anonymousInnerClass.persion.work();</span><br><span class="line">        anonymousInnerClass.test1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>关键字static修饰，只能访问外部静态字段和方法，根成员内部类一样可以用public等修饰符修饰，不依赖于外部类，可直接外部类.内部类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = num;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化静态内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印如下：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 初始化静态内部类</span></span><br><span class="line"><span class="comment">     * 静态内部方法</span></span><br><span class="line"><span class="comment">     * test</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticClass.print();</span><br><span class="line">        StaticClass staticClass = <span class="keyword">new</span> StaticClass();</span><br><span class="line">        staticClass.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程</title>
      <link href="2020/12/12/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>2020/12/12/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2020/12/12/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-20201212194346694.png" alt="image-20201212194346694"></p><h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><h3 id="在加载类时，Java-虚拟机必须完成以下3件事情"><a href="#在加载类时，Java-虚拟机必须完成以下3件事情" class="headerlink" title="在加载类时，Java 虚拟机必须完成以下3件事情"></a>在加载类时，Java 虚拟机必须完成以下3件事情</h3><ol><li>通过类的全名，获取类的二进制数据流。</li><li>解析类的二进制数据流，在<strong>方法区</strong>中构建Java<strong>类模板对象</strong>。</li><li>在<strong>堆</strong>中创建java. lang. Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</li></ol><p>注：</p><ul><li><strong>类模板对象</strong>，是Java类在JVM内存中的一个快照，JVM将 从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成 员变量进行遍历，也能进行Java方法的调用。反射的机制即基于这一基础。 如果JVM没 有将Java类的声明信息存储起来，则JVM在 运行期也无法反射。</li><li><strong>数组类</strong>本身不是由类加载器负责创建的，JVM在加载数组的时候加载的仅仅是数组的类型类（如String[] 加载String这个类型类），而数组的创建则由JVM在运行时根据需要直接创建的。如果是N维数组，类加载器会从最外层开始一层一层的递归加载，直到加载到非数组类型为止。</li></ul><h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><ul><li><p>通过文件系统读入一个class后缀的文件(最常见) 。</p></li><li><p>读入jar、zip等归档数据包，提取类文件。</p></li><li><p>事先存放在数据库中的类的二进制数据。</p></li><li><p>使用类似于HTTP之类的协议通过网络进行加载。</p></li><li><p>在运行时生成一段Class的二进制信息。</p></li><li><p>……</p></li></ul><h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><h3 id="Verification-验证"><a href="#Verification-验证" class="headerlink" title="Verification(验证)"></a>Verification(验证)</h3><p><strong>目的是保证加载的字节码是合法、合理并符合规范的。</strong></p><ol><li><p><strong>格式检查</strong></p><p> 魔数检查（class文件前四个字节的16进制是不是0xCAFEBABE）。</p><p> 版本检查（高版本Java编译器编译出来的class文件无法在低版本运行）。</p><p> 长度检查（数据项的码，每一项长度是否正确）。</p></li><li><p><strong>语义检查</strong></p><p> 是否有类继承final（被定义为final的方法或者类无法被重写或继承）。</p><p> 是否有父类（在Java里，除了object外，其他类都应该有父类）。</p><p> 抽象方法是否有实现 （非抽象类是否实现了所有抽象方法或者接口方法）。</p><p> 是否存在不兼容的方法(比如方法的签名除了返回值不同，其他都一样， 这种方法会让虚拟机无从下手调度; abstract情况下的方法，就不能是final的了)。</p></li><li><p><strong>字节码验证</strong></p><p> 跳转指令是否指向正确位置（在字节码的执行过程中，是否会跳转到一条不存在的指令）。</p><p> 变量的赋值是不是给了正确的数据类型。</p><p> 函数的调用是否传递了正确类型的参数。</p></li><li><p><strong>符号引用验证</strong></p><p> 符号引用的直接引用是否存在（Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。虚拟机会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError ,如果一个 方法无法被找到，则会抛出NoSuchMethodError）。</p></li></ol><h3 id="Preparation-准备"><a href="#Preparation-准备" class="headerlink" title="Preparation(准备)"></a>Preparation(准备)</h3><p>虚拟机会为该类分配内存空间并为静态字段设置默认值</p><table><thead><tr><th>类型</th><th>默认初始值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><p>注：</p><ol><li>这里不包含基本数据类型的字段用static final修饰的情况， 因为final在编译的时候就会分配了，准备阶段会显式赋值。</li><li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </li></ol><h3 id="Resolution-解析"><a href="#Resolution-解析" class="headerlink" title="Resolution(解析)"></a>Resolution(解析)</h3><p>将类、接口、字段和方法符号引用转为直接引用。</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。在Class类文件中，通过常量池进行了大量的符号引用。解析操作会把符号引用转为对应目标的直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>执行类的初始化方法：&lt; clinit&gt;();，该方法由Java编译器生成并由JVM调用，开发者无法自定义它，它是由类静态成员到的赋值语句及static代码块语句合并而产生的。即初始化阶段为类的静态变量赋予正确的初始值。</p><p>注：在加载一个类前，会先加载其父类，因此父类的clinit方法总在子类前被调用。</p><p><strong>没有类初始化方法的情况</strong></p><ul><li>一个类中并没有声明任何的类变量，也没有静态代码块时。</li><li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。</li><li>一个类中只包含static final修饰的<strong>基本数据类型</strong>的字段，这些类字段初始化语句采用编译时<strong>常量表达式</strong>。</li></ul><p>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行。对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-clinit-gt-的调用"><a href="#lt-clinit-gt-的调用" class="headerlink" title="&lt; clinit&gt;()的调用"></a>&lt; clinit&gt;()的调用</h3><h4 id="类的主动使用：意味着会调用类的-lt-clinit-gt"><a href="#类的主动使用：意味着会调用类的-lt-clinit-gt" class="headerlink" title="类的主动使用：意味着会调用类的&lt; clinit&gt;()"></a>类的主动使用：意味着会调用类的&lt; clinit&gt;()</h4><ol><li>当创建一个类的实例时，比如使用new关键字，或者通过反射（如Class.forName(“com.atguigu.java.Test”)）、克隆、反序列化。</li><li>当调用类的静态方法时，即当使用了字节码invokestatic指令。</li><li>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化（<strong>并不会先初始化它所实现的接口**</strong>，在初始化一个接口时，并不会先初始化它的父接口，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。）。</li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</li></ol><h4 id="类的被动使用：即不会进行类的初始化操作，即不会调用-lt-clinit-gt"><a href="#类的被动使用：即不会进行类的初始化操作，即不会调用-lt-clinit-gt" class="headerlink" title="类的被动使用：即不会进行类的初始化操作，即不会调用&lt; clinit&gt;()"></a>类的被动使用：即不会进行类的初始化操作，即不会调用&lt; clinit&gt;()</h4><ol><li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。（当通过子类引用父类的静态变量，不会导致子类初始化）</li><li>通过数组定义类引用，不会触发此类的初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objectList = <span class="keyword">new</span> Object[<span class="number">10</span>];<span class="comment">//执行此句并不会使Object类的&lt; clinit&gt;()被调用</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p></li><li><p>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p></li></ol><p><strong>注：没有初始化的类，不意味着没有加载！</strong></p><h2 id="使用阶段"><a href="#使用阶段" class="headerlink" title="使用阶段"></a>使用阶段</h2><p>即可直接使用，调用它的静态字段、方法。使用new关键字创建实例对象。</p><h2 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h2><p><strong>条件</strong></p><ul><li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收。</li><li>该类对应的java. lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li><li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一一样，没有引用了就必然会回收。</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>class字节码文件结构</title>
      <link href="2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="class字节码文件结构"><a href="#class字节码文件结构" class="headerlink" title="class字节码文件结构"></a>class字节码文件结构</h2><table><thead><tr><th>类型</th><th>名称</th><th>说明</th><th>长度</th><th>数量</th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>魔数,识别Class文件格式</td><td>4个字节</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>副版本号(小版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>主版本号(大版本)</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>常量池计数器</td><td>2个字节</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>常量池表</td><td>n个字节</td><td>constant_pool_count-1</td></tr><tr><td>u2</td><td>access_flags</td><td>访问标识</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>父类索引</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>接口计数器</td><td>2个字节</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>接口索引集合</td><td>2个字节</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>字段计数器</td><td>2个字节</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>字段表</td><td>n个字节</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>方法计数器</td><td>2个字节</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>方法表</td><td>n个字节</td><td>methods_count</td></tr><tr><td>u2</td><td>attributes_count</td><td>属性计数器</td><td>2个字节</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>属性表</td><td>n个字节</td><td>attributes_count</td></tr></tbody></table><h2 id="Class文件版本号和平台的对应"><a href="#Class文件版本号和平台的对应" class="headerlink" title="Class文件版本号和平台的对应"></a>Class文件版本号和平台的对应</h2><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><h2 id="class文件数据类型"><a href="#class文件数据类型" class="headerlink" title="class文件数据类型"></a>class文件数据类型</h2><table><thead><tr><th>数据类型</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>无符号数</td><td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td><td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td></tr><tr><td>表</td><td>表是由多个无符号数或其他表构成的复合数据结构。</td><td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a>类型描述符</h2><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型byte</td></tr><tr><td>C</td><td>基本数据类型char</td></tr><tr><td>D</td><td>基本数据类型double</td></tr><tr><td>F</td><td>基本数据类型float</td></tr><tr><td>I</td><td>基本数据类型int</td></tr><tr><td>J</td><td>基本数据类型long</td></tr><tr><td>S</td><td>基本数据类型short</td></tr><tr><td>Z</td><td>基本数据类型boolean</td></tr><tr><td>V</td><td>代表void类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table><h2 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h2><table><thead><tr><th>类型</th><th>标志(或标识)</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><h2 id="常量类型和结构细节"><a href="#常量类型和结构细节" class="headerlink" title="常量类型和结构细节"></a>常量类型和结构细节</h2><p><img src="/2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1598773300484.png" alt="1598773300484"></p><p><img src="/2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1598773308492.png" alt="1598773308492"></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><h2 id="字段表访问标志"><a href="#字段表访问标志" class="headerlink" title="字段表访问标志"></a>字段表访问标志</h2><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否为public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否为private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否为protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否为static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否为final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否为volatile</td></tr><tr><td>ACC_TRANSTENT</td><td>0x0080</td><td>字段是否为transient</td></tr><tr><td>ACC_SYNCHETIC</td><td>0x1000</td><td>字段是否为由编译器自动产生</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否为enum</td></tr></tbody></table><h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><table><thead><tr><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>this_class</td></tr><tr><td>u2</td><td>super_class</td></tr><tr><td>u2</td><td>interfaces_count</td></tr><tr><td>u2</td><td>interfaces[interfaces_count]</td></tr></tbody></table><h2 id="属性的通用格式"><a href="#属性的通用格式" class="headerlink" title="属性的通用格式"></a>属性的通用格式</h2><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>含义</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td><td>属性名索引</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td><td>属性长度</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td><td>属性表</td></tr></tbody></table><h2 id="数据类型和默认初始值对应"><a href="#数据类型和默认初始值对应" class="headerlink" title="数据类型和默认初始值对应"></a>数据类型和默认初始值对应</h2><table><thead><tr><th>类型</th><th>默认初始值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>IP地址是<a href="https://baike.baidu.com/item/IP%E5%8D%8F%E8%AE%AE/131947">IP协议</a>提供的一种统一的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F/53569124">地址格式</a>，它为互联网上的每一个网络和每一台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>分配一个<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/3283849">逻辑地址</a>，以此来屏蔽<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2901583">物理地址</a>的差异。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>每一类地址都由两个固定长度的字段组成，其中一个字段是网络号<strong>net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号<strong>host-id</strong>，它标志该主机（或路由器）。</p><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201206132449004.png" alt="image-20201206132449004"></p><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201206132458995.png" alt="image-20201206132458995"></p><h3 id="各类-IP-地址的网络号字段和主机号字段"><a href="#各类-IP-地址的网络号字段和主机号字段" class="headerlink" title="各类 IP 地址的网络号字段和主机号字段"></a><strong>各类</strong> <strong>IP</strong> <strong>地址的网络号字段和主机号字段</strong></h3><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201206132538023.png" alt="image-20201206132538023"></p><h3 id="各类网络号范围"><a href="#各类网络号范围" class="headerlink" title="各类网络号范围"></a>各类网络号范围</h3><ul><li>A类0.0.0.0到127.255.255.255</li><li>B类128.0.0.0到191.255.255.255</li><li>C类192.0.0.0到223.255.255.255</li><li>D类224.0.0.0到239.255.255.255</li><li>E类240.0.0.0到247.255.255.255</li></ul><h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><a href="https://blog.csdn.net/qq_26442553/article/details/82761882">链接</a></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="良心知识链接"><a href="#良心知识链接" class="headerlink" title="良心知识链接"></a>良心知识链接</h3><p><a href="https://www.kancloud.cn/spirit-ling/http-study/1412541">基础知识</a></p><p><a href="https://blog.csdn.net/sinat_34166518/article/details/83584910">HTTP头部</a></p><p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP和HTTPS协议</a></p><p><a href="https://segmentfault.com/a/1190000021559557?utm_source=sf-related">HTTPS连接过程</a></p><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">http的三次握手与四次挥手</a></p><p><a href="https://blog.csdn.net/xiaofei0859/article/details/6044694">MSL（Maximum Segment Lifetime报文最大生存时间）</a></p><p><a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么</a></p><p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接与短连接，实质上是TCP的长连接</a></p><p><a href="https://www.cnblogs.com/chenqf/p/6386163.html#!comments">Http缓存原理</a></p><p><a href="https://www.cnblogs.com/heluan/p/8620312.html">HTTP1.0/1.1/2.0区别</a></p><p>注：</p><p>HTTP/1.1协议的长连接有两种工作方式，即非流水线方式(without pipelining)和流水线方式(with pipelining)。</p><ul><li><p>非流水线方式在收到前一个响应后才能发出下一个请求。因此，在TCP连接已建立后，客户每访问一次对象都要用去一个往返时间RTT。这比非持续连接要用去两倍RTT的开销，节省了建立TCP连接所需的一个RTT时间。但非流水线方式还是有缺点的，因为服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</p></li><li><p>流水线方式的特点，是客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问所有的对象只需花费一个RTT时间。流水线工作方式使TCP连接中的空闲时间减少，提高了下载文档效率。</p></li></ul><h3 id="HTTP-1-1流水线-和-HTTP-2多路复用区别"><a href="#HTTP-1-1流水线-和-HTTP-2多路复用区别" class="headerlink" title="HTTP / 1.1流水线 和 HTTP / 2多路复用区别"></a>HTTP / 1.1流水线 和 HTTP / 2多路复用区别</h3><p>HTTP / 1.1流水线操作仍然要求按请求的顺序完整地返回请求。</p><p>HTTP / 2允许将请求响应拆分为块并以混合的方式返回，从而避免<strong>行头阻塞</strong>（Head of line【HOL】通常是指每个浏览器/客户端与服务器的连接数量有限，并且对其中一个连接进行新请求必须先等待这些连接完成，然后才能完成行首请求阻止后续请求。HTTP / 2通过引入多路复用来解决此问题，以便发出新的请求）。 </p><p><strong>TCP头阻塞行</strong> HTTP / 2仍然受到影响来自另一种HOL，即TCP级别。 TCP流中一个丢失的数据包使，使窗口停止，流一直等待，直到重新发送和接收该包为止。HTTP / 3正在通过QUIC协议（UDP实现）来解决该HOL问题。</p><p><a href="https://blog.csdn.net/jin970505/article/details/78982151">DNS协议详解</a></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">TCP详解</a></p><p><a href="https://blog.csdn.net/whgtheone/article/details/80983882">快重传</a></p><h2 id="网络协议、socket、webSocket"><a href="#网络协议、socket、webSocket" class="headerlink" title="网络协议、socket、webSocket"></a><a href="https://blog.csdn.net/yjclsx/article/details/80922951?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161477445216780264030367%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161477445216780264030367&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-80922951.first_rank_v2_pc_rank_v29&utm_term=websocket%E6%B7%B1%E5%85%A5">网络协议、socket、webSocket</a></h2><p><a href="https://blog.csdn.net/frank_good/article/details/50856585">webSocket原理</a></p><h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190324093704786.png" alt="TCP报文"></p><h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1911111249535K.png" alt="UDP报文"></p><h3 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h3><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20160216233020326.png" alt="IP报文"></p><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><p><img src="/2020/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/d695563104ebf6a7d481be9fffee1c324a184f26.gif" alt="HTTP报文"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收器（Garbage Collector）</title>
      <link href="2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="查看默认的垃圾收集器"><a href="#查看默认的垃圾收集器" class="headerlink" title="查看默认的垃圾收集器"></a>查看默认的垃圾收集器</h2><ol><li>运行时带上JVM参数-XX: +PrintCommandLineFlags:查看命令行相关参数(包含使用的垃圾收集器) 。</li><li>使用命令行指令: jinfo -flag  相关垃圾回收器参数  进程ID。</li></ol><h2 id="GC的性能指标"><a href="#GC的性能指标" class="headerlink" title="GC的性能指标"></a>GC的性能指标</h2><ul><li><strong>吞吐量</strong>: 运行用户代码的时间占总运行时间的比例(总运行时间:程序的运行时间+内存回收的时间)。</li><li><strong>垃圾收集开销</strong>: 吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>: 执行垃圾收集时，程序的工作线程被暂停的时间。</li><li><strong>收集频率</strong>: 相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>:  Java堆区所占的内存大小。</li><li><strong>快速</strong>: 一个对象从诞生到被回收所经历的时间。</li></ul><h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201202233303029.png" alt="image-20201202233303029"></p><ul><li>红色虚线：在JDK 8时将Serial+CMS、ParNew+Serial Oldd这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了<br>  这些组合的支持(JEP214)。</li><li>绿色虚线：在jdk14中弃用Paral1el Scavenge 和Serial0ld GC组合(JEP366)</li><li>青色虚线：在jdk14中:删除CMS垃圾回收器(JEP 363)</li></ul><h2 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>第一款GC，1999年随jdk1.3发布，<strong>负责回收年轻代</strong>。HotSpot中Client模式下的默认新生代垃圾收集器。<strong>采用复制算法</strong>、在HotSpot虚拟机中，使用-XX:+UseSerialGC 指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC， 且老年代用Serial Old GC。</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p><strong>负责回收老年代</strong>，内存回收算法使用的是<strong>标记-压缩算法</strong>。是运行在Client模式下默认的老年代的垃圾回收器。在Server模式下主要有两个用途: 与新生代的Parallel Scavenge配合使用或作为老年代CMS收集器的后备垃圾收集方案。</p><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>串行回收器意味着使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束(Stop The World)。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203155200633.png" alt="image-20201203155200633"></p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>简单而高效</strong>(与其他收集器的单线程比)，<strong>单CPU</strong>的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。一般用于用户的桌面应用等资源有限环境。</p><h2 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h2><h2 id="ParNew（Parallel-New）"><a href="#ParNew（Parallel-New）" class="headerlink" title="ParNew（Parallel New）"></a>ParNew（Parallel New）</h2><p><strong>负责回收年轻代</strong>，相当于Serial的多线程版，在多CPU的环境下，充分利用多CPU、多核心等物理硬件资源优势。采用<strong>复制算法</strong>。ParNew是很多JVM运行在<strong>Server模式下新生代的默认垃圾收集器。</strong></p><h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203155249152.png" alt="image-20201203155249152"></p><h3 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h3><p>在单个CPU的环境下，ParNew收集 器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的-一些额外开销。除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</p><p>-XX: +UseParNewGC 指定ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX:ParallelGCThreads 指定线程数量，默认开启和CPU数据相同的线程数。</p><h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>jdk1.6后默认使用，<strong>负责回收年轻代</strong>。采用了复制算法、并行回收。和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，它也被称为<strong>吞吐量优先</strong>（高吞吐量可以充分利用CPU）的垃圾收集器。自适应调节策略也是Parallel Scavenge 与ParNew一个重要区别。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置:"></a>参数配置:</h3><p>-XX: +UseParallelGC  指定年轻代使用Parallel。</p><p>-XX:+UseParallel0ldGC 指定老年代都是使用并行回收收集器。</p><p>分别适用于新生代和老年代。默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。(互相激活)。</p><p>-XX: ParallelGCThreads设置年轻代并行收集器的线程数。一般地与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><p>在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量。当CPU数量大于8个， ParallelGCThreads的值等于3+ [5*CPU_ Count]/8]。</p><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</p><p>-XX: GCTimeRatio 垃圾收集时间占总时间的比例( 1 / (N+ 1))。用于衡量吞吐量的大小。取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。与前一个-XX:MaxGCPauseMillis参数有一 定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p><p>-XX: +UseAdaptiveSizePolicy ,设置Parallel Scavenge收集器具有自适应调节策略<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、 晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿<br>时间之间的平衡点。</p><h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p><strong>负责回收老年代</strong>，用来代替老年代的Serial 0ld收集器。采用了标记-压缩算法，基于并行回收和”Stop- the-World”机制。</p><h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203155328057.png" alt="image-20201203155328057"></p><h3 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h3><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld 收集器的组合，在Server模式下的内存回收性能很不错。在jdk8中，默认是此垃圾收集器。</p><h2 id="并发回收器"><a href="#并发回收器" class="headerlink" title="并发回收器"></a>并发回收器</h2><h3 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h3><p><strong>负责回收老年代</strong>，jdk1.5推出，采用<strong>标记-清除算法</strong>，并且也会”Stop- the-world”。是HotSpot虚拟机中<strong>第一 款</strong>真正意义上的<strong>并发收集器</strong>，它第一次实现了让<strong>垃圾收集线程与用户线程同时工作</strong>（<strong>低延迟</strong>）。缩短垃圾收集时间、用户线程的停顿时。</p><h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203152900355.png" alt="image-20201203152900355"></p><h4 id="初始标记阶段-Initial-Mark"><a href="#初始标记阶段-Initial-Mark" class="headerlink" title="初始标记阶段(Initial-Mark)"></a>初始标记阶段(Initial-Mark)</h4><p>会出现“Stop- the-World”，只标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p><h4 id="并发标记阶段-Concurrent-Mark"><a href="#并发标记阶段-Concurrent-Mark" class="headerlink" title="并发标记阶段(Concurrent-Mark)"></a>并发标记阶段(Concurrent-Mark)</h4><p>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p><h4 id="重新标记阶段-Remark"><a href="#重新标记阶段-Remark" class="headerlink" title="重新标记阶段(Remark)"></a>重新标记阶段(Remark)</h4><p>在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p><h4 id="并发清除阶段-Concurrent-Sweep"><a href="#并发清除阶段-Concurrent-Sweep" class="headerlink" title="并发清除阶段(Concurrent -Sweep)"></a>并发清除阶段(Concurrent -Sweep)</h4><p>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。</p><h3 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h3><ol><li><p>CMS无法与JDK 1.4 中已经存在的新生代收集器Paral1el Scavenge配合工作，所以在jdk1. 5中使用时，新生代只能选择ParNew或者Serial收集器中的一个。</p></li><li><p>在CMS回收过程中，为确保应用程序用户线程有足够的内存可用。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收。若CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure“失败，这时虚拟机将启动后备预案Serial 0ld收集器来重新进行老年代的垃圾收集，停顿时间变长了。</p></li><li><p>jdk9将CMS标记Deprecate（弃用），jdk14将其移除</p></li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>-XX: +UseConcMarkSweepGC手动指定使用CMS收集器。开启该参数后会自动将-XX: +UseParNewGC打开。 即: ParNew (Young区<br>用) +CMS (Old区用) +Serial Old的组合。</p><p>-XX: CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值，jdk1.5及其以前默认68%，1.6以上默认92%。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Serial GC：最小化地使用内存和并行开销。</p><p>Parallel GC：最大化应用程序的吞吐量。</p><p>CMS GC：最小化Gc的中断或停顿时间。</p><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>jdk9默认使用，在延迟可控的情况下获得尽可能高的吞吐量。<strong>主要针对多核CPU以及大量内存的机器</strong>，兼顾<strong>年轻代和老年代</strong>的回收。将堆内存（Eden、survivor1、survivor2、老年代等）分割成很多不相关的区域（Region，物理上可不连续）。后台维护一个以回收时间和回收价值排序的优先列表，region作为基本回收单位，每次回收只需要回收部分Region区。</p><p>JVM使用Remembered Set解决一个对象被不同Region区引用问题，避免全局扫描，每个Region都有一个对应的Rememberd Set（用来判断对象是否存活），若写入的数据有引用其他Region区的数据时，会去更新被引用数据的Region的Rememberd  Set。</p><h3 id="Region分区图"><a href="#Region分区图" class="headerlink" title="Region分区图"></a>Region分区图</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205151643878.png" alt="image-20201205151643878"></p><p>注：空白为未使用区，humongous主要是为了存储大对象若对象超过0.5个Region时，就放到humongous区。</p><h3 id="工作流程-4"><a href="#工作流程-4" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205151949513.png" alt="image-20201205151949513"></p><h4 id="年轻代并行GC"><a href="#年轻代并行GC" class="headerlink" title="年轻代并行GC"></a>年轻代并行GC</h4><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205153301399.png" alt="image-20201205153301399"><br>1.扫描根。<br>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><p>2.更新RSet.<br>处理dirty card queue中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><p>注：对于应用程序的引用赋值语句bject.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队-个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</p><p>3.处理RSet。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><p>4.复制对象。<br>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段,Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><p>处理引用。<br>处理Soft，Weak，Phantom， Final， JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p><h4 id="并发标记过程"><a href="#并发标记过程" class="headerlink" title="并发标记过程"></a>并发标记过程</h4><p>1.初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</p><p>2.根区域扫描(Root Region Scanning) : 扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</p><p>3.并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例，默认超过65%再回收阶段才会被回收)。</p><p>4.再次标记(Remark): 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法: snapshot-at-the-beginning (SATB)。</p><p>5.独占清理(cleanup,STW): 计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集。</p><p>6.并发清理阶段:识别并清理完全空闲的区域。</p><h4 id="导致Full-GC的原因"><a href="#导致Full-GC的原因" class="headerlink" title="导致Full GC的原因"></a>导致Full GC的原因</h4><ul><li>Evacuation的时候没有足够的to-space来存放晋升的对象。</li><li>并发处理过程完成之前空间耗尽。</li></ul><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><p>Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact )算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p><h5 id="可预测的停顿时间模型-即-软实时soft-real-time"><a href="#可预测的停顿时间模型-即-软实时soft-real-time" class="headerlink" title="可预测的停顿时间模型(即:软实时soft real-time)"></a>可预测的停顿时间模型(即:软实时soft real-time)</h5><p>能明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<br>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p><p>G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>需要维护优先列表，需要更多的而外内存占用。</p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>-XX:+UseG1GC 指定使用G1回收器。</p><p>-XX: G1HeapRegionSize: 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p><p>-XX : MaxGCPauseMillis：设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms。</p><p>-XX: ParallelGCThread设 置STW工作线程数的值。最多设置为8 。</p><p>-XX: ConcGCThreads：设置并发标记的线程数。</p><p>-XX: InitiatingHeapOccupancyPercent设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p><h2 id="七种垃圾回收器对比"><a href="#七种垃圾回收器对比" class="headerlink" title="七种垃圾回收器对比"></a>七种垃圾回收器对比</h2><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205153827039.png" alt="image-20201205153827039"></p><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>使用-XX:+PrintGCDetails 打印GC日志</p><p>-Xloggc: path/gc_log. log 将日志输出到文件</p><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/1607148456(1).jpg" alt="1607148456(1)"></p><h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/1607148484(1).jpg" alt="1607148484(1)"></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库常见问题</title>
      <link href="2020/12/02/SQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/"/>
      <url>2020/12/02/SQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库索引失效情况"><a href="#数据库索引失效情况" class="headerlink" title="数据库索引失效情况"></a>数据库索引失效情况</h2><h3 id="查询条件中使用or"><a href="#查询条件中使用or" class="headerlink" title="查询条件中使用or"></a>查询条件中使用or</h3><p>​    注：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p><h3 id="查询使用is-null判断"><a href="#查询使用is-null判断" class="headerlink" title="查询使用is null判断"></a>查询使用is null判断</h3><ul><li>单列索引无法存储null，复合索引无法储存全为null的值。</li><li>索引是有序的，插入数据时需要对其进行比较，null无法比较，无法确定其位置。</li></ul><p>（解决，可自定义特定值替代null值，或使用复合索引）</p><h3 id="模糊查询使用-开头-如-like-‘-this’"><a href="#模糊查询使用-开头-如-like-‘-this’" class="headerlink" title="模糊查询使用%开头 如 like ‘%this’"></a>模糊查询使用%开头 如 like ‘%this’</h3><p>​    注：若不是%开头的模糊查询，如’XX%’，可用XX去匹配索引列，当碰到其他开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。以%开头的就难以定位，执行引擎可能更倾向于全表扫描。</p><h3 id="若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引"><a href="#若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引" class="headerlink" title="若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引"></a>若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引</h3><h3 id="存在类型转换"><a href="#存在类型转换" class="headerlink" title="存在类型转换"></a>存在类型转换</h3><p>如：整型字段条件却用字符(where num =  ‘123’)</p><h3 id="如果mysql估计使用全表扫描要比使用索引快-则不使用索引"><a href="#如果mysql估计使用全表扫描要比使用索引快-则不使用索引" class="headerlink" title="如果mysql估计使用全表扫描要比使用索引快,则不使用索引"></a>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</h3><p>如：表中列与列间的对比，在同一表中的两个列都建了索引，条件是where column1 = column2时，会被认为不如走全表扫描</p><h2 id="索引列的数据都一样时"><a href="#索引列的数据都一样时" class="headerlink" title="索引列的数据都一样时"></a>索引列的数据都一样时</h2><p>注：索引不应被建在数据几乎一样的列上</p><h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>​    B树索引底层使用多路平衡查找树，具有范围查找和前缀查找的能力，对于有N节点的B树，检索一条记录的复杂度为O(LogN)。相当于二分查找。InnoDB存储引擎的默认索引实现为:B+树索引。</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>　　哈希索引底层是Hash表只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。如果值的差异性相对较差，并且以范围查找为主，B树是更好的选择，它支持范围查找。</p><h2 id="MySQL8-0无法对表一个字段同时添加外键和check"><a href="#MySQL8-0无法对表一个字段同时添加外键和check" class="headerlink" title="MySQL8.0无法对表一个字段同时添加外键和check"></a>MySQL8.0无法对表一个字段同时添加外键和check</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 开课表</span><br><span class="line">(</span><br><span class="line">  开课号 <span class="built_in">CHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  课号 <span class="built_in">CHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  工号 <span class="built_in">CHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  开课地点 <span class="built_in">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">  开课学年 <span class="built_in">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">  开课学期 <span class="built_in">INT</span> ,</span><br><span class="line">  开课周数 <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">17</span>,</span><br><span class="line">  开课时间 <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  限选人数 <span class="built_in">INT</span>,</span><br><span class="line">  已选人数 <span class="built_in">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_开课表_开课号 PRIMARY <span class="keyword">KEY</span>(开课号),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_开课表_工号 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(工号) <span class="keyword">REFERENCES</span> 教师表(工号) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_开课表_课号 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(课号) <span class="keyword">REFERENCES</span> 课程表(课号) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> CK_开课表_开课号 <span class="keyword">CHECK</span>(开课号 regexp <span class="string">&#x27;[0-9][0-9][0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line">    <span class="comment">--以下来的字段约束无法添加，报错</span></span><br><span class="line">   <span class="comment">-- &gt; 3823 - Column &#x27;工号&#x27; cannot be used in a check constraint &#x27;CK_开课表_工号&#x27;: needed in a foreign key constraint &#x27;FK_开课表_工号&#x27; referential action.</span></span><br><span class="line"><span class="comment">--   CONSTRAINT CK_开课表_工号 CHECK(工号 regexp &#x27;T[0-9][0-9][0-9][0-9][0-9]&#x27;),</span></span><br><span class="line"><span class="comment">--   CONSTRAINT CK_开课表_课号 CHECK(课号 regexp &#x27;C[0-9][0-9][0-9][0-9][0-9]&#x27;)</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><strong>使用触发器替代check</strong></p><p>注：在MYSQL8.0前，CHECK只是一段可调用但无意义的子句，MySQL会直接忽略。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">delimiter $ <span class="comment">--更改结束符</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> CK_开课表_工号 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> 开课表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(new.工号 <span class="keyword">not</span> regexp <span class="string">&#x27;T[0-9][0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">signal <span class="keyword">sqlstate</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">set</span> message_text = <span class="string">&#x27;工号格式不对&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> CK_开课表_课号 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> 开课表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(new.课号 <span class="keyword">not</span> regexp <span class="string">&#x27;C[0-9][0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">signal <span class="keyword">sqlstate</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">set</span> message_text = <span class="string">&#x27;课号格式不对&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="Mysql用触发器实现修改同一字段"><a href="#Mysql用触发器实现修改同一字段" class="headerlink" title="Mysql用触发器实现修改同一字段"></a>Mysql用触发器实现修改同一字段</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--需求修改工号同时修改负责人</span></span><br><span class="line"><span class="comment">--错误写法--》会造成循环的调用.</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> jobNumber <span class="keyword">after</span> <span class="keyword">update</span> <span class="keyword">on</span> 教师表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">update</span> 教师表 <span class="keyword">set</span> 负责人 = new.工号 <span class="keyword">where</span> 教师表.工号 = new.工号;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">--正确写法</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> jobNumber <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">on</span> 教师表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> new.负责人 = new.工号;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h2 id="在存储过程中使用游标操作多个数据"><a href="#在存储过程中使用游标操作多个数据" class="headerlink" title="在存储过程中使用游标操作多个数据"></a>在存储过程中使用游标操作多个数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$  <span class="comment">--将sql分割符声明为$$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--创建名为insert_student_course的存储过程</span></span><br><span class="line"><span class="comment">--参数([in/out/inout] 参数名   参数类型)</span></span><br><span class="line"><span class="comment">--IN :   该参数可以作为输入，也就是需要调用方传入值 , 默认</span></span><br><span class="line"><span class="comment">--OUT:   该参数作为输出，也就是该参数可以作为返回值</span></span><br><span class="line"><span class="comment">--INOUT: 既可以作为输入参数，也可以作为输出参数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_student_course(<span class="keyword">IN</span> classNo <span class="built_in">varchar</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 需要定义接收游标数据的变量 DECLARE var_name[,...] type [DEFAULT value]</span></span><br><span class="line"><span class="keyword">DECLARE</span> s_no <span class="built_in">varchar</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> tcid <span class="built_in">varchar</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> has_data <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 声明游标DECLARE cursor_name CURSOR FOR select_statement ;</span></span><br><span class="line"><span class="keyword">DECLARE</span> cur1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">select</span> st.s_no, tc.tcid <span class="keyword">from</span> student_4954 st</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> teacher_course_4954 tc <span class="keyword">on</span> tc.class_no = st.class_no</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> course_4954 c <span class="keyword">on</span> c.cno = tc.cno</span><br><span class="line"><span class="keyword">where</span> st.class_no = classNo;</span><br><span class="line"><span class="comment">--钩子，在取不到数据时触发！！！下面循环结束条件需要！</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">set</span> has_data = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">-- 打开游标</span></span><br><span class="line">OPEN cur1;</span><br><span class="line"> <span class="comment">-- 开始循环</span></span><br><span class="line">REPEAT</span><br><span class="line"><span class="comment">--逐行取出crul的数据存入 s_no和tcid</span></span><br><span class="line">FETCH cur1 INTO s_no,tcid;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_course_4954 (s_no, tcid) <span class="keyword">values</span> (s_no, tcid);</span><br><span class="line">until has_data = 0</span><br><span class="line">  <span class="comment">--退出循环</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"><span class="comment">--关闭游标</span></span><br><span class="line">CLOSE cur1;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;<span class="comment">--将sql分割符声明回;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> insert_student_course(<span class="string">&#x27;1001&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/SkySuperWL/article/details/52583579">最左前缀匹配原则</a></p><p><a href="https://blog.csdn.net/u012422440/article/details/105257665">MySQL锁</a></p><p><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161184289216780299027777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161184289216780299027777&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-104778621.pc_search_result_before_js&utm_term=mysql%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187">mysql学习链接</a></p><p><a href="http://blog.itpub.net/22664653/viewspace-1140915/">double write</a></p><p><a href="https://blog.csdn.net/lzhcoder/article/details/88814364">binlog</a></p><p><a href="https://blog.csdn.net/u010002184/article/details/88526708?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161675714216780357281036%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161675714216780357281036&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-88526708.first_rank_v2_pc_rank_v29&utm_term=undolog+redolog">redo log/undo log/bin log区别</a> </p><p><a href="https://blog.csdn.net/huangjw_806/article/details/100927097">binlog与redolog一致性问题</a></p><p><a href="https://blog.csdn.net/qq_35246620/article/details/61200815?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161501483016780255275945%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161501483016780255275945&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-11-61200815.first_rank_v2_pc_rank_v29&utm_term=mysql+%E5%88%B7%E8%84%8F">深入理解MySQL事务</a></p><p><a href="https://www.jianshu.com/p/5a9c1e487ddd">MySQL InnoDB 的多版本并发控制（MVCC）</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常见指令笔记</title>
      <link href="2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/"/>
      <url>2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="查看内存CPU使用情况-Top"><a href="#查看内存CPU使用情况-Top" class="headerlink" title="查看内存CPU使用情况 Top"></a>查看内存CPU使用情况 Top</h2><img src="/2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/image-20201201160508354.png" alt="image-20201201160508354"><h4 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h4><p>当前时间16：04：49</p><p>系统已运行时间 188天4小时32分</p><p>当前登陆用户数 1个user</p><p>负载情况 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><h4 id="第二行："><a href="#第二行：" class="headerlink" title="第二行："></a>第二行：</h4><p>  Tasks（ 任务/进程）100个进程，其中处于运行中的有1个，99个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p><h4 id="第三行：cpu状态"><a href="#第三行：cpu状态" class="headerlink" title="第三行：cpu状态"></a>第三行：cpu状态</h4><p> us — 用户空间占用CPU的百分比。</p><p> sy — 内核空间占用CPU的百分比。</p><p> ni — 改变过优先级的进程占用CPU的百分比。</p><p> id — 空闲CPU百分比。</p><p> wa — IO等待占用CPU的百分比。</p><p> hi — 硬中断（Hardware IRQ）占用CPU的百分比。</p><p> si — 软中断（Software Interrupts）占用CPU的百分比 。</p><h4 id="第四行：内存状态"><a href="#第四行：内存状态" class="headerlink" title="第四行：内存状态"></a>第四行：内存状态</h4><p> total — 物理内存总量。</p><p> used — 使用中的内存总量。</p><p> free — 空闲内存总量。</p><p> buffers — 缓存的内存量 。</p><h4 id="第五行：swap交换分区"><a href="#第五行：swap交换分区" class="headerlink" title="第五行：swap交换分区"></a>第五行：swap交换分区</h4><p>total — 交换区总量。</p><p>used — 使用的交换区总量。</p><p>free — 空闲交换区总量。</p><p>cached — 缓冲的交换区总量。</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>PID — 进程id。</p><p>USER — 进程所有者。</p><p>PR — 进程优先级。</p><p>NI — nice值。负值表示高优先级，正值表示低优先级。</p><p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES。</p><p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA。</p><p>SHR — 共享内存大小，单位kb。</p><p> S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程。</p><p>%CPU — 上次更新到现在的CPU时间占用百分比。</p><p>%MEM — 进程使用的物理内存百分比。</p><p>TIME+ — 进程使用的CPU时间总计，单位1/100秒。</p><p>COMMAND — 进程名称（命令名/命令行）。</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><ul><li>b: 打开/关闭高亮效果。</li><li>x:打开/关闭排序列高亮效果。</li><li>shift + ‘&lt;’  或  ‘&gt;’ 向左向右改变排序列。</li><li>e修改进程列表单位显示，E修改前五行单位显示信息。</li></ul><h3 id="top-H-p-进程id-查看某进程的线程信息"><a href="#top-H-p-进程id-查看某进程的线程信息" class="headerlink" title="top -H -p [进程id] 查看某进程的线程信息"></a>top -H -p [进程id] 查看某进程的线程信息</h3><h2 id="free-h"><a href="#free-h" class="headerlink" title="free -h"></a>free -h</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>查看内存使用使用情况</p><p><img src="/2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/image-20201201170143345.png" alt="image-20201201170143345"></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="find-目录-条件-动作"><a href="#find-目录-条件-动作" class="headerlink" title="find [目录] [条件] [动作]"></a>find [目录] [条件] [动作]</h3><p>如 find . -name ‘name*’ 查找当前目录下以name开头的文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment"># find . -name &quot;name*&quot;</span></span><br><span class="line">./node_modules/continuation-local-storage/<span class="built_in">test</span>/namespaces.tap.js</span><br><span class="line">./node_modules/argparse/lib/namespace.js</span><br><span class="line">./node_modules/ast-types/gen/namedTypes.js</span><br><span class="line">./node_modules/ast-types/gen/namedTypes.d.ts</span><br><span class="line">./node_modules/@pm2/js-api/src/namespace.js</span><br></pre></td></tr></table></figure><h3 id="whitch"><a href="#whitch" class="headerlink" title="whitch"></a>whitch</h3><p>在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@~]<span class="comment"># which ps</span></span><br><span class="line">/usr/bin/ps</span><br></pre></td></tr></table></figure><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment"># whereis npm</span></span><br><span class="line">npm: /usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># whereis java</span></span><br><span class="line">java: /usr/java/jdk1.8.0_221/bin/java /usr/java/jdk1.8.0_221/jre/bin/java</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># whereis nodejs</span></span><br><span class="line">nodejs: /usr/<span class="built_in">local</span>/nodejs</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment">#  type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">[root@iZwz9 ~]<span class="comment">#  type npm</span></span><br><span class="line">npm is /usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment">#  type -p npm</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure><h2 id="防火墙（CentOS7）"><a href="#防火墙（CentOS7）" class="headerlink" title="防火墙（CentOS7）"></a>防火墙（CentOS7）</h2><h3 id="查看所有开放的端口号"><a href="#查看所有开放的端口号" class="headerlink" title="查看所有开放的端口号"></a><strong>查看所有开放的端口号</strong></h3><p>firewall-cmd –list-all</p><h3 id="查看指定端口是否已开放"><a href="#查看指定端口是否已开放" class="headerlink" title="查看指定端口是否已开放"></a>查看指定端口是否已开放</h3><p>firewall-cmd –query-port=6379/tcp</p><h3 id="设置开放的端口号"><a href="#设置开放的端口号" class="headerlink" title="设置开放的端口号"></a><strong>设置开放的端口号</strong></h3><p>firewall-cmd –add-port=80/tcp –permanent</p><h3 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a><strong>重启防火墙</strong></h3><p>firewall-cmd –reload</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><p>systemctl start firewalld</p><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a><strong>查看状态</strong></h3><p> systemctl status firewalld </p><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a><strong>停止</strong></h3><p> systemctl disable firewalld</p><h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a><strong>禁用</strong></h3><p>systemctl stop firewalld</p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h4><p>set nu</p><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><h4 id="删除光标所在行"><a href="#删除光标所在行" class="headerlink" title="删除光标所在行"></a>删除光标所在行</h4><p>dd</p><h4 id="删除n行"><a href="#删除n行" class="headerlink" title="删除n行"></a>删除n行</h4><p>dnd</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收相关概念及算法</title>
      <link href="2020/11/30/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
      <url>2020/11/30/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="判断对象存活方式"><a href="#判断对象存活方式" class="headerlink" title="判断对象存活方式"></a>判断对象存活方式</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>引用计数算法(Reference Counting) ，对每个对象保存<strong>一个整型的引用计数器属性</strong>。用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1;当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><p>实现简单，垃圾对象便于辨识;判定效率高，回收没有延迟性。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li><li>引用计数器有一个严重的问题，即无法处理循环引用的情况。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制,以提高吞吐量的尝试。</p><p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>引用计数算法，是很多语言的资源回收选择，如Python，同时支持引用计数和垃圾收集机制。</p><p>​    <strong>Python如何解决循环引用?</strong></p><p>​    手动解除: 就是在合适的时机，解除引用关系。使用弱引用weakref，weakref是Python提供的标准库， 旨在解决循环引用。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>可达性分析算法是以根对象集合(GC Roots[<strong>所谓”GC Roots”根集 合就是一组必须活跃的引用</strong>])为起始点，按照从上至下的方式搜索被根对象集合所<strong>连接的目标对象是否可达</strong>。使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链(Reference Chain)**，如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p><h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>Java的GC Roots包括以几类元素:</p><ol><li>虚拟机栈中引用的对象。如:各个线程被调用的方法中使用到的参数、局部变量等。</li><li>本地方法栈内JNI (通常说的本地方法)引用的对象</li><li>方法区中类静态属性引用的对象。如: Java类的引用类型静态变量</li><li>方法区中常量引用的对象。如:字符串常量池(String Table) 里的引用</li><li>所有被同步锁synchronized持有的对象</li><li>Java虛拟机内部的引用。</li><li>基本数据类型对应的Class对象，一些常驻的异常对象(如:NullPointerException、OutOfMemoryError)，系统类加载器。</li><li>反映java虛拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li><li>在分代收集和局部回收时，GC Roots集临时性的加入其他对象，比如针对新生代回收，老年代的对象也要纳入GC Roots集中。</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须“StopTheWorld”的一个重要原因。即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><ul><li><p>Java语言提供了对象终止(finalization) 机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p></li><li><p>当垃圾回收器发现没有引用指向一个对象，即:垃圾回收此对象之前，总会先调用这个对象的finalize()方法。.</p></li><li><p>finalize ()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p></li></ul><h3 id="不重写finalize-方法的原因"><a href="#不重写finalize-方法的原因" class="headerlink" title="不重写finalize()方法的原因"></a>不重写finalize()方法的原因</h3><ol><li>在finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定。</li><li>若不发生GC，则finalize ()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。</li></ol><h3 id="虚拟机中Java对象的三种状态"><a href="#虚拟机中Java对象的三种状态" class="headerlink" title="虚拟机中Java对象的三种状态"></a>虚拟机中Java对象的三种状态</h3><ol><li>可触及的:从根节点开始，可以到达这个对象。</li><li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及 的对象不可能被复活，因为finalize()只会被调用一次。</li></ol><h3 id="判定一个对象是否可回收，至少要经历两次标记过程"><a href="#判定一个对象是否可回收，至少要经历两次标记过程" class="headerlink" title="判定一个对象是否可回收，至少要经历两次标记过程:"></a>判定一个对象是否可回收，至少要经历两次标记过程:</h3><ol><li><h4 id="如果对象到GC-Roots没有-引用链，则进行第一次标记。"><a href="#如果对象到GC-Roots没有-引用链，则进行第一次标记。" class="headerlink" title="如果对象到GC Roots没有 引用链，则进行第一次标记。"></a>如果对象到GC Roots没有 引用链，则进行第一次标记。</h4></li><li><h4 id="进行筛选，判断此对象是否有必要执行finalize-方法"><a href="#进行筛选，判断此对象是否有必要执行finalize-方法" class="headerlink" title="进行筛选，判断此对象是否有必要执行finalize()方法"></a>进行筛选，判断此对象是否有必要执行finalize()方法</h4><p> ① 如果对象没有 重写finalize()方法，或者finalize ()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，被判定为不可触及的。</p><p> ② 如果对象重写 了finalize()方法，且还未执行过，那么该对象会被插入到E-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize ()方法执行。</p><p> ③ finalize()方法是对象逃脱死亡的最后机会，稍后GC会对E-Queue队列中的对象进行第二次标记。如果对象在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，对象会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p></li></ol><h1 id="垃圾清除"><a href="#垃圾清除" class="headerlink" title="垃圾清除"></a>垃圾清除</h1><h2 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记 - 清除算法( Mark-Sweep)"></a>标记 - 清除算法( Mark-Sweep)</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序(也被称为stop the world) ，然后进行两项工作，第一项则是标记，第二项则是清除。</p><p>标记: Collector从引用 根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p><p>清除:Collector对堆 内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>效率不算高。</li><li>在进行GC的时候，需要停止整个应用程序，导致用户体验差。</li><li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表。</li></ol><h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h2><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ol><li>没有标记和清除过程，实现简单，运行高效。</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ol><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h3><ol><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li></ol><h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的:"></a>特别的:</h3><ol><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</li><li>即特别适合垃圾对象很多,存活对象很少的场景;例如:Young区的Survivor0和Survivor1区</li></ol><h2 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记 - 压缩算法(Mark-Compact )"></a>标记 - 压缩算法(Mark-Compact )</h2><p>第一阶段和标记清除算法- -样，从根节点开始标记所有被引用对象,第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。<br>之后，清理边界外所有的空间。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h3><ol><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只 需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ol><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><ol><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li><li>移动过程中，需要全程暂停用户应用程序。即: STW。</li></ol><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。目前几乎所有的GC都是采用分代收集(Generational Collecting) 算法执行垃圾回收的。</p><h3 id="年轻代-Young-Gen"><a href="#年轻代-Young-Gen" class="headerlink" title="年轻代(Young Gen)"></a>年轻代(Young Gen)</h3><p>算法：复制算法。</p><p>特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>速度最快。效率只和当前存活对象大小有关，而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><h3 id="老年代-Tenured-Gen"><a href="#老年代-Tenured-Gen" class="headerlink" title="老年代(Tenured Gen)"></a>老年代(Tenured Gen)</h3><p>算法：一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><p>特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</p><h4 id="各阶段开销"><a href="#各阶段开销" class="headerlink" title="各阶段开销"></a>各阶段开销</h4><p>Mark（标记）阶段的开销与存活对象的数量成正比。</p><p>Sweep（清除）阶段的开销与所管理区域的大小成正相关。</p><p>Compact（压缩/整理）阶段的开销与存活对象的数据成正比。</p><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。降低系统停顿时间，但线程切换和上下文转换消耗，导致垃圾回收成本增加。总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>为了更好地控制GC产生的停顿时间，将一块大的内存区 域分割成多个小块，根据目标的停顿时间，每次合理地回收若千个小区间，而不是整个堆空间，从而减少一 次GC所产生的停顿。分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成<br>连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easypoi导出动态列头excel文件（非注解）</title>
      <link href="2020/11/30/java/easypoi/"/>
      <url>2020/11/30/java/easypoi/</url>
      
        <content type="html"><![CDATA[<h2 id="easypoi"><a href="#easypoi" class="headerlink" title="easypoi"></a>easypoi</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>java对excel文件操作的工具类，使用简单，只需简单几个注解即可完成excel的简单导入导出，也可以基于map灵活定义的表头字段（适用于列数不定，动态生成，下面介绍）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springboot项目直接引入以下启动依赖也行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="用于生成excel文件所需数据"><a href="#用于生成excel文件所需数据" class="headerlink" title="用于生成excel文件所需数据"></a>用于生成excel文件所需数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 用于生成excel文件所需数据</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">transformToExcelMap</span><span class="params">(Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    List&lt;ExcelExportEntity&gt; colList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    添加列</span></span><br><span class="line"><span class="comment">    public ExcelExportEntity(String name, Object key) &#123;</span></span><br><span class="line"><span class="comment">            super.name = name;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        key用于后面数据绑定</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;班级&quot;</span>, <span class="string">&quot;className&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;学号&quot;</span>, <span class="string">&quot;username&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;name&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;性别&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">表格内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();</span><br><span class="line">    List&lt;ExamCorrectDto&gt; examCorrectDtos = (List&lt;ExamCorrectDto&gt;) params.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    examCorrectDtos.forEach(examCorrectDto -&gt; &#123;</span><br><span class="line">        <span class="comment">//每一个valMap就是一行数据，key就是前面定义表头时的key</span></span><br><span class="line">        Map&lt;String, Object&gt; valMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        valMap.put(<span class="string">&quot;className&quot;</span>, examCorrectDto.getClassName());</span><br><span class="line">        valMap.put(<span class="string">&quot;username&quot;</span>, examCorrectDto.getUsername());</span><br><span class="line">        valMap.put(<span class="string">&quot;name&quot;</span>, examCorrectDto.getName());</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将每行数据添加在表格内容list中</span></span><br><span class="line">        list.add(valMap);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    String title = <span class="string">&quot;测验名：&quot;</span> + params.get(<span class="string">&quot;examName&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      课程：&quot;</span> + params.get(<span class="string">&quot;courseName&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      日期：&quot;</span> + simpleDateFormat.format(params.get(<span class="string">&quot;startTime&quot;</span>)) +</span><br><span class="line">        <span class="string">&quot;;      时长：&quot;</span> + params.get(<span class="string">&quot;durationTime&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      总题数：&quot;</span> + params.get(<span class="string">&quot;questionNum&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      总分：&quot;</span> + params.get(<span class="string">&quot;totalScore&quot;</span>);</span><br><span class="line">    ExportParams exportParams = <span class="keyword">new</span> ExportParams(title, params.get(<span class="string">&quot;examName&quot;</span>).toString(), ExcelType.XSSF);</span><br><span class="line">    <span class="comment">//设置标题高度</span></span><br><span class="line">    exportParams.setTitleHeight((<span class="keyword">short</span>) <span class="number">15</span>);</span><br><span class="line">    <span class="comment">//自定义标题样式（代码在下面）</span></span><br><span class="line">    exportParams.setStyle(ExcelTitleStyleConfig.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**    cn.afterturn.easypoi.entity.vo.NormalExcelConstants </span></span><br><span class="line"><span class="comment"> 单Sheet导出 EASYPOI_EXCEL_VIEW = &quot;easypoiExcelView&quot;;</span></span><br><span class="line"><span class="comment">    数据列表 DATA_LIST    = &quot;data&quot;;</span></span><br><span class="line"><span class="comment">    多Sheet 对象 MAP_LIST    = &quot;mapList&quot;;</span></span><br><span class="line"><span class="comment"> 注解对象  CLASS    = &quot;entity&quot;;</span></span><br><span class="line"><span class="comment">    表格参数 PARAMS    = &quot;params&quot;;</span></span><br><span class="line"><span class="comment">    下载文件名称 FILE_NAME    = &quot;fileName&quot;;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    res.put(NormalExcelConstants.CLASS, ExcelExportEntity.class);</span><br><span class="line">    res.put(NormalExcelConstants.DATA_LIST, list);</span><br><span class="line">    res.put(NormalExcelConstants.PARAMS, exportParams);</span><br><span class="line">    res.put(NormalExcelConstants.MAP_LIST, colList);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/11/29</span></span><br><span class="line"><span class="comment"> * 设置样式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelTitleStyleConfig</span> <span class="keyword">extends</span> <span class="title">ExcelExportStylerDefaultImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelTitleStyleConfig</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(workbook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getHeaderStyle</span><span class="params">(<span class="keyword">short</span> color)</span> </span>&#123;</span><br><span class="line">        CellStyle headStyle = <span class="keyword">super</span>.getHeaderStyle(color);</span><br><span class="line">        headStyle.setWrapText(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置前景色填充颜色</span></span><br><span class="line">        headStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex());</span><br><span class="line">        <span class="comment">//设置填充模式！！！注，必要设置，否则ForegroundColor设置无效</span></span><br><span class="line">        headStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        <span class="keyword">return</span> headStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 生成多sheet文件</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> paramList 参数列表，每个Map表示一个Tab，即Sheet</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exportToExcel</span><span class="params">(List&lt;Map&lt;String, Object&gt;&gt; paramList)</span> </span>&#123;</span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">    ExcelExportService server = <span class="keyword">new</span> ExcelExportService();</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; sheetList = <span class="keyword">new</span> ArrayList(paramList.size());</span><br><span class="line">    <span class="comment">//将信息组装成相应信息，一个map就是一个sheet</span></span><br><span class="line">    paramList.forEach(param -&gt; sheetList.add(transformToExcelMap(param)));</span><br><span class="line">    </span><br><span class="line">    sheetList.forEach(sheet -&gt; &#123;</span><br><span class="line">        server.createSheetForMap(</span><br><span class="line">            workbook,</span><br><span class="line">            (ExportParams) sheet.get(NormalExcelConstants.PARAMS),</span><br><span class="line">            (List&lt;ExcelExportEntity&gt;) sheet.get(NormalExcelConstants.MAP_LIST),</span><br><span class="line">            (List&lt;Map&lt;String, Object&gt;&gt;) sheet.get(NormalExcelConstants.DATA_LIST));</span><br><span class="line">    &#125;);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;文件名.xlsx&quot;</span>);</span><br><span class="line">        <span class="comment">//写出文件</span></span><br><span class="line">        workbook.write(fos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (workbook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                workbook.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="/2020/11/30/java/easypoi/image-20201130170342374.png" alt="image-20201130170342374"></p><h3 id="注解形式直接看官方文档即可"><a href="#注解形式直接看官方文档即可" class="headerlink" title="注解形式直接看官方文档即可"></a>注解形式直接看官方文档即可</h3><p><a href="http://easypoi.mydoc.io/">参考文档1</a></p><p><a href="http://doc.wupaas.com/docs/easypoi/easypoi-1c0u6ksp2r091">参考文档2</a></p><p>注：也可使用<a href="https://github.com/alibaba/easyexcel">easyexcel</a> （阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称）。</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javadoc简单使用</title>
      <link href="2020/11/29/java/javadoc/"/>
      <url>2020/11/29/java/javadoc/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h2><p>Java 支持三种注释方式。前两种分别是 <strong>//</strong> 和 <strong>/* */<strong>，第三种被称作说明注释，它以 **/\</strong></strong> 开始，以 ***/**结束。</p><p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p><p>说明注释，使你更加方便的记录你的程序信息。</p><h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><ul><li>第一段：概要描述，通常用一句或者一段话简要描述该类的作用，以英文句号作为结束。</li><li>第二段：详细描述，通常用一段或者多段话来详细描述该类的作用，一般每段话都以英文句号作为结束。</li><li>第三段：文档标注，用于标注作者、创建时间、参阅类等信息。</li></ul><p><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">参考地址</a></p><h2 id="javadoc-标签"><a href="#javadoc-标签" class="headerlink" title="javadoc 标签"></a>javadoc 标签</h2><table><thead><tr><th align="left"><strong>标签</strong></th><th align="center"><strong>描述</strong></th><th align="center"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">@author</td><td align="center">标识一个类的作者</td><td align="center">@author description</td></tr><tr><td align="left">@deprecated</td><td align="center">指名一个过期的类或成员</td><td align="center">@deprecated description</td></tr><tr><td align="left">{@docRoot}</td><td align="center">指明当前文档根目录的路径</td><td align="center">Directory Path</td></tr><tr><td align="left">@exception</td><td align="center">标志一个类抛出的异常</td><td align="center">@exception exception-name explanation</td></tr><tr><td align="left">{@inheritDoc}</td><td align="center">从直接父类继承的注释</td><td align="center">Inherits a comment from the immediate surperclass.</td></tr><tr><td align="left">{@link}</td><td align="center">用于快速链接到相关代码</td><td align="center">{@link name text}</td></tr><tr><td align="left">{@linkplain}</td><td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td><td align="center">Inserts an in-line link to another topic.</td></tr><tr><td align="left">@param</td><td align="center">说明一个方法的参数</td><td align="center">@param parameter-name explanation</td></tr><tr><td align="left">@return</td><td align="center">说明返回值类型</td><td align="center">@return explanation</td></tr><tr><td align="left">@see</td><td align="center">指定一个到另一个主题的链接</td><td align="center">@see anchor</td></tr><tr><td align="left">@serial</td><td align="center">说明一个序列化属性</td><td align="center">@serial description</td></tr><tr><td align="left">@serialData</td><td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td><td align="center">@serialData description</td></tr><tr><td align="left">@serialField</td><td align="center">说明一个ObjectStreamField组件</td><td align="center">@serialField name type description</td></tr><tr><td align="left">@since</td><td align="center">标记当引入一个特定的变化时</td><td align="center">@since release</td></tr><tr><td align="left">@throws</td><td align="center">和 @exception标签一样.</td><td align="center">The @throws tag has the same meaning as the @exception tag.</td></tr><tr><td align="left">{@value}</td><td align="center">显示常量的值，该常量必须是static属性。</td><td align="center">Displays the value of a constant, which must be a static field.</td></tr><tr><td align="left">@version</td><td align="center">指定类的版本</td><td align="center">@version info</td></tr><tr><td align="left">@code</td><td align="center">将文本标记为code</td><td align="center">{@code text} 会被解析成<code>&lt;code&gt; text &lt;/code&gt;</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String理解</title>
      <link href="2020/11/17/java/String/"/>
      <url>2020/11/17/java/String/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>jdk8及以前底层用char[]数组实现，jdk9以后改为byte[]。</p><p>jdk6及以前，字符串常量池存放在永久代。jdk7及其以后保存在Java堆中。</p><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>对String字符串重新赋值，拼接，replace指定字符，都不能使用原有value进行赋值。</p><h2 id="字符串拼接结果保存"><a href="#字符串拼接结果保存" class="headerlink" title="字符串拼接结果保存"></a>字符串拼接结果保存</h2><ol><li>两个常量拼接结果在常量池，原理是编译器优化。</li><li>要是拼接表达式存在变量，结果就保存在堆中。底层使用String Builder拼接。</li><li>如果拼接结果调用intern()方法，则主动将常量池中还没有的字符串对象存入常量池中，并返回此对象地址。</li></ol><h2 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2020/11/17/java/String/image-20201130200723360.png" alt="image-20201130200723360"></p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">创建两对象</span></span><br><span class="line"><span class="comment">1，堆空间的new 出来的对象</span></span><br><span class="line"><span class="comment">2，字符串常量池的&quot;a&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//由于常量池已经有&quot;a&quot;,直接返回常量池&quot;a&quot;地址</span></span><br><span class="line">String ss = s.intern();</span><br><span class="line">String s2 =<span class="string">&quot;a&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//jdk6/7/8 : false</span></span><br><span class="line">System.out.println(ss == s2); <span class="comment">//jdk6/7/8 : true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">创建&quot;aa&quot;对象，但常量池中只有字符串&quot;a&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">jdk6</span></span><br><span class="line"><span class="comment">由于此时常量池中无&quot;aa&quot;，常量池中存入&quot;aa&quot;字符串（相当于复制一份），返回常量池中字符串的引用地址</span></span><br><span class="line"><span class="comment">所以s3和s4地址不相同</span></span><br><span class="line"><span class="comment">jdk7/8</span></span><br><span class="line"><span class="comment">由于此时常量池中无&quot;aa&quot;，所以把s3的对象地址存入常量池(复制的是对象的地址)，返回常量池中对象的地址</span></span><br><span class="line"><span class="comment">所以s3和s4的地址是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>String 的String Pool 不存在相同的内容变量，是固定大小的HashTable，默认长度1009，当里面String过多时，Hash冲突严重，导致链表会很长，String.itern(用于将字符串放入常量池)性能严重下降。</p><h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p> -XX: StringTableSize 可设置JVM的StringTable长度。</p><ul><li>jdk6：StringTable固定大小，长度就是1009。</li><li>jdk7：长度默认60013。</li><li>jdk8：长度默认60013。1009是设置String Table的最小值。</li></ul><h2 id="问题！！！"><a href="#问题！！！" class="headerlink" title="问题！！！"></a>问题！！！</h2><h3 id="new-String-“ab”-；new-String-“a”-new-String-“b”-分别创建多少个对象？"><a href="#new-String-“ab”-；new-String-“a”-new-String-“b”-分别创建多少个对象？" class="headerlink" title="new String(“ab”)；new String(“a”) + new String(“b”); 分别创建多少个对象？"></a>new String(“ab”)；new String(“a”) + new String(“b”); 分别创建多少个对象？</h3><h2 id="new-String-“ab”-；"><a href="#new-String-“ab”-；" class="headerlink" title="new String(“ab”)；"></a>new String(“ab”)；</h2><p>两个：</p><p>一个是堆中new出来的对象，一个是常量池中的”ab”字符串。</p><h2 id="new-String-“a”-new-String-“b”"><a href="#new-String-“a”-new-String-“b”" class="headerlink" title="new String(“a”) + new String(“b”);"></a>new String(“a”) + new String(“b”);</h2><p>六个：</p><ol><li>StringBulider对象</li><li>new String(“a”)堆中new对象</li><li>常量池中的”a”字符串</li><li>new String(“b”)堆中new对象</li><li>常量池中的”b”字符串</li><li>StringBuilder的toString()方法返回new String(“ab”).注：调用toString()方法常量池不会生成字符串”ab”</li></ol><h2 id="扩展String、StringBuilder、StringBuffer区别"><a href="#扩展String、StringBuilder、StringBuffer区别" class="headerlink" title="扩展String、StringBuilder、StringBuffer区别"></a>扩展String、StringBuilder、StringBuffer区别</h2><p><strong>String</strong>底层是用final修饰的char数组，不可改变，（String的大部分情况都是字母，一个字节即可满足，为降低内存占用，<strong>jdk9后改成byte数组</strong>,StringBuilder和StringBuffer也是，并用coder字段修饰编码类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coder字段可选值</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LATIN1 = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UTF16  = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>StringBuilder</strong>底层是一个可变的char数组，默认初始化长度为16，构造器有字符串传参时默认长度为字符串长度+16，append操作超过原有长度限制时以下规则扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//char数组长度 * 2 + 2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">//扩展后长度还是不满足则直接等于minCapacity（minCapacity = 已使用长度 + append参数的长度）</span></span><br><span class="line">        newCapacity = minCapacity; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(); <span class="comment">//超出最大长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//minCapacity在(Integer.MAX_VALUE - 8, Integer.MAX_VALUE]之间</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">       ? minCapacity : MAX_ARRAY_SIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer使用synchronized修饰方法，线程安全，内部维护一个char[] toStringCache数组缓存最近一次toString()的值，每次修改前都置为null。扩展规则和StringBuilder一致，都是使用AbstractStringBuilder抽象类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm对象分析与执行引擎</title>
      <link href="2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ol><li>使用new关键字</li><li>Class的newInstance();</li><li>Constructor的newInstance();</li><li>使用clone();方法</li><li>对象反序列化</li></ol><p>注：前三个会调用构造函数，后两个不会。</p><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol><li><p>判断对象对应的类是否加载、链接、初始化。</p></li><li><p>为对象分配内存（内存规划与并发问题）</p></li><li><p>初始化（所有属性设置默认值，保证对象的实例属性不赋值可直接使用）</p></li><li><p>设置对象头</p></li><li><p>执行init方法初始化</p></li></ol><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205538656.png" alt="image-20201116205538656"></p><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205552066.png" alt="image-20201116205552066"></p><h2 id="对象的访问与定位"><a href="#对象的访问与定位" class="headerlink" title="对象的访问与定位"></a>对象的访问与定位</h2><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205753071.png" alt="image-20201116205753071"></p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205802784.png" alt="image-20201116205802784"></p><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212053763.png" alt="image-20201116212053763"></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>执行引擎是Java虚拟机核心的组成部分之一，“虚拟机”是一个相对于”物理机“的概念，这两钟机器都有代码执行能力，物理机执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，能够执行硬件不支持的指令集格式。</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>将字节码指令解释/编译成对应平台上的本地机器指令，即将字节码指令翻译为机器指令。输入是字节码二进制流，输出的是执行结果。</p><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a><strong>工作过程</strong></h4><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212237168.png" alt="image-20201116212237168"></p><h4 id="字节码执行过程"><a href="#字节码执行过程" class="headerlink" title="字节码执行过程"></a>字节码执行过程</h4><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212749868.png" alt="image-20201116212749868"></p><h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><p>​    当java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容”翻译”为对应平台的本地机器码执行。</p><h4 id="JIT（Just-In-Time-Compiler）"><a href="#JIT（Just-In-Time-Compiler）" class="headerlink" title="JIT（Just In Time Compiler）"></a>JIT（Just In Time Compiler）</h4><p>​    即时编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><p><a href="https://www.cnblogs.com/yanl55555/p/13334713.html?utm_source=tuicool">执行引擎参考</a></p><p><a href="https://www.cnblogs.com/guanghe/p/11880577.html">解释器与JIT参考</a></p><h2 id="源代码到机器码过程的三种编译器"><a href="#源代码到机器码过程的三种编译器" class="headerlink" title="源代码到机器码过程的三种编译器"></a>源代码到机器码过程的三种编译器</h2><p><a href="https://blog.csdn.net/fuxiaoxiaoyue/article/details/93497558">参考链接</a></p><h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p>java代码-》字节码</p><h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p>字节码-》机器码</p><h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>java代码-》机器码</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础</title>
      <link href="2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    Java编译器输入的指令流基本上是一种基于栈的指令集架构，与之对比的是另外一种基于寄存器的指令集架构。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="基于栈式架构特点："><a href="#基于栈式架构特点：" class="headerlink" title="基于栈式架构特点："></a>基于栈式架构特点：</h4><ol><li>设计简单，资源受限等小型系统也适用。</li><li>避开寄存器的分配难题，直接使用零地址指令，指令集更小，实现更加简单。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。</li></ol><h4 id="基于寄存器架构特点"><a href="#基于寄存器架构特点" class="headerlink" title="基于寄存器架构特点"></a>基于寄存器架构特点</h4><ol><li>指令集架构完全依赖硬件，可移植性差。</li><li>指令执行更高效，性能更好。</li><li>花费更少指令完成一项操作。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于跨平台的设计，java的指令都是根据栈来设计的，不同平台的CPU架构不同，所以不能设计基于寄存器的。基于栈来设计的<strong>优点</strong>是跨平台，指令集小，编译器更容易实现。<strong>缺点</strong>是性能下降，实现同一项操作需要更多指令。</p><h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>通过引导类加载器（bootstrap class loader）创建一个初始类来完成，一个Jvm启动后就是一个进程。</p><p>注：可在命令窗口使用jps指令查看当前进程id</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>执行Java程序，即执行一个叫做java虚拟机的进程。</p><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ol><li>程序执行结束正常退出。</li><li>程序执行过程中遇到异常或错误而异常终止。</li><li>操作系统出现错误导致JVM进程终止。</li><li>程序中执行System.exit(status)或Runtime.getRuntime().halt(status)方法。</li><li>除此之外，JNI(Java Native Interface)规范描述了JNI Invocation API来加载或卸载java虚拟机时，java虚拟机退出的情况。</li></ol><h2 id="字节码执行过程"><a href="#字节码执行过程" class="headerlink" title="字节码执行过程"></a>字节码执行过程</h2><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/1.png" alt="jvm整体架构"></p><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>​    负责将字节码文件即class文件加载到JVM中，加载的类信息将存储于JVM运行时数据区的方法区中。（除类信息外，方法区还存放运行时的常量池信息等）</p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/2.png" alt="image-20201115151642295"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过类的全限定类名获取此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>1.验证（Verify）</p><p>目的：保证Class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性以及虚拟机自身安全。</p><ul><li>​    文件格式验证</li><li>​    元数据验证</li><li>​    字节码验证</li><li>​    符号引用验证</li></ul><p>2.准备（Prepare）</p><p>​    为类变量（静态属性）分配内存并设置默认初始值，即零值。</p><p>注：</p><ul><li>final修饰的static除外，因为final在编译的时候就分配了，准备阶段会显式初始化。</li><li>实例变量（普通属性）不会被分配初始化，类变量会被分配在方法区中，而实例变量会随java对象一起分配在堆中。</li></ul><p>3.解析(Pesolve)</p><p>​    将常量池的符号引用转换为直接引用（直接引用就是直接指向目标的指针，相对偏移量或间接定位到目标的句柄）。主要针对的是类的接口、字段、类方法、接口方法、方法类型等。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>本质：就是执行类构造方法clinit()的过程。</li><li>此方法不需要定义，javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句。</li><li>指令的执行顺序会按代码在源文件出现的顺序执行。</li><li>若该类有父类，JVM会先加载并执行完父类的clinit()方法。clinit()方法在多线程下是被同步加锁的。</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>注：所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器（User-Defined ClassLoader）（即只有Bootstrap 不是）。</p><h4 id="引导（启动）类加载器（Bootstrap-ClassLoader）"><a href="#引导（启动）类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导（启动）类加载器（Bootstrap ClassLoader）"></a>引导（启动）类加载器（Bootstrap ClassLoader）</h4><ol><li>由C/C++语言实现，嵌套在JVM内部。</li><li>用来加载Java核心库（JAVA_HOME/jre/lib/rt.jar、resourse.jar或sun.boot.class.path路径下的内容），提供JVM自身所需类。</li><li>并不继承自java.lang.ClassLoader,没有父加载器，加载扩展类加载器并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap启动加载器只加载包名为java、javax、sun等开头的类。</li></ol><h4 id="扩展类加载器（ExClassLoader）"><a href="#扩展类加载器（ExClassLoader）" class="headerlink" title="扩展类加载器（ExClassLoader）"></a>扩展类加载器（ExClassLoader）</h4><ol><li>Java语言编写，由sun.mis.Launcher$ExtClassLoader实现。</li><li>派生于ClassLoader类，父类加载器为Bootsrap ClassLoader 。</li><li>从java.ext.dirs系统属性所加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR包放在此目录下，也会自动由扩展类加载器加载。</li></ol><h4 id="系统类（应用程序类）加载器（AppClassLoader）"><a href="#系统类（应用程序类）加载器（AppClassLoader）" class="headerlink" title="系统类（应用程序类）加载器（AppClassLoader）"></a>系统类（应用程序类）加载器（AppClassLoader）</h4><ol><li>Java语言编写，由sun.mis.Launcher$AppClassLoader实现。</li><li>派生于ClassLoader类，父类加载器为Bootsrap ClassLoader 。</li><li>负责加载类环境变量classpath或系统属性 java.class.path 指定路径下的类库</li><li>程序中的默认加载器，一般来说，Java应用类都是由它来完成加载</li><li>可以通过ClassLoader.getSystemClassLoader()方法获取</li></ol><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ol><li>作用：隔离加载类、修改加载方式、扩展加载源、防止源码泄露。</li><li>实现：可继承java.lang.ClassLoader或java.net.URLClassLoader类实现自己的类加载器，</li></ol><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>一个加载器收到类加载请求，不会自己先去加载，而是先将请求委托给父类的加载器去执行，若父类加载器还有其父类加载器，则进一步向上委托，依次递归到启动类加载器，父类加载器可以加载则成功返回，无法加载则子类再去加载。</p><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a><strong>优势：</strong></h4><p>避免类重复加载，保护程序安全，防止核心API被随意算改</p><h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>​    如我们在程序中自己定义了一个 String 类，但是加载自定义 String 类的时候会先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 java\lang\String.class），这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    又称PC计数器、指令计数器，程序钩子。JVM的PC寄存器是对物理PC寄存器的抽象模拟。占用内存少，几乎可忽略不记，运行速度最快的存储区域。在JVM规范中，<strong>每个线程独享一个程序计数器</strong>，生命周期与线程一致。任何时期每个线程都只有一个方法在执行，也就是当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是正在执行本地方法，则是未指定值（undefned）。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</li><li>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时需要通过计数器的值来选取下一条需要执行的字节码指令。</li><li>它是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域。</li></ol><h3 id="虚拟机栈-JVM-Stacks"><a href="#虚拟机栈-JVM-Stacks" class="headerlink" title="虚拟机栈(JVM Stacks)"></a>虚拟机栈(JVM Stacks)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，<strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。生命周期与线程一致。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM对Java的栈操作只有两个：进栈（入栈、压栈）【方法执行】，出栈【方法结束】。</li><li><strong>栈不存在垃圾回收问题。</strong></li></ol><h4 id="可能存在异常"><a href="#可能存在异常" class="headerlink" title="可能存在异常"></a>可能存在异常</h4><ul><li>栈大小固定：StackOverflowError</li><li>栈大小可动态扩展：OutOfMemoryError</li></ul><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ul><li><h5 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h5></li></ul><p>又称局部变量数组或本地变量表，定义为一个数字数组，主要存储方法参数和定义在方法体内的局部变量【基本数据类型、对象引用、以及returnAddress类型】，局部变量表是建立在线程栈上的，线程私有，不存在数据安全问题，表容量大小是编译期确定下来，最基本单位是slot（变量槽）32位以内类型占一个slot，64位类型占两个。</p><p><strong>注：若当前帧是由构造方法或实例方法创建的，那么该栈帧的slot的index=0存放的是该对象的引用—this</strong></p><ul><li><h5 id="操作数栈-Operand-Stack-或-表达式栈"><a href="#操作数栈-Operand-Stack-或-表达式栈" class="headerlink" title="操作数栈(Operand Stack)(或 表达式栈)"></a>操作数栈(Operand Stack)(或 表达式栈)</h5></li></ul><p>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。主要用于保存计算过程的中间结果。其栈深度在编译期就定义好，保存在方法的Code属性中，为max_stack的值。32位占一个、64位占两个单位的栈深度。</p><p>栈顶缓存（Top-of-Stack Cashing）技术：将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</p><ul><li><h5 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h5></li></ul><p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用。动态链接就是将变量和方法的引用转换为调用方法的直接引用</p><ul><li><h5 id="方法返回值-Return-Address-（或方法退出或异常退出的定义）"><a href="#方法返回值-Return-Address-（或方法退出或异常退出的定义）" class="headerlink" title="方法返回值(Return Address)（或方法退出或异常退出的定义）"></a>方法返回值(Return Address)（或方法退出或异常退出的定义）</h5></li></ul><p>正常退出：调用者的pc计数器的值作为返回地址，即调用该方法的下一条指令地址。</p><p>异常退出：异常表来确定。</p><p>区别：异常退出的不会给他的上层调用者产生任何返回值。</p><ul><li><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5></li></ul><p>对程序调试提供支持的信息</p><h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h3><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域（最大的内存空间），堆可以在物理上不连续，但在逻辑上它应该被视为连续的，<strong>堆区域是所有线程共享的</strong>，但也有划分出线程私有的缓存区Thread Local Allocation Buffer（TLAB，解决指针冲突）。</p><p>可细分为新生区和养老区；</p><p>新生区又可细分为Eden，Survivor0，Survivor1三个空间 （也称Eden, from, to）， 官网说默认比例是8:1:1 。</p><p>实际操作发现并不是，需关闭自适应内存分配策略：-XX:-UseAdaptiveSizePolicy，或直接通过-XX:SurvivorRatio=8调整此比例</p><h4 id="设置堆空间新生代和老年代占比"><a href="#设置堆空间新生代和老年代占比" class="headerlink" title="设置堆空间新生代和老年代占比"></a>设置堆空间新生代和老年代占比</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio= <span class="comment">#设置新生代和老年代空间占比，默认2</span></span><br><span class="line">-XX:NewRatio=2 <span class="comment">#表示新生代占1，老年代占2，新生代占整个堆空间的1/3</span></span><br><span class="line">-XX:NewRatio=4 <span class="comment">#表示新生代占1，老年代占4，新生代占整个堆空间的1/5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行查看此参数</span></span><br><span class="line">&gt;jinfo -flag NewRatio 【进程id】</span><br><span class="line">-XX:NewRatio=2</span><br></pre></td></tr></table></figure><p>idea可直接在Run-&gt;Eidt Configurations-&gt;VM options里设置（注：设置多个时用空格隔开）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-X 是jvm的运行参数 m是memory， s是start， x是max</span></span><br><span class="line"><span class="comment">#官网建议： For server deployments, -Xms and -Xmx are often set to the same value.</span></span><br><span class="line">-Xms300m <span class="comment">#设置堆空间（年轻代+老年代）的初始内存大小300M ,单位不指定默认字节（k,m,g）</span></span><br><span class="line">-Xmx300m <span class="comment">#设置堆空间（年轻代+老年代）的最大内存大小300M</span></span><br><span class="line"><span class="comment">#不设置默认值：初始内存大小=物理电脑内存/64，最大内存大小=物理电脑内存/4</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">#控制台打印相关参数</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsInitial <span class="comment">#查看所有参数的默认值（就算有指定，也显示默认值）</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsFinal <span class="comment">#查看所有参数的最终值</span></span><br><span class="line"><span class="comment">#具体查看某个参数指令：命令行输入 </span></span><br><span class="line"><span class="comment">#jps #查看进程id</span></span><br><span class="line"><span class="comment">#jinfo -flag 参数 进程id</span></span><br><span class="line">如：</span><br><span class="line">&gt;jps</span><br><span class="line">2932 Jps</span><br><span class="line">6628</span><br><span class="line">11944 Launcher</span><br><span class="line">12952 RemoteMavenServer</span><br><span class="line">13096 Launcher</span><br><span class="line">6392 Launcher</span><br><span class="line">&gt;jinfo -flag SurvivorRatio 13096</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line"></span><br><span class="line">-Xmn <span class="comment">#设置新生代大小</span></span><br><span class="line"></span><br><span class="line">-XX:NewRatio <span class="comment">#配置新生代与老年代在堆中占比</span></span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio <span class="comment">#设置新生代中Eden和s0/s1空间比例</span></span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold <span class="comment">#设置新生代垃圾最大年龄 （默认15岁进入老年代）</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">#输出详细的Gc处理日志</span></span><br><span class="line"><span class="comment">#打印GC简要信息 -XX:+PrintGC 或 -verbose:gc</span></span><br><span class="line"></span><br><span class="line">-XX:HandlePromotionFailure <span class="comment">#是否设置空间分配担保</span></span><br></pre></td></tr></table></figure><h4 id="命令行查看运行参数"><a href="#命令行查看运行参数" class="headerlink" title="命令行查看运行参数"></a>命令行查看运行参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 【进程id】 【打印间隔时间单位（秒或毫秒），不指定默认毫秒】(不写只打印一次)<span class="comment">#查看进程GC情况</span></span><br><span class="line"></span><br><span class="line">&gt;jstat -gc 48476</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC …… </span><br><span class="line">7680.0 1024.0  0.0   768.0  63488.0  34050.8   70656.0     5471.6   24064.0 23307.3 2816.0 2640.8  5…… </span><br></pre></td></tr></table></figure><h4 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h4><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/image-20201115210033571.png" alt="image-20201115210033571"></p><h5 id="STW（Stop-The-World）："><a href="#STW（Stop-The-World）：" class="headerlink" title="STW（Stop The World）："></a>STW（Stop The World）：</h5><p>​    指在进行垃圾回收时，暂停其它用户线程，等垃圾回收结束，用户线程才能恢复运行。</p><h5 id="新生代收集MinorGC（Young-GC）"><a href="#新生代收集MinorGC（Young-GC）" class="headerlink" title="新生代收集MinorGC（Young GC）"></a>新生代收集MinorGC（Young GC）</h5><p>清理年轻代的内存，Survivor中基数达到15的对象移至老年代，当年轻代Eden空间满时触发，Survuivor满不会触发GC</p><h5 id="老年代收集MajorGC-Old-GC"><a href="#老年代收集MajorGC-Old-GC" class="headerlink" title="老年代收集MajorGC(Old GC)"></a>老年代收集MajorGC(Old GC)</h5><p>目前只有CMS GC会有单独收集老年代的行为，很多时候Major GC会和Full GC混合使用。Major GC的速度一般会比Minor GC慢10倍以上。STW更长</p><p>Major GC经常会胖随至少一次Minor  GC，若Major GC后内存还不足，就直接报OOM。</p><h5 id="混合收集（Mixed-GC）"><a href="#混合收集（Mixed-GC）" class="headerlink" title="混合收集（Mixed GC）"></a>混合收集（Mixed GC）</h5><p>目前只有G1 GC会有这种行为。</p><h5 id="整堆收集FullGC"><a href="#整堆收集FullGC" class="headerlink" title="整堆收集FullGC"></a>整堆收集FullGC</h5><p>收集整个java堆和方法区的垃圾。</p><p>触发条件：</p><ol><li>调用System.gc(),系统建议执行，但不是必须执行。</li><li>老年代空间不足。</li><li>方法区空间不足。</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</li></ol><h3 id="方法区-Metaspace"><a href="#方法区-Metaspace" class="headerlink" title="方法区(Metaspace)"></a>方法区(Metaspace)</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>方法区是线程共享的，jdk7以前永久代实现，jdk8后改为元空间（Metaspace ）使用本地内存。存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p><a href="https://blog.csdn.net/duoyu779553/article/details/105878755/">参考链接</a></p><p><a href="https://blog.csdn.net/qingtiantianqing/article/details/51405517">参考链接</a></p><h2 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h2><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><p><a href="https://www.hollischuang.com/archives/2398">参考链接</a></p><p><a href="https://blog.csdn.net/hollis_chuang/article/details/80922794">参考链接2</a></p><p>jdk1.7后默认开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis #开启方法逃逸</span><br><span class="line">-XX:-DoEscapeAnalysis #关闭方法逃逸</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>一、<strong>为什么要字节码，用不同平台虚拟机直接将java代码编译成对应指令集不就行？</strong></p><ol><li>准备工作：（源代码———&gt; 机器码）每次执行都需要检查语法和语义检查，每次执行语义分析的结果都不会被保留下来，都要重新编译，重新去分析，整体性能会受到影响，做很多重复的事情，因此引出中间字节码，保证一次编译，多次运行时不需要重复校验。</li><li>兼容性：也可以将别的语言解析成字节码，例如scala，生成字节码同样也可以被JVM调用执行，提高平台兼容扩展能力，符合软件设计的中庸之道。</li></ol><p>二、<strong>堆是内存分配对象的唯一选择码？</strong></p><p>　    随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。<br>　　在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。<br>　　此外，基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (Gcinvisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且Gc不能管理GCIH内部的Java对象，以此达到降低Gc的回收频率和提升GC的回收效率的目的。</p><p>注：《深入理解Java虚拟机》</p><p>三、 <strong>什么是解释器（Interpreter），什么是即时编译器(JIT)</strong></p><p>​    <strong>解释器：</strong>当java虚拟机启动时，会根据预定义的规范对字节码文件进行逐行解释的方式执行。每条指令都会被翻译成机械指令执行。</p><p>​    <strong>JIT（Just In Time）编译器：</strong>虚拟机直接将源码转换成可以直接发送给处理器的指令的程序。</p><p>四、 <strong>为什么说java是半编译半解释型语言</strong></p><ol><li>jdk1.0时代，java虚拟机的执行引擎只用解释器将字节码逐行翻译成机械指令执行，效率较慢，此时可算解释型语言。</li><li>现在虚拟机的执行引擎里有JIT编译器，可直接将方法编译成机械码后再执行，通常两者会结合使用，所以说java是半编译半解释型语言。</li></ol><p>五、<strong>JIT比解释器快，为啥不直接只使用JIT</strong></p><p>​    虚拟机刚启动时，解释器可以先发挥作用（表现为启动时响应用户更快），即时编译器全部编译完再执行，需要一定时间等待。随着时间的推移，即时编译器逐渐发挥作用，利用热点探测功能， 将有价值的字节码编译成本地机械指令，以换取更高的执行效率。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RK987快捷键</title>
      <link href="2020/11/15/%E5%85%B6%E4%BB%96/RK%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/11/15/%E5%85%B6%E4%BB%96/RK%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Fn-A后"><a href="#Fn-A后" class="headerlink" title="Fn+A后"></a>Fn+A后</h2><ul><li>Caps Lock = 长按2s后 切换到大写；点按切换中英文</li><li>按住shift= 打印大写字母</li><li>ctrl + backspace=切换中英文</li><li>🔒 + A = 全选</li><li>ctrl+ ⬅️ 或者 ➡️ 桌面切换</li><li>ctrl+⬇️ 显示当前桌面所有窗口   ===作用等同 F3</li><li>ctrl+⬆️ 显示当前桌面所有窗口  ===作用等同 F3</li></ul><p>FX系列使用说明</p><ul><li>F1 亮度调暗  </li><li>F2 亮度调亮</li><li>F3 显示当前桌面所有窗口</li><li>F4 启动台</li><li>F5 +command  启动旁白</li><li>F8 启动苹果音乐</li><li>F10 静音</li><li>F10 + Alt 或 F11 + Alt 或 F11 + Alt 打开声音配置</li><li>F11 降低声音</li><li>F12 增加音量</li></ul><ul><li>Fn+SCR LK 切换灯光效果</li><li>Fn+A: 切换到mac 键盘 Fn+S: 切换到win键盘</li><li>🔒键==command键 alt==option</li></ul><h2 id="Fn-S后"><a href="#Fn-S后" class="headerlink" title="Fn+S后"></a>Fn+S后</h2><ul><li>Caps Lock = 长按2s后 切换到大写；点按切换中英文</li><li>按住shift= 打印大写字母</li><li>ctrl + backspace=切换中英文</li><li>ALT + A = 全选</li></ul><h2 id="蓝牙切换"><a href="#蓝牙切换" class="headerlink" title="蓝牙切换"></a>蓝牙切换</h2><p><img src="/2020/11/15/%E5%85%B6%E4%BB%96/RK%E5%BF%AB%E6%8D%B7%E9%94%AE/RK%E8%93%9D%E7%89%99.jpg" alt="RK蓝牙"></p><p><a href="http://www.rkgaming.com/zh-CN/article.php?id=5123">参考链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常用知识</title>
      <link href="2020/11/14/JVM/jvm%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
      <url>2020/11/14/JVM/jvm%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">官网链接</a></p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="打开JDK自带可视化工具jvisualvm"><a href="#打开JDK自带可视化工具jvisualvm" class="headerlink" title="打开JDK自带可视化工具jvisualvm"></a>打开JDK自带可视化工具jvisualvm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1，到jdk的bin目录找到jvisualvm.exe，双击运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2，或配置了jdk环境变量后可直接命令行执行以下命令打开</span></span><br><span class="line">C:\Users\CZM&gt;jvisualvm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打开可视化监控jconsole"><a href="#打开可视化监控jconsole" class="headerlink" title="打开可视化监控jconsole"></a>打开可视化监控jconsole</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\CZM&gt;jconsole</span><br></pre></td></tr></table></figure><ol><li>可以远程可视化监控服务器的java进程。</li><li>可以观测堆的不同区块的占用空间量。</li><li>不能heapdump</li></ol><p><a href="https://blog.csdn.net/moneyshi/article/details/81511687">参考链接</a></p><h3 id="查看当前所有进程id"><a href="#查看当前所有进程id" class="headerlink" title="查看当前所有进程id"></a>查看当前所有进程id</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;jps</span><br><span class="line">12984</span><br><span class="line">10684 Jps</span><br><span class="line">48476 Launcher</span><br></pre></td></tr></table></figure><h3 id="查看指定参数信息"><a href="#查看指定参数信息" class="headerlink" title="查看指定参数信息"></a>查看指定参数信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flag jvm参数 进程ip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL&#39;1055&#39;错误</title>
      <link href="2020/11/06/SQL/mySQL%E5%BC%82%E5%B8%B8/"/>
      <url>2020/11/06/SQL/mySQL%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>执行复杂sql（我是多表连接查询和group by分组一起使用）语句时，报以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate SQLException with Error code <span class="string">&#x27;1055&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>mysql5.7后，sql_mode中默认存在ONLY_FULL_GROUP_BY(不要让GROUP BY部分中的查询指向未选择的列)，对 group by 用法的规定，select 的字段只能是group by的字段。或者需要加聚合函数的。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在数据库中执行以下语句</span></span><br><span class="line">SELECT @@global.sql_mode <span class="comment">#查询sql_mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span></span><br><span class="line"><span class="comment">#ONLY_FULL_GROUP_BY　　        不要让GROUP BY部分中的查询指向未选择的列　　</span></span><br><span class="line"><span class="comment">#STRICT_TRANS_TABLES           为事务存储引擎启用严格模式，也可能为非事务存储引擎启用严格模式</span></span><br><span class="line"><span class="comment">#NO_ZERO_IN_DATE               在严格模式，不接受月或日部分为0的日期</span></span><br><span class="line"><span class="comment">#NO_ZERO_DATE                 在严格模式，不将 &#x27;0000-00-00&#x27;做为合法日期</span></span><br><span class="line"><span class="comment">#ERROR_FOR_DIVISION_BY_ZERO   在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误　　</span></span><br><span class="line"><span class="comment">#NO_AUTO_CREATE_USER          防止GRANT自动创建新用户，除非还指定了密码</span></span><br><span class="line"><span class="comment">#NO_ENGINE_SUBSTITUTION       如果需要的存储引擎被禁用或未编译，可以防止自动替换存储引擎</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去掉ONLY_FULL_GROUP_BY 执行以下语句</span></span><br><span class="line"><span class="built_in">set</span> global sql_mode = <span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启项目问题解决</span></span><br></pre></td></tr></table></figure><h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>能不修改尽量不修改，一般这个是你使用group by分组后，在查出的数据中被分到同一组的数据的有其它字段不相同，可将这字段加入分组条件解决</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot全局异常处理</title>
      <link href="2020/10/27/Springboot/springboot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2020/10/27/Springboot/springboot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>​    @ControllerAdvice注解是Spring3.2中新增的注解，只能用于类上，与下面三个方法注解结合可进行一些全局操作。</p><h3 id="方法注解"><a href="#方法注解" class="headerlink" title="方法注解"></a>方法注解</h3><h3 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a>@InitBinder</h3><p>用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Date类型参数转换器的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalInitBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>表示其注解的方法将会在目标Controller方法执行之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute(value = &quot;key&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">globalModelAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加了全局属性。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;key_value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">list</span><span class="params">(<span class="meta">@ModelAttribute(&quot;key&quot;)</span> String key)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印：</p><p>​    添加了全局属性。</p><p>​    key: key_value</p><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>用于捕获Controller中抛出的指定类型的异常</p><p>​    返回自定义实体 统一格式，特别是前后端分离自定义消息格式（记得加@ResponseBody）。</p><p>​    返回 ModelAndView 跳转到指定页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.czm.constants.ResultCodeEnum;</span><br><span class="line"><span class="keyword">import</span> com.czm.dto.ResultDto;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.NoHandlerFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">//返回ResultDto消息实体的json对象</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;未知错误：&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName() ,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.ERROR.getCode(), </span><br><span class="line">                                           ResultCodeEnum.ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MissingServletRequestParameterException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">ParameterExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        MissingServletRequestParameterException exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误请求：&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName() ,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.BAG_REQUEST.getCode(), </span><br><span class="line">                                           ResultCodeEnum.BAG_REQUEST.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">NotFountHandler</span><span class="params">(NoHandlerFoundException exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;404错误:&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName(), exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.NOT_FOUND.getCode(), </span><br><span class="line">                                           ResultCodeEnum.NOT_FOUND.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置-否则拦截不到"><a href="#注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置-否则拦截不到" class="headerlink" title="注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置,否则拦截不到"></a>注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置,否则拦截不到</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#出现错误时, 直接抛出异常</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">   <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#不要为我们工程中的资源文件建立映射</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">   <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jwt生产校验token</title>
      <link href="2020/10/21/java/jwt%E7%94%9F%E6%88%90%E6%A0%A1%E9%AA%8Ctoken/"/>
      <url>2020/10/21/java/jwt%E7%94%9F%E6%88%90%E6%A0%A1%E9%AA%8Ctoken/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <strong>Jwt</strong>（JSON Web Token）是一种基于RFC 7519标准定义的一种可以安全传输的小巧和自包含的JSON对象。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token计为紧凑且安全,也可直接被用于认证，也可被加密。允许我们在用户和服务器之间传递安全可靠的信息。<strong>特别适用于分布式站点的单点登录</strong>(SingleSignOn，SSO)。支持移动平台（cookie不支持）。JWT可以使用HMAC算法对secret进行加密或者使用RSA的公钥私钥对其进行签名。</p><h2 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h2><ul><li><p><strong>Header 头部</strong></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#令牌的类型（即JWT）和使用的签名算法组成</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Payload 负载</strong> </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由预定义（Registered） 公有（public） 私有（private）三类属性组成</span></span><br><span class="line"><span class="comment">#Registered，由官方预定，非必需</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    iss (issuer)：签发人</span><br><span class="line"></span><br><span class="line">    sub (subject)：主题</span><br><span class="line"></span><br><span class="line">    aud (audience)：受众</span><br><span class="line"></span><br><span class="line">    exp (expiration time)：过期时间</span><br><span class="line"></span><br><span class="line">    nbf (Not Before)：生效时间，在此之前是无效的</span><br><span class="line"></span><br><span class="line">    iat (Issued At)：签发时间</span><br><span class="line"></span><br><span class="line">    jti (JWT ID)：编号</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#public: 在使用 JWT 时可以额外定义的载荷</span></span><br><span class="line"><span class="comment">#private:在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Signature 签名/签证</strong></p><p>  主要是把头部的base64UrlEncode与负载的base64UrlEncode拼接起来，再用HMACSHA256进行加盐<code>secret</code>组合加密，最终得到的结果作为签名部分。</p></li></ul><h3 id="JWT示例"><a href="#JWT示例" class="headerlink" title="JWT示例"></a>JWT示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiItMSIsInJvbGVJZCI6LTEsInVzZXJJZCI6MSwiaWF0IjoxNjAzMjc1OTE5LCJleHAiOjE2MDMzNjIzMTl9.KVJTpGYMX8IOBFjdNQvmGAsDRQ3J7_2McajtI2WYlss</span><br></pre></td></tr></table></figure><h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Jwt工具类代码"><a href="#Jwt工具类代码" class="headerlink" title="Jwt工具类代码"></a>Jwt工具类代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/20 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间，一天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long EXPIRED_TIME = <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String KEY = <span class="string">&quot;密钥&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(String userName, Long userId)</span></span>&#123;</span><br><span class="line">        String token = Jwts</span><br><span class="line">                .builder()</span><br><span class="line">                .setSubject(String.valueOf(roleId)) <span class="comment">//设置这个JWT的主体，即它的所有人</span></span><br><span class="line">                .claim(<span class="string">&quot;userName&quot;</span>, userName)</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date()) <span class="comment">//jwt的签发时间</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis()+EXPIRED_TIME))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, KEY) <span class="comment">//设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Claims claims = Jwts.parser()  //得到DefaultJwtParser</span></span><br><span class="line"><span class="comment">//                .setSigningKey(KEY)         //设置签名的秘钥</span></span><br><span class="line"><span class="comment">//                .parseClaimsJws(jwt).getBody();//设置需要解析的jwt</span></span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody().get(<span class="string">&quot;userName&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getUserId</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims body = Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> body.get(<span class="string">&quot;userId&quot;</span>,Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExpiration</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打包vue项目部署到Nginx</title>
      <link href="2020/10/19/%E9%83%A8%E7%BD%B2/%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0nginx/"/>
      <url>2020/10/19/%E9%83%A8%E7%BD%B2/%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    <strong>前后端分离，前后端项目往往分开部署，有的甚至部署到不同的服务器，大二的软件工程团队作业项目强后端分离，下面讲下用Nginx部署Vue项目及遇到的坑。</strong></p><h2 id="Vue项目打包"><a href="#Vue项目打包" class="headerlink" title="Vue项目打包"></a>Vue项目打包</h2><p><strong>打开命令行进入项目根目录</strong></p><p><strong>注：本机需先安装<a href="https://nodejs.org/en/">NodeJS</a></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装项目所需模块</span></span><br><span class="line">npm install </span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">npm run serve</span><br><span class="line"><span class="comment">#打包项目 ,该指令执行后会生成一个dist目录（存放项目的静态文件）</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><strong>将整个dist目录上传到服务器</strong></p><h2 id="Nginx环境搭建"><a href="#Nginx环境搭建" class="headerlink" title="Nginx环境搭建"></a>Nginx环境搭建</h2><p><strong>这里使用docker的Nginx镜像快速搭建。</strong></p><p><strong>连接云服务器，命令行输入如下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#从Docker Hub查找镜像</span></span><br><span class="line"><span class="comment">#docker search [OPTIONS] TERM</span></span><br><span class="line"><span class="comment">#--automated :只列出 automated build类型的镜像；</span></span><br><span class="line"><span class="comment">#--no-trunc :显示完整的镜像描述；</span></span><br><span class="line"><span class="comment">#-s :列出收藏数不小于指定值的镜像。</span></span><br><span class="line">docker search -s 100 nginx <span class="comment">#从Docker Hub查找所有镜像名包含nginx，并且收藏数大于1000的镜像</span></span><br><span class="line">INDEX       NAME             DESCRIPTION                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/nginx  Official build of Nginx.        13876     [OK]       </span><br><span class="line"><span class="comment">#参数说明：</span></span><br><span class="line"><span class="comment">#NAME: 镜像仓库源的名称</span></span><br><span class="line"><span class="comment">#DESCRIPTION: 镜像的描述</span></span><br><span class="line"><span class="comment">#OFFICIAL: 是否 docker 官方发布</span></span><br><span class="line"><span class="comment">#stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</span></span><br><span class="line"><span class="comment">#AUTOMATED: 自动构建。 </span></span><br><span class="line"></span><br><span class="line">docker pull nginx <span class="comment">#拉取镜像，默认最新版</span></span><br><span class="line"></span><br><span class="line">docker images <span class="comment">#列出本机镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的容器并运行 （--volume , -v: 绑定一个卷，相当于将容器相应路径映射到服务器上）--name=&quot;&quot;: 为容器指定一个名称</span></span><br><span class="line">docker run --name nginx -p 本机端口:容器端口（nginx默认80） -d （后台运行）</span><br><span class="line">-v ……/nginx.conf（服务器配置文件路径）:/etc/nginx/nginx.conf（容器配置文件路径） </span><br><span class="line">-v ……/dist（前端打包文件上传路径）:/usr/share/nginx/html（容器内部目录） nginx:latest （镜像名或id）</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p><strong>注：此处若未配置 try_files $uri $uri/ /index.html;项目除根路径外刷新后会直接报404，下面有说明</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">vim ……/nginx.conf(服务器上映射的配置文件)</span><br><span class="line"><span class="comment">#找到80端口的server模块</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  【你的域名或ip】;</span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html; <span class="comment">#根路径</span></span><br><span class="line"><span class="comment">#    proxy_pass http://127.0.0.1:8080</span></span><br><span class="line">            index  index.html index.htm; <span class="comment">#首页</span></span><br><span class="line">                 </span><br><span class="line">           try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment">#方法1</span></span><br><span class="line">       <span class="comment"># try_files $uri $uri/ =404;</span></span><br><span class="line">   <span class="comment"># try_files $uri $uri/ @router; #方法2</span></span><br><span class="line">   <span class="comment">#参数: $uri</span></span><br><span class="line">       <span class="comment">#解释: 表示当前请求的URI(域名后的内容),不带任何参数 例如访问: http://localhost/about</span></span><br><span class="line">       <span class="comment">#$uri: &quot;/about&quot;</span></span><br><span class="line">       <span class="comment">#第一个参数$uri Nginx首先会查找/下有没有名为$uri的文件，本例中为名为demo的文件，如有则将请求传递给$uri</span></span><br><span class="line">       <span class="comment">#第二个参数$uri/ 如找不到名为$uri的文件，Nginx接着会查找/下有没有名为$uri的文件夹，本例中为名为about的文件夹，如有则将请求传递给$uri/ ，访问该文件夹下的index</span></span><br><span class="line">       <span class="comment"># 第三个参数 </span></span><br><span class="line">       <span class="comment">#= 404 如前两个参数都无法接收请求 就返回状态码404</span></span><br><span class="line">   <span class="comment">#若是路径，则访问，本例是请求http://ip:80/index.html</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#之所以出现刷新404的现象，是因为在nginx配置的根目录 /usr/share/nginx/html下面压根没有&#x27;about/find&#x27;这个真实资源存在，这些访问资源都是在js里渲染的</span></span><br><span class="line"><span class="comment">#在服务端nginx配置里添加vue-route的跳转设置</span></span><br><span class="line"><span class="comment">#location @router &#123;</span></span><br><span class="line">        <span class="comment">#rewrite ^.*$ /index.html last;</span></span><br><span class="line">   <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>改完后保存退出。</strong></p><p><strong>执行docker restart nginx 重启容器后配置生效</strong></p><p><strong>到此部署结束</strong></p><h3 id="扩展Nginx热加载"><a href="#扩展Nginx热加载" class="headerlink" title="扩展Nginx热加载"></a>扩展Nginx热加载</h3><p><strong>docker exec -it nginx /bin/bash 进入容器，执行 service nginx  reload  按ctrl+P+Q退出容器</strong></p><p><strong>或者直接docker exec -i nginx（容器名） service nginx reload （执行命令）</strong></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger简单入门</title>
      <link href="2020/10/16/java/swagger/"/>
      <url>2020/10/16/java/swagger/</url>
      
        <content type="html"><![CDATA[<h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a><strong>前后端分离</strong></h2><ul><li>前端 -&gt; 前端控制层、视图层</li><li>后端 -&gt; 后端控制层、服务层、数据访问层</li><li>前后端通过API进行交互</li><li>前后端相对独立且松耦合</li></ul><h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a><strong>产生的问题</strong></h2><ul><li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul><li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li></ul><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a><strong>Swagger</strong></h2><ul><li>号称世界上最流行的API框架</li><li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li><li>直接运行，在线测试API</li><li>支持多种语言 （如：Java，PHP等）</li><li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li></ul><h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p>jdk 1.8 +</p><h3 id="方式一-使用官方依赖"><a href="#方式一-使用官方依赖" class="headerlink" title="方式一:使用官方依赖"></a>方式一:使用官方依赖</h3><h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="编写一个配置类-SwaggerConfig来配置-Swagger"><a href="#编写一个配置类-SwaggerConfig来配置-Swagger" class="headerlink" title="编写一个配置类-SwaggerConfig来配置 Swagger"></a>编写一个配置类-SwaggerConfig来配置 Swagger</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;配置类</span><br><span class="line">@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问测试-：http-localhost-8080-swagger-ui-html-，可以看到swagger的界面；"><a href="#访问测试-：http-localhost-8080-swagger-ui-html-，可以看到swagger的界面；" class="headerlink" title="访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面；"></a>访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</h4><p><img src="/2020/10/16/java/swagger/image-20201016202312084.png" alt="image-20201016202312084"></p><h4 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.swagger.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Profiles;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.VendorExtension;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/16 16:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(ApiInfo apiInfo, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断当前是否处于该环境，环境配置：spring.profiles.active=dev</span></span><br><span class="line">        <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo)</span><br><span class="line">                .groupName(<span class="string">&quot;czm&quot;</span>) <span class="comment">//配置API分组名</span></span><br><span class="line">                .enable(flag)<span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">                .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  // 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.any()</span></span><br><span class="line"><span class="comment">                 *  // 不扫描接口</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.none()</span></span><br><span class="line"><span class="comment">                 *  // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span></span><br><span class="line"><span class="comment">                 *  // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.basePackage(final String basePackage) // 根据包路径扫描接口</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.czm.swagger.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/czm开头的接口</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/czm/**&quot;</span>))</span><br><span class="line">                <span class="comment">/***其他参数</span></span><br><span class="line"><span class="comment">                 * PathSelectors.any() // 任何请求都扫描</span></span><br><span class="line"><span class="comment">                 * PathSelectors.none() // 任何请求都不扫描</span></span><br><span class="line"><span class="comment">                 * PathSelectors.regex(final String pathRegex) // 通过正则表达式控制</span></span><br><span class="line"><span class="comment">                 * PathSelectors.ant(final String antPattern) // 通过ant()控制</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//配置文档信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         *    Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span></span><br><span class="line"><span class="comment">         *    return new ApiInfo(</span></span><br><span class="line"><span class="comment">         *            &quot;Swagger学习&quot;, // 标题</span></span><br><span class="line"><span class="comment">         *            &quot;学习演示如何配置Swagger&quot;, // 描述</span></span><br><span class="line"><span class="comment">         *            &quot;v1.0&quot;, // 版本</span></span><br><span class="line"><span class="comment">         *            &quot;http://terms.service.url/组织链接&quot;, // 组织链接</span></span><br><span class="line"><span class="comment">         *            contact, // 联系人信息</span></span><br><span class="line"><span class="comment">         *            &quot;Apach 2.0 许可&quot;, // 许可</span></span><br><span class="line"><span class="comment">         *            &quot;许可链接&quot;, // 许可连接</span></span><br><span class="line"><span class="comment">         *            new ArrayList&lt;&gt;()// 扩展</span></span><br><span class="line"><span class="comment">         *   );</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;czm&quot;</span>, <span class="string">&quot;baidu.com&quot;</span>, <span class="string">&quot;1233@qq.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(<span class="string">&quot;swagger的测试API&quot;</span>, <span class="string">&quot;Api Documentation的描述&quot;</span>, <span class="string">&quot;1.0版&quot;</span>, <span class="string">&quot;urn:tos&quot;</span>,</span><br><span class="line">                contact, <span class="string">&quot;Apache 2.0&quot;</span>, <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>, <span class="keyword">new</span> ArrayList&lt;VendorExtension&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 其他多个API组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h4><p>1、新建一个实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体类&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;用户账号&quot;)</span><br><span class="line">    private String account;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;用户密码&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public User(String account, String password) &#123;</span><br><span class="line">        this.account &#x3D; account;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccount(String account) &#123;</span><br><span class="line">        this.account &#x3D; account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;getUser&quot;)</span><br><span class="line">public User getUser()&#123;</span><br><span class="line">   return new User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/16/java/swagger/image-20201016210951882.png" alt="image-20201016210951882"></p><p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p><p>@ApiModel为类添加注释</p><p>@ApiModelProperty为类属性添加注释</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p><p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p><table><thead><tr><th>Swagger注解</th><th>简单说明</th></tr></thead><tbody><tr><td>@Api(tags = “xxx模块说明”)</td><td>作用在模块类上</td></tr><tr><td>@ApiOperation(“xxx接口说明”)</td><td>作用在接口方法上</td></tr><tr><td>@ApiModel(“xxxPOJO说明”)</td><td>作用在模型类上：如VO、BO</td></tr><tr><td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td><td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td></tr><tr><td>@ApiParam(“xxx参数说明”)</td><td>作用在参数、方法和字段上，类似@ApiModelProperty</td></tr><tr><td>@ApiImplicitParam()</td><td>作用在方法上，表示单独的请求参数</td></tr><tr><td>@ApiImplicitParams()</td><td>作用于方法，包含多个 @ApiImplicitParam</td></tr></tbody></table><p>注：@ApiImplicitParam(name–参数名，value–参数说明 ，dataType–数据类型 ，example–举例说明，required–是否必填,</p><p>paramType–参数类型 )</p><p>paramType表示参数放在哪个地方</p><ul><li>header–&gt;请求参数的获取：@RequestHeader(代码中接收注解)</li><li>query–&gt;请求参数的获取：@RequestParam(代码中接收注解)</li><li>path（用于restful接口）–&gt;请求参数的获取：@PathVariable(代码中接收注解)</li><li>body–&gt;请求参数的获取：@RequestBody(代码中接收注解)</li><li>form（不常用）</li></ul><p>我们也可以给请求的接口配置一些注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.czm.swagger.controller;</span><br><span class="line"></span><br><span class="line">import com.czm.swagger.entity.User;</span><br><span class="line">import io.swagger.annotations.*;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author CZM</span><br><span class="line"> * @create 2020&#x2F;10&#x2F;16 16:49</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@Api(value&#x3D;&quot;swagger的hello模块&quot;,tags&#x3D;&#123;&quot;用户操作接口&quot;&#125;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;getUser&quot;)</span><br><span class="line">    @ApiOperation(&quot;获取一个默认user对象&quot;)</span><br><span class="line">    @ApiResponses(&#123;@ApiResponse(code &#x3D; 200, message &#x3D; &quot;good&quot;),@ApiResponse(code &#x3D; 401, message &#x3D; &quot;no power&quot;)&#125;)</span><br><span class="line">    public User getUser(@ApiParam(value &#x3D; &quot;这是参数1&quot;,name &#x3D; &quot;param&quot;) @RequestParam String param,</span><br><span class="line">                        @ApiParam(value &#x3D; &quot;这是参数2&quot;,name &#x3D; &quot;param2&quot;) @RequestParam String param2)&#123;</span><br><span class="line">        return new User(param+&quot;123&quot;,param2+&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;getUser2&#x2F;&#123;account&#125;&#x2F;&#123;password&#125;&quot;)</span><br><span class="line">    @ApiOperation(&quot;获取一个指定user对象&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * name–参数ming</span><br><span class="line">             * value–参数说明</span><br><span class="line">             * dataType–数据类型</span><br><span class="line">             * paramType–参数类型</span><br><span class="line">             * example–举例说明</span><br><span class="line">             * required–是否必填</span><br><span class="line">             *&#x2F;</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;account&quot;,value&#x3D;&quot;用户名&quot;,dataType&#x3D;&quot;String&quot;, paramType &#x3D; &quot;path&quot;,</span><br><span class="line">            example &#x3D; &quot;username&quot;,required &#x3D; true),</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;password&quot;,value&#x3D;&quot;用户密码&quot;,dataType&#x3D;&quot;String&quot;, paramType &#x3D; &quot;path&quot;,example &#x3D; &quot;password&quot;)     </span><br><span class="line">    &#125;)</span><br><span class="line">    public User getUser2(@PathVariable(&quot;account&quot;) String account, </span><br><span class="line">    @PathVariable(&quot;password&quot;) String password) &#123;</span><br><span class="line">        System.out.println(account+password);</span><br><span class="line">        return new User(account,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p><p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p><p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p><h3 id="方式二：使用第三方依赖"><a href="#方式二：使用第三方依赖" class="headerlink" title="方式二：使用第三方依赖"></a>方式二：使用第三方依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/SpringForAll/spring-boot-starter-swagger">github上有配置详情</a></p><h2 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h2><p>我们可以导入不同的包实现不同的皮肤定义：</p><ul><li>bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/16/java/swagger/image-20201016210544771.png" alt="image-20201016210544771"></p><ul><li>Layui-ui  <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.caspar-chen&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-ui-layer&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>注：需注入一个groupName为默认的Docket</p><p><img src="/2020/10/16/java/swagger/image-20201016210310198.png" alt="image-20201016210310198"></p><ul><li>mg-ui  <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.zyplayer&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-mg-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/16/java/swagger/image-20201016202725022.png" alt="image-20201016202725022"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven简单介绍</title>
      <link href="2020/10/15/java/maven%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/10/15/java/maven%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p></li><li><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p></li><li><p>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p><p> 注：摘自[菜鸟教程]:<a href="https://www.runoob.com/maven/maven-tutorial.html">https://www.runoob.com/maven/maven-tutorial.html</a></p></li></ol><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><h4 id="减少冗余"><a href="#减少冗余" class="headerlink" title="减少冗余"></a>减少冗余</h4><p>在项目开发中，我们常常需要引入第三方的框架和工具包来提高开发速度，以前要使用这些 jar 包就是复制粘贴到 WEB-INF/lib 目录下。当你建了多个项目时有项目都需要引入同一jar包，需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，使工程显得很臃肿。 </p><p>使用maven后会在本地建一个统一的仓库，用于存放所有jar包、源文件等，当项目需要引入某个jar包时，只需复制其依赖坐标至pom文件中，maven就会自动帮我们导入到项目中。每个jar包本地只保存一份，不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</p><h4 id="解决jar包依赖"><a href="#解决jar包依赖" class="headerlink" title="解决jar包依赖"></a>解决jar包依赖</h4><p>jar包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来， 无需人工参与，节约了我们大量的时间和精力。</p><h4 id="统一下载"><a href="#统一下载" class="headerlink" title="统一下载"></a>统一下载</h4><p>我们通常在查找第三方jar包，选择版本上花费很多时间，maven提供个中央仓库，只需你依赖坐标填对，就会自动去 [中央仓库]:<a href="https://mvnrepository.com/">https://mvnrepository.com/</a>  下载。</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本，打包项目等。</p><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven有三套相互独立的生命周期，分别是 Clean、Default 和 Site。每个生命周期包含一些阶段，阶段是有顺序的，后面的阶段依赖于前面的阶段。不管用户要求执行的命令对应生命周期中的哪一个阶段，Maven都会自动从当前生命周期的最初位置开始执行，直到完成用户下达的指令。</p><ul><li><p>Clean 生命周期：清理项目，包含三个 phase（阶段） ：</p><ul><li><p>pre-clean：执行清理前需要完成的工作。</p></li><li><p>clean：清理上一次构建生成的文件。</p></li><li><p>post-clean：执行清理后需要完成的工作。</p></li></ul></li><li><p>Default 生命周期：构建项目，重要的 phase 如下：</p><ul><li>validate：验证工程是否正确，所有需要的资源是否可用。</li><li>compile：编译项目的源代码。</li><li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li><li>package：把已编译的代码打包成可发布的格式，比如 jar、war 等。</li><li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li><li>verify：运行所有检查，验证包是否有效且达到质量标准。</li><li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li><li>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</li></ul></li><li><p>Site 生命周期：建立和发布项目站点，phase 如下：</p><ul><li>pre-site：生成项目站点之前需要完成的工作。</li><li>site：生成项目站点文档。</li><li>post-site：生成项目站点之后需要完成的工作。</li><li>site-deploy：将项目站点发布到服务器。</li></ul></li></ul><h2 id="pom文件常用标签介绍"><a href="#pom文件常用标签介绍" class="headerlink" title="pom文件常用标签介绍"></a>pom文件常用标签介绍</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的全球唯一标识符(项目名) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。默认值是../pom.xml。</span></span><br><span class="line"><span class="comment">Maven首先在构建当前项目的地方寻找父项目的pom，</span></span><br><span class="line"><span class="comment">其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目.(公司或组织的域名倒序) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.czm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。(当前项目的模块名称) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>back<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当前模块的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目打包格式：pom、jar、war</span></span><br><span class="line"><span class="comment">父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--统一管理所依赖 jar 包的版本 对同一个框架的一组 jar 包最好使用相同的版本。</span></span><br><span class="line"><span class="comment">为了方便升级框架，可以将 jar 包的版本信息统一提取出来  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR8<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.12<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--项目描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>just a demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">     <span class="comment">&lt;!--jar包依赖坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用上面统一声明的版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">依赖的范围 ：compile、test、provided </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。</span></span><br><span class="line"><span class="comment">即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">          <span class="comment">&lt;!--描述与项目关联的文件是什么和在哪里--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span> <span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span> </span><br><span class="line">              <span class="comment">&lt;!-- true/false，表示为这个resource，filter是否激活--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!--定义resource文件所在的文件夹，默认为$&#123;basedir&#125;/src/main/resources--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span> <span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!--  指定哪些文件将被匹配，以*作为通配符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>configuration.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!-- 指定哪些文件将被忽略--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 定义和resource类似，只不过在test时使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">        ...  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>  </span><br><span class="line"> <span class="comment">&lt;!--指定使用的插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="父项目pom常用坐标"><a href="#父项目pom常用坐标" class="headerlink" title="父项目pom常用坐标"></a>父项目pom常用坐标</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入springboot开始依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明子模块，指定模块工程的相对路径即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>model1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>model2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--统一声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot-maven-plugin</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-maven-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意使用import标签时，不再使用&lt;parent&gt;标签</span></span><br><span class="line"><span class="comment">表示将父项目的dependencyManagement拿到本POM中，不再继承parent</span></span><br><span class="line"><span class="comment">type必须是pom--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--与dependencyManagement类似，只声明--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-maven-plugin&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--添加配置跳过测试类构建--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Maven中的SNAPSHOT版本和RELEASE版本"><a href="#Maven中的SNAPSHOT版本和RELEASE版本" class="headerlink" title="Maven中的SNAPSHOT版本和RELEASE版本"></a>Maven中的SNAPSHOT版本和RELEASE版本</h2><p>在一个Nexus仓库中，一个仓库一般分为<strong>Release</strong>（public）仓和<strong>SNAPSHOT</strong>仓，前者存放<strong>发布版本</strong>（正式版），后者存放快照版本。若pom.xml中指定版本带有”-SNAPSHOT”后缀，则打包出来的就是快照版。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>快照版本和正式版本的主要区别在于，本地获取这些依赖的机制有所不同。假设你依赖一个库的<strong>正式版本</strong>，构建的时候构建工具会先在本次仓库中查找是否已经有了这个依赖库，如果没有的话才会去远程仓库中去拉取。（若远程仓库已经更新新的软件包{如只修改一点代码，没更新版本号}，则本地不会更新至最新版）。</p><p><strong>快照版</strong>不管本地是否已有此jar包，都会去远程仓库查看是否有最新版发布。为充分利用本地缓存机制，采用四种请求策略，分别是：</p><ol><li>always是每次都去远程仓库查看是否有更新。</li><li>daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看。</li><li>interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次。</li><li>never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- maven仓库配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>仓库唯一标识<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>仓库名<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>仓库路径<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置快照查询策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>interval:XX<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span> <span class="comment">&lt;!--XX是间隔分钟数,daily是默认值--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做:</span></span><br><span class="line"><span class="comment">                ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://www.huangbowen.net/blog/2016/01/29/understand-official-version-and-snapshot-version-in-maven/">参考链接</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA常用快捷键</title>
      <link href="2020/10/10/%E5%85%B6%E4%BB%96/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/10/10/%E5%85%B6%E4%BB%96/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Intellij-IDEA常用快捷键"><a href="#Intellij-IDEA常用快捷键" class="headerlink" title="Intellij IDEA常用快捷键"></a>Intellij IDEA常用快捷键</h2><ol><li><p>Alt+回车 导入包,自动修正</p></li><li><p>Ctrl＋Alt＋V 插入变量名。</p></li><li><p>Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</p></li><li><p>Ctrl＋Q可以看到当前方法的声明（注释文档）</p></li><li><p>Alt＋Insert可以生成构造器/Getter/Setter等</p></li><li><p>Alt+Shift+C 对比最近修改的代码</p></li><li><p>Ctrl+N   查找类</p></li><li><p>Alt + 7 查看当前所有方法</p></li><li><p>Alt+f7 查看方法被调用(顺序)</p></li><li><p>Ctrl+Alt+H 查看方法被调用（逆推）</p></li><li><p>Ctrl+H 显示类结构图（继承结构）</p></li><li><p>Ctrl+Shift+N 查找文件</p></li><li><p>Ctrl+Alt+L  格式化代码</p></li><li><p>Ctrl+E查看最近文件</p></li><li><p>Ctrl+R 替换文本</p></li><li><p>Ctrl+F 查找文本</p></li><li><p>Ctrl+Shift+Space 代码提示</p></li><li><p>Ctrl+Alt+Space 类名或接口名提示</p></li><li><p>Ctrl+P 方法参数提示</p></li><li><p>Shift+F6  重构-重命名</p></li><li><p>Ctrl+X 复制行</p></li><li><p>Ctrl+D 删除行</p></li><li><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）</p></li><li><p>Alt+F1 查找代码所在位置</p></li><li><p>Ctrl+Alt+ left/right 返回至上次浏览的位置</p></li><li><p>Alt+ left/right 切换代码视图</p></li><li><p>Alt+ Up/Down 在方法间快速移动定位</p></li><li><p>Ctrl+Shift+Up/Down 代码向上/下移动。</p></li><li><p>F2 或Shift+F2 高亮错误或警告快速定位</p></li><li><p>代码标签输入完成后，按Tab，生成代码。</p></li><li><p>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</p></li><li><p>Ctrl+W 选中代码，连续按会有其他效果</p></li><li><p>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</p></li><li><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下</p></li><li><p>Ctrl+B 快速打开光标处的类或方法 </p></li><li><p>Shift＋Click可以关闭文件</p></li><li><p>Ctrl＋[或]可以跳到大括号的开头结尾</p></li><li><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p></li><li><p>Ctrl＋F12，可以显示当前文件的结构</p></li><li><p>Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</p></li><li><p>Ctrl＋W可以选择单词继而语句继而行继而函数</p></li><li><p>Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaNIO</title>
      <link href="2020/10/10/java/JavaNIO/"/>
      <url>2020/10/10/java/JavaNIO/</url>
      
        <content type="html"><![CDATA[<h2 id="Java共支持3种网络编程模型-IO模式：BIO、NIO、AIO"><a href="#Java共支持3种网络编程模型-IO模式：BIO、NIO、AIO" class="headerlink" title="Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO"></a>Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</h2><ol><li><p>​    Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端 有连接请求时服务器端就需要启动一个线程    进行处理，如果这个连接不做任何事情会造成 不必要的线程开销 。</p></li><li><p>​    Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发 送的连接请求都会注册到多路复用器上，多</p><p> ​    路复用器轮询到连接有I/O请求就进行处理 。</p></li><li><p>​     Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简 化了程序编写，有效的请求才启动线程，</p><p> ​    它的特点是先由操作系统完成后才通知服务端程。</p></li></ol><h2 id="I-O模型-BIO、NIO、AIO适用场景分析"><a href="#I-O模型-BIO、NIO、AIO适用场景分析" class="headerlink" title="I/O模型 BIO、NIO、AIO适用场景分析"></a>I/O模型 BIO、NIO、AIO适用场景分析</h2><ol><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕 系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分 调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ol><h2 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h2><p>Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io.*下， BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连 接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。 </p><p> BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p><h3 id="BIO编程简单流程"><a href="#BIO编程简单流程" class="headerlink" title="BIO编程简单流程"></a>BIO编程简单流程</h3><ol><li>服务器端启动一个ServerSocket</li><li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li><li>客户端发出请求后, 先咨询服务器 是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行</li></ol><h4 id="Java-BIO-问题分析"><a href="#Java-BIO-问题分析" class="headerlink" title="Java BIO 问题分析"></a>Java BIO 问题分析</h4><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</li></ol><h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol><li>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</li><li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</li><li>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) NIO是面向缓冲区 ，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得 到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线 程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞 写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。</li><li>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来, 根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。</li><li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li></ol><h3 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h3><ol><li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多 。</li><li>BIO 是阻塞的，NIO 则是非阻塞的。</li><li>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 </li></ol><h3 id="NIO-三大核心关系"><a href="#NIO-三大核心关系" class="headerlink" title="NIO 三大核心关系"></a>NIO 三大核心关系</h3><p>​    <strong>Selector 、 Channel 和 Buffer</strong></p><ol><li><p>每个channel 都会对应一个Buffer。</p></li><li><p>Selector 对应一个线程， 一个线程对应多个channel(连接) 。</p></li><li><p>程序切换到哪个channel 是由事件决定的, Event 就是一个重要的概念 。</p></li><li><p>Selector 会根据不同的事件，在各个通道上切换 。</p></li><li><p>Buffer 就是一个内存块 ， 底层是有一个数组 。</p></li><li><p>数据的读取写入是通过Buffer（BIO 中要么是输入流，或者是输出流, 不能双向），NIO的Buffer 是可以读也可以写, 需要 flip 方法切换 。</p></li><li><p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的。</p></li></ol><h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个 容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道 (Channel)是双向的，可以读操作，也可以写操作。</li><li>Channel在NIO中是一个接口 public interface Channel extends Closeable{} 。</li><li>常用的 Channel 类有：FileChannel、 DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li><li>FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</li><li>NIO的通道类似于流，但有些区别如下：</li></ol><ul><li>通道可以同时进行读写，而流只能读或者只能写。</li><li>通道可以实现异步读写数据。</li><li>通道可以从缓冲读数据，也可以写数据到缓冲。</li></ul><h3 id="关于Buffer-和-Channel的注意事项和细节"><a href="#关于Buffer-和-Channel的注意事项和细节" class="headerlink" title="关于Buffer 和 Channel的注意事项和细节"></a>关于Buffer 和 Channel的注意事项和细节</h3><ol><li>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</li><li>可以将一个普通Buffer 转成只读Buffer 。</li><li>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由NIO 来完成。</li><li>前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</li></ol><h3 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a>Selector(选择器)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)。</li><li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以 事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</li><li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少 了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 4) 避免了多线程之间的上下文切换导致的开销。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><p>NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类 似Socket。</p></li><li><p>注册进Select的Channel必须是非阻塞的，所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socketchannel可以正常使用。</p></li><li><p>selector 相关方法说明：</p><p> ​    selector.select()//阻塞 </p><p> ​    selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回 </p><p> ​    selector.wakeup();//唤醒selector </p><p> ​    selector.selectNow();//不阻塞，立马返还</p></li></ol><h3 id="NIO写入文件代码示例"><a href="#NIO写入文件代码示例" class="headerlink" title="NIO写入文件代码示例"></a>NIO写入文件代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是  FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对byteBuffer 进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="NIO聊天室代码示例"><a href="#NIO聊天室代码示例" class="headerlink" title="NIO聊天室代码示例"></a>NIO聊天室代码示例</h3><p>Server端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel =  ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;<span class="comment">//有事件处理</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//遍历得到selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出selectionkey</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable()) &#123; <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line"></span><br><span class="line">                            readData(key);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有可以用的通道...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个线程, 读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        Thread.currentThread().sleep(3000);</span></span><br><span class="line"><span class="comment">//                    &#125;catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol><li>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式： Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得 到通知，进行相应的处理 。</li><li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作 系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时 间较长的应用。</li></ol><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>数据从一个存储区域拷贝到另一个存储区域，没有CPU参与，这个过程称为零拷贝。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>减少CPU占用。</li><li>减少用户空间（用户态操作的缓存区）与内核空间（CPU可以操作的内存缓存区域及寄存器）拷贝过程。</li><li>减少用户态和内核态的上下文切换</li></ul><p><a href="https://blog.csdn.net/u013096088/article/details/79122671">参考链接</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>注：笔记参考自尚硅谷-韩顺平的Netty相关教程</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级</title>
      <link href="2020/09/27/Redis/Redis%E9%AB%98%E7%BA%A7/"/>
      <url>2020/09/27/Redis/Redis%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="为什么持久化"><a href="#为什么持久化" class="headerlink" title="为什么持久化"></a>为什么持久化</h3><p>​    Redis是内存数据库，数据都保存在内存中，因此数据读取速度快，效率高，但也容易发生丢失（如Redis宕机，突然断电等）。所以必须要有持久化的机制保存数据到硬盘，防止数据丢失。</p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        RDB(默认的持久化方式)指在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb,它恢复时是将快照文件直接读到内存里。</p><h4 id="持久化过程"><a href="#持久化过程" class="headerlink" title="持久化过程"></a>持久化过程</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p><h4 id="触发RDB快照条件"><a href="#触发RDB快照条件" class="headerlink" title="触发RDB快照条件"></a>触发RDB快照条件</h4><ol><li>配置文件save配置</li><li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li><li>执行命令save或者bgsave</li></ol><p>注：save：save时只管保存，其它不管，全部阻塞</p><p>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p><p>可以通过lastsave命令获取最后一次成功执行快照的时间。</p><h4 id="停用"><a href="#停用" class="headerlink" title="停用"></a>停用</h4><ol><li>动态所有停止RDB保存规则的方法：redis-cli config set save “”</li><li>修改配置文件save “”</li></ol><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li></ol><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF默认存储文件名appendonly.aof</p><h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>修改配置appendonly no改为yes</p><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>修复受损appendonly.aof文件命令： Redis-check-aof –fix  appendonly.aof</p><h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p><h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol><li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li><li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li></ol><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li><li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li><li>不同步：appendfsync no   从不同步，性能最好</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li></ol><h4 id="同时开启两种持久化方式"><a href="#同时开启两种持久化方式" class="headerlink" title="同时开启两种持久化方式"></a>同时开启两种持久化方式</h4><ol><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li></ol><h4 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h4><ol><li> 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li><li>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</li></ol><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​    进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。复杂情况下可使用专门的消息中间件，如RabbitMQ。</p><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>PSUBSCRIBE pattern [pattern …]     订阅一个或多个符合给定模式的频道。<br>PUBSUB subcommand [argument [argument …]]      查看订阅与发布系统状态。<br>PUBLISH channel message     将信息发送到指定的频道。<br>PUNSUBSCRIBE [pattern [pattern …]]     退订所有给定模式的频道。<br>SUBSCRIBE channel [channel …]     订阅给定的一个或多个频道的信息。<br>UNSUBSCRIBE [channel [channel …]]    指退订给定的频道。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#窗口1</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel  <span class="comment">#订阅channel频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line"><span class="comment">#当下面发布消息到此频道时，显示下面信息</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1 <span class="comment">#数量 </span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span> <span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span> <span class="comment">#消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与上面同一时刻的另一个客户端窗口2</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#窗口3</span></span><br><span class="line"><span class="comment">#将信息发送到指定的频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH channel <span class="string">&quot;hello word&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 <span class="comment">#推送给两个订阅者</span></span><br><span class="line"><span class="comment">#获取当前系统所有频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">&quot;channel2&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主，实现读写分离，Slave无法写入数据</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Info replication <span class="comment">#查看</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment">#角色</span></span><br><span class="line">connected_slaves:0 <span class="comment">#从机数</span></span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><ol><li>拷贝多个redis.conf文件</li><li>开启daemonize yes</li><li>修改port，pidfile，logfile，dbfilename</li><li>执行指令：redis-server 配置文件路径</li><li>在从机上运行SLAVEOF masterip  端口</li></ol><h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><h4 id="一主多仆："><a href="#一主多仆：" class="headerlink" title="一主多仆："></a>一主多仆：</h4><p>​        一个master多个slaver</p><h4 id="薪火相传："><a href="#薪火相传：" class="headerlink" title="薪火相传："></a>薪火相传：</h4><ul><li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。</li><li>中途变更转向:会清除之前的数据，重新建立拷贝最新的。</li><li>Slaveof 新主库IP 新主库端口</li></ul><h4 id="反客为主："><a href="#反客为主：" class="headerlink" title="反客为主："></a>反客为主：</h4><p>​        执行指令SLAVEOF no one，使当前数据库停止与其他数据库的同步，转成主数据库</p><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><h3 id="哨兵模式-sentinel-（实际开发中常用）"><a href="#哨兵模式-sentinel-（实际开发中常用）" class="headerlink" title="哨兵模式(sentinel)（实际开发中常用）"></a>哨兵模式(sentinel)（实际开发中常用）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ol><li>新建sentinel.conf文件</li><li>写入基本配置：sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 （最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机）</li><li>在Redis根目录下执行命令启动哨兵：Redis-sentinel  sentinel.conf 文件路径</li></ol><h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><p><a href="https://www.cnblogs.com/renpingsheng/p/9862485.html">Redis Cluter</a></p><h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>在设置键的过期时间的同时，创建一个定时器， 让定时器在键的过期时间来临时，立即执行对键的删除操作。对内存友好，但会占用CPU资源，影响响应时间和吞吐量。</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>被动删除，每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。对CPU友好，但会占用内存。</p><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>前两个的折中方案。每隔一段时间（默认10s，可在redis.conf中配置hz）程序就对数据库的expires字典进行一次扫描，删除里面的过期键。至于要扫描、删除多少过期键，以及要检查多少个数据库，则由算法决定。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br><strong>注：</strong></p><ol><li>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。</li><li>为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</li><li></li></ol><h2 id="aof-rdb和复制功能对过期键的处理"><a href="#aof-rdb和复制功能对过期键的处理" class="headerlink" title="aof/rdb和复制功能对过期键的处理"></a>aof/rdb和复制功能对过期键的处理</h2><h3 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h3><ul><li>生成rdb文件：程序会对键进行检查，过期键不放入rdb文件。</li><li>载入rdb文件：如果以主服务器模式运行，程序会对文件中保存的键进行检查，过期键会被忽略；如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。</li></ul><h3 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h3><ul><li>当服务器以aof持久化模式运行时，当过期键被删除后，程序会向aof文件追加一条del命令来显式记录该键已被删除。</li><li>aof重写过程中，程序会对数据库中的键进行检查，过期键则会被忽略。</li></ul><h3 id="集群复制"><a href="#集群复制" class="headerlink" title="集群复制"></a>集群复制</h3><p>Redis集群运行在复制模式下时，从服务器的过期删除动作由主服务器控制。</p><ul><li><p>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键。</p></li><li><p>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键，保持数据一致性。</p></li></ul><h2 id="其他重要知识链接"><a href="#其他重要知识链接" class="headerlink" title="其他重要知识链接"></a>其他重要知识链接</h2><p><a href="https://blog.csdn.net/miss1181248983/article/details/90056960">Redis三种集群详解</a></p><p><a href="https://blog.csdn.net/houjixin/article/details/27680183">Redis同步机制</a></p><p><a href="https://blog.csdn.net/qq_41453285/article/details/103224875">Redis对象与编码</a></p><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html">Redis内存模型</a></p><p><a href="https://blog.csdn.net/Design407/article/details/103242874?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160726406319724827617155%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160726406319724827617155&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_click~default-1-103242874.pc_v1_rank_blog_v1&utm_term=redis&spm=1018.2118.3001.4450">Redis常问问题</a></p><p><a href="https://blog.csdn.net/shuningzhang/article/details/89445417">Redis通讯协议</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis之java简单使用</title>
      <link href="2020/09/25/Redis/Redis%E4%BD%BF%E7%94%A8/"/>
      <url>2020/09/25/Redis/Redis%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​    Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉 </p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h5 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="代码示例（与命令行操作基本一致）"><a href="#代码示例（与命令行操作基本一致）" class="headerlink" title="代码示例（与命令行操作基本一致）"></a>代码示例（与命令行操作基本一致）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"> <span class="comment">//验证密码，如果没有设置密码这段代码省略</span></span><br><span class="line">jedis.auth(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.print(<span class="string">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line">System.out.println(<span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());</span><br><span class="line">System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());</span><br><span class="line">System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());</span><br><span class="line">System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());</span><br><span class="line">System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span>+jedis.mset(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;key04&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="comment">//添加名称为hash（key）的hash元素</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;hash&quot;</span>,map);</span><br><span class="line"><span class="comment">//向名称为hash的hash中添加key为key5，value为value5元素</span></span><br><span class="line">jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Map&lt;String,String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span>+jedis.hkeys(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span>+jedis.hvals(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return List&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">6</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span>+jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span>+jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;key4&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//……其他类型操作类似，可参考redis命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis事务</span></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">String result = jsonObject.toJSONString();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result);</span><br><span class="line">    <span class="comment">//再存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result);</span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果出现异常，回滚</span></span><br><span class="line">    multi.discard();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>));</span><br><span class="line">    <span class="comment">//最终关闭客户端</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis与SpringBoot整合"><a href="#Redis与SpringBoot整合" class="headerlink" title="Redis与SpringBoot整合"></a>Redis与SpringBoot整合</h2><h3 id="maven依赖-1"><a href="#maven依赖-1" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#数据库索引，默认0</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">      <span class="attr">jedis:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池最大连接数 </span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment">#连接池最大阻塞连接时间，负值表示无限制</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">5</span> <span class="comment">#连接池中最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池最小空闲连接</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">shutdown-timeout:</span> <span class="string">100ms</span> <span class="comment">#关闭超时时间，默认100ms</span></span><br></pre></td></tr></table></figure><h3 id="自定义Redistemplate模板"><a href="#自定义Redistemplate模板" class="headerlink" title="自定义Redistemplate模板"></a>自定义Redistemplate模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(factory);</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> </span><br><span class="line">          Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      <span class="comment">//解决缓存转换异常的问题</span></span><br><span class="line">      ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//设置所有访问权限以及所有的实际类型都可序列化和反序列化</span></span><br><span class="line">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">       <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的 </span></span><br><span class="line">      om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">      </span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">      template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//必须执行这个函数,初始化RedisTemplate</span></span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="2020/09/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitMq/"/>
      <url>2020/09/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitMq/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件（MQ）"><a href="#消息中间件（MQ）" class="headerlink" title="消息中间件（MQ）"></a>消息中间件（MQ）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。——百度百科</p><p>​    MQ全称为Message Queue，消息队列是程序和程序之间的通信方法。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>实现项目通讯与解耦   </li></ul><p>MQ相当于一个中介，消息生产方将消息发给MQ，消息消费方接收消息并进行相应逻辑处理，它将两应用程序进行解耦合。</p><ul><li>处理异步任务</li></ul><p>​        在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p><ul><li>   削峰填谷</li></ul><p>  如订单抢票系统，开始抢票瞬间高请求，高并发，若此时都操作数据库，需要大量IO操作，消耗系统性能，系统很可能崩溃，我们可以先将订单存消息队列里，然后系统就可以避开高峰期再按照自己的消费能力消费消息队列里的消息。</p><h2 id="主流实现方式"><a href="#主流实现方式" class="headerlink" title="主流实现方式"></a>主流实现方式</h2><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>​    AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF/1619218">消息</a>队列协议，是<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788">应用层</a>协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240">中间件</a>不同产品，不同的开发语言等条件的限制。<a href="https://baike.baidu.com/item/Erlang">Erlang</a>中的实现有<a href="https://baike.baidu.com/item/RabbitMQ">RabbitMQ</a>等。                                                                                                                               ——百度百科</p><p>AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>​    JMS即Java消息服务（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/5899771">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中发送消息，进行<a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/2273903">异步通信</a>。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。                                                                                                                                                                                                    ——百度百科</p><h3 id="AMQP-与-JMS-区别"><a href="#AMQP-与-JMS-区别" class="headerlink" title="AMQP 与 JMS 区别"></a>AMQP 与 JMS 区别</h3><ul><li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li><li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li><li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li></ul><h3 id="常见的消息队列"><a href="#常见的消息队列" class="headerlink" title="常见的消息队列"></a>常见的消息队列</h3><ul><li><p>ActiveMQ：基于JMS</p></li><li><p>ZeroMQ：基于C语言开发</p></li><li><p>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</p></li><li><p>RocketMQ：基于JMS，阿里巴巴产品</p></li><li><p>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</p><p>  <a href="https://blog.csdn.net/qq_35246620/article/details/107175767">优缺点</a></p></li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a href="http://www.rabbitmq.com/">官网</a></p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/%E5%BA%93">库</a>。        ——百度百科</p><h3 id="6种模式"><a href="#6种模式" class="headerlink" title="6种模式"></a>6种模式</h3><ul><li><p>简单模式：一个生产者发送消息到队列,一个消费者接收，不需要设置交换机（使用默认的交换机）</p></li><li><p>work工作队列模式，一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者竞争同一个队列的消息</p></li><li><p>Publish/Subscribe发布与订阅模式：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者</p></li><li><p>Routing路由模式（direct模式）：生产者发送消息到交换机并且要指定路由key，消费者将队列绑定到交换机时需要指定路由key</p></li><li><p>Topics通配符模式:  生产者发送消息到交换机，交换机类型设置topic，交换机根据绑定队列的routing key的值进行通配符匹配，</p><p>  “#”：匹配零个或者多个词topic.# 可以匹配topic，topic.text，topic.test.queue</p><p>  “<em>“：匹配l零个或一个词，topic.</em> 可以匹配topic，topic.text或topic.queue</p></li><li><p>RPC远程调用模式：功能如名，调用远程项目的功能并等待结果。</p></li></ul><h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><h4 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a><strong>maven坐标</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="java代码示例"><a href="#java代码示例" class="headerlink" title="java代码示例"></a>java代码示例</h4><p>注：这里以direct模式示例，其他模式类似</p><h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置Rabbitmq主机地址,默认localhost</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//设置端口,默认5672</span></span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line"><span class="comment">//设置虚拟主机，默认 /</span></span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line"><span class="comment">//连接密码；默认为guest</span></span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//通过连接工厂创建连接</span></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">// 通过connection创建一个Channel通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的信息</span></span><br><span class="line">String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">.deliveryMode(<span class="number">2</span>)<span class="comment">//2消息持久化；1重启消息丢失</span></span><br><span class="line">.contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">.expiration(<span class="string">&quot;10000&quot;</span>)<span class="comment">//十秒失效</span></span><br><span class="line">.headers(headers)</span><br><span class="line">.build();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span></span><br><span class="line"><span class="comment">* 参数2：路由key,简单模式可以传递队列名称</span></span><br><span class="line"><span class="comment">* 参数3：消息其它属性</span></span><br><span class="line"><span class="comment">* 参数4：消息内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;test_direct_exchange&quot;</span>, <span class="string">&quot;test.direct&quot;</span>, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory() ;  </span><br><span class="line"></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//自动恢复连接</span></span><br><span class="line">connectionFactory.setAutomaticRecoveryEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//自动恢复在尝试重新连接之前要等待多长时间，默认5000ms</span></span><br><span class="line">connectionFactory.setNetworkRecoveryInterval(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">Channel channel = connection.createChannel();  </span><br><span class="line"><span class="comment">//4 声明</span></span><br><span class="line">String exchangeName = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line">String exchangeType = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">String queueName = <span class="string">&quot;test_direct_queue&quot;</span>;</span><br><span class="line">String routingKey = <span class="string">&quot;test.direct&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示声明了一个交换机</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, exchangeType, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 声明（创建）队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：队列名称</span></span><br><span class="line"><span class="comment">* 参数2：是否持久化队列</span></span><br><span class="line"><span class="comment">* 参数3：是否独占连接</span></span><br><span class="line"><span class="comment">* 参数4：是否在不使用的时候自动删除队列</span></span><br><span class="line"><span class="comment">* 参数5：队列其它参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//建立一个绑定关系:</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//durable 是否持久化消息</span></span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//参数：队列名称、是否自动ACK、Consumer</span></span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"><span class="comment">//循环获取消息  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">    <span class="comment">//获取消息，如果没有消息，这一步将会一直阻塞  </span></span><br><span class="line">    Delivery delivery = consumer.nextDelivery();  </span><br><span class="line">    String msg = <span class="keyword">new</span> String(delivery.getBody());    </span><br><span class="line">    System.out.println(<span class="string">&quot;收到消息：&quot;</span> + msg);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="用xml配置方式与spring整合"><a href="#用xml配置方式与spring整合" class="headerlink" title="用xml配置方式与spring整合"></a>用xml配置方式与spring整合</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><h5 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h5><p>注：以下配置rabbitMQ可靠性投递用到，消息的延迟投递，做二次确认，回调检查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入spring配置文件 ，便于下方配置变量引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:application.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 创建连接类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;rabbitmqConnectionFactory&quot;  class=&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg value=&quot;localhost&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的账户,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;username&quot; value=&quot;$&#123;rmq.manager.user&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的密码,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;password&quot; value=&quot;$&#123;rmq.manager.password&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- host,RabbitMQ服务器地址，默认值&quot;localhost&quot; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;host&quot; value=&quot;$&#123;rmq.ip&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- port，RabbitMQ服务端口，默认值为5672 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;port&quot; value=&quot;$&#123;rmq.port&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- channel-cache-size，channel的缓存数量，默认值为25 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;channel-cache-size&quot; value=&quot;50&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--cache-mode，缓存连接模式，默认值为CHANNEL(单个connection连接，连接之后关闭，自动销毁) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;cache-mode&quot; value=&quot;CHANNEL&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--或者这样配置，connection-factory元素实际就是注册一个org.springframework.amqp.rabbit.connection.CachingConnectionFactory实例--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;$&#123;rmq.ip&#125;&quot;</span> <span class="attr">port</span>=<span class="string">&quot;$&#123;rmq.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;rmq.manager.virtual&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;$&#123;rmq.manager.user&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;$&#123;rmq.manager.password&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span> <span class="attr">publisher-returns</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注：publisher-confirms=&quot;true&quot; publisher-returns=&quot;true&quot;用于开启消息投递的回调监听，若想使用必须配置--&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产者部分 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发送消息的producer类，也就是生产者 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;RabbitmqProduct&quot;</span> <span class="attr">class</span>=<span class="string">&quot;生产者类路径&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--routingKey的 value中的值就是producer中的的routingKey，它与上面的rabbit:bindings标签中的key必须相同 -&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;exchange&quot; value=&quot;$&#123;rmq.manager.exchange&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;routingKey&quot; value=&quot;$&#123;rmq.manager.routingKey&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;delayKey&quot; value=&quot;$&#123;rmq.manager.key_delay&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;rabbitTemplate&quot; ref=&quot;rabbitTemplate&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;!-- spring amqp默认的是jackson 的一个插件,目的将生产者生产的数据转换为json存入消息队列，由于fastjson的速度快于jackson,这里替换为fastjson的一个实现 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;jsonMessageConverter&quot; class=&quot;com.jy.utils.FastJsonMessageConverter&quot;&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或者配置jackson --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--消息成功投递后回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--消息找不到对应交换机或routingkey，投递失败回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--exchange=&quot;Anyview_exchange&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span>  <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">confirm-callback</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">return-callback</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">mandatory</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费者部分 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义消息队列,durable:是否持久化，</span></span><br><span class="line"><span class="comment">    如果想在RabbitMQ退出或崩溃的时候，不会失去所有的queue和消息，需要同时标志队列(queue)和交换机(exchange)是持久化的，即rabbit:queue标签和rabbit:direct-exchange中的durable=true,而消息(message)默认是持久化的可以看类org.springframework.amqp.core.MessageProperties中的属性</span></span><br><span class="line"><span class="comment">public static final MessageDeliveryMode DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span></span><br><span class="line"><span class="comment">    exclusive: 仅创建者可以使用的私有队列，断开后自动删除；</span></span><br><span class="line"><span class="comment">    auto_delete: 当所有消费客户端连接断开后，是否自动删除队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--延时队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_delay&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  队列过期时间 10秒--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;java.lang.Long&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过期后消息将通过以下交换机和routingkey发送到死信队列--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-routing-key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--绑定队列,</span></span><br><span class="line"><span class="comment">rabbitmq的exchangeType常用的三种模式：direct，fanout，topic三种,</span></span><br><span class="line"><span class="comment">我们用direct模式，即rabbit:direct-exchange标签，Direct交换器很简单，</span></span><br><span class="line"><span class="comment">如果是Direct类型，就会将消息中的RoutingKey与该Exchange关联的所有Binding中的BindingKey进行比较，</span></span><br><span class="line"><span class="comment">如果相等，则发送到该Binding对应的Queue中。有一个需要注意的地方：如果找不到指定的exchange，就会报错。</span></span><br><span class="line"><span class="comment">但routing key找不到的话，不会报错，这条消息会直接丢失，所以此处要小心,</span></span><br><span class="line"><span class="comment">auto-delete:自动删除，如果为Yes，则该交换机所有队列queue删除后，自动删除交换机，默认为false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.routingKey&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_delay&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--死信队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange_dead&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于消息的监听的代理类MessageListenerAdapter --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;testQueueListenerAdapter&quot; class=&quot;org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter&quot; &gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg ref=&quot;Handler&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;defaultListenerMethod&quot; value=&quot;handlerTest&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;messageConverter&quot; ref=&quot;jsonMessageConverter&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;rabbit:direct-exchange id=&quot;$&#123;rmq.manager.exchange&#125;&quot; name=&quot;$&#123;rmq.manager.exchange&#125;&quot;  durable=&quot;false&quot; auto-delete=&quot;false&quot; &gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;/rabbit:direct-exchange&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义接口类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Handler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;消息类路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置监听acknowledeg=&quot;manual&quot;设置手动应答，它能够保证即使在一个worker处理消息的时候用CTRL+C来杀掉这个worker，或者一个consumer挂了(channel关闭了、connection关闭了或者TCP连接断了)，也不会丢失消息。</span></span><br><span class="line"><span class="comment">    因为RabbitMQ知道没发送ack确认消息导致这个消息没有被完全处理，将会对这条消息做re-queue处理。</span></span><br><span class="line"><span class="comment">    如果此时有另一个consumer连接，消息会被重新发送至另一个consumer会一直重发,直到消息处理成功,</span></span><br><span class="line"><span class="comment">    监听容器acknowledge=&quot;auto&quot; concurrency=&quot;30&quot;设置发送次数,最多发送30次 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--concurrency=&quot;20&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Handler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="keyword">private</span> String routingKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String delayKey;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此服务用于将消息持久化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rabbitmq发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketMsg 消息实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isFirst 是否第一次发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(SocketMsg socketMsg, <span class="keyword">boolean</span> isFirst)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次发送前先持久化</span></span><br><span class="line">        <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">            socketMsgService.insert(socketMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CorrelationData消息唯一ID</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object jsonSocketMsg = JSON.toJSON(socketMsg);</span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,routingKey, jsonSocketMsg, </span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()));</span><br><span class="line">            <span class="comment">//发送到延时队列</span></span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,delayKey, jsonSocketMsg,</span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()+<span class="string">&quot;delay&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExchange</span><span class="params">(String exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoutingKey</span><span class="params">(String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayKey</span><span class="params">(String delayKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayKey = delayKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="延时队列消费者代码"><a href="#延时队列消费者代码" class="headerlink" title="延时队列消费者代码"></a>延时队列消费者代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitmqProduct rabbitmqProduct;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        Object parse = JSONObject.parse(message.getBody());</span><br><span class="line">        log.info(parse.toString());</span><br><span class="line">        SocketMsg socketMsg = JSONObject.parseObject(message.getBody(), SocketMsg.class);</span><br><span class="line">        log.info(socketMsg.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息未成功投递</span></span><br><span class="line">        <span class="keyword">if</span>(socketMsgService.findById(socketMsg.getId()).getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//未超过重试次数</span></span><br><span class="line">            <span class="keyword">if</span> (socketMsgService.getTryCountById(socketMsg.getId()) &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//添加重试次数</span></span><br><span class="line">                socketMsgService.addTryCountById(socketMsg.getId());</span><br><span class="line">                rabbitmqProduct.sendMessage(socketMsg, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="投递成功回调类"><a href="#投递成功回调类" class="headerlink" title="投递成功回调类"></a>投递成功回调类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;confirmCallBackListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallBackListener</span> <span class="keyword">implements</span> <span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;################发送到exchange成功:&quot;</span>+correlationData);</span><br><span class="line">            <span class="comment">//非延时队列的消息确认</span></span><br><span class="line">            <span class="keyword">if</span> (!correlationData.getId().endsWith(<span class="string">&quot;delay&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//将数据库消息标志置为成功发送</span></span><br><span class="line">                socketMsgService.succeedSendById(Long.parseLong(correlationData.getId()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;#########发送失败:&quot;</span>+correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="投递失败回调类"><a href="#投递失败回调类" class="headerlink" title="投递失败回调类"></a>投递失败回调类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallBackListener</span> <span class="keyword">implements</span> <span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, </span></span></span><br><span class="line"><span class="function"><span class="params">                                String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;无对应key队列，发送失败了&quot;</span>+message);</span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><h5 id="配置与上面延时队列的消息接收方类似，此处不再累赘"><a href="#配置与上面延时队列的消息接收方类似，此处不再累赘" class="headerlink" title="配置与上面延时队列的消息接收方类似，此处不再累赘"></a>配置与上面延时队列的消息接收方类似，此处不再累赘</h5><p><a href="https://blog.csdn.net/Design407/article/details/103636161?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328602.14831.16149505641775423&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">常问问题1</a></p><p><a href="https://blog.csdn.net/thinkwon/article/details/104588612/">常问问题2</a></p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis事务与配置</title>
      <link href="2020/09/24/Redis/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>2020/09/24/Redis/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="通常情况下的事务"><a href="#通常情况下的事务" class="headerlink" title="通常情况下的事务"></a>通常情况下的事务</h3><h4 id="事务的基本要素即四大特性（ACID）"><a href="#事务的基本要素即四大特性（ACID）" class="headerlink" title="事务的基本要素即四大特性（ACID）"></a>事务的基本要素即四大特性（ACID）</h4><ul><li><p>原子性（Atomicity）：事务所有操作指令，要么全部完成，要么全部不做。</p></li><li><p>一致性（Consistency）：事务提交后，数据库从一个一致性状态变到另一个一致性状态。</p><p>  如事务（a-100，b+100）执行后a减100，b一定加100，不然a，b就都不变</p></li><li><p>隔离性（Isolation）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。</p></li><li><p>持久性（Durability）：事务一旦提交后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p></li></ul><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>​     本质：一组指令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li><p><strong>Redis事务没有隔离级别的概念！</strong></p><p> 一个事务的所有指令并没有被直接执行，而是存入队列中，只有发起执行命令（Exec）的时候才会顺序执行！</p></li><li><p><strong>Redis单条命令保证原子性，但是事务不保证原子性！</strong></p></li><li><p><strong>单独的隔离操作</strong></p><p> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p></li></ol><h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>开启事务：multi</li><li>输入命令入队列：set key value  ……</li><li>提交事务：exec  或 撤销事务：discard</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><p>​        命令有问题，事务所有的命令都不会被执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2  <span class="comment">#错误命令</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">EXECABORT Transaction discarded because of previous errors.  <span class="comment">#执行事务报错</span></span><br><span class="line">&gt; get key2  </span><br><span class="line">null</span><br><span class="line">&gt; get key1 <span class="comment">#所有命令都不会被执行</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure><h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>​    如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的（Redis事务不保证原子性）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k1 abc</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k1  <span class="comment">#k1为字符串，无法加1</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range  <span class="comment"># incr k1执行报错</span></span><br><span class="line">4) <span class="string">&quot;abc&quot;</span></span><br><span class="line">5) <span class="string">&quot;3&quot;</span></span><br><span class="line">&gt; get k2  <span class="comment">#其他命令正常执行</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="监控watch"><a href="#监控watch" class="headerlink" title="监控watch"></a>监控watch</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​    很悲观，总是认为最坏情况，拿数据的时候数据都会被别人修改，无论什么时候都加锁，效率低下</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​    很乐观，总是认为最好情况，拿数据的时候数据都不会被别人修改，所以不加锁，在更新数据的时候先判断下，拿数据这期间有没有人修改过此数据（mysql中可增加一版本字段version，更新前比较此字段）</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi   </span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#事务正常结束，数据期间没有发生变动，这时候事务正常执行</span></span><br><span class="line">80</span><br><span class="line">20</span><br><span class="line">&gt; get money</span><br><span class="line">80</span><br></pre></td></tr></table></figure><p>使用多客户端即多线程修改值，使用watch可以当作Redis的乐观锁操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#执行之前，其他客户端执行 set money 10</span></span><br><span class="line">null  <span class="comment">#对比watch监控的money，发生变化，修改失败</span></span><br><span class="line"></span><br><span class="line">&gt; unwatch  <span class="comment">#执行失败，就先解锁</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money <span class="comment">#获取最新值，再次监控（此时money=10，usedMoney=0）</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">&gt; get money</span><br><span class="line">5</span><br><span class="line">&gt; get usedMoney</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="配置文件Redis-conf"><a href="#配置文件Redis-conf" class="headerlink" title="配置文件Redis.conf"></a>配置文件Redis.conf</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">unit(单位)</span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line">只支持bytes，不支持bit，对大小写不敏感</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INCLUDES模块</span><br><span class="line"><span class="comment"># include .\path\to\local.conf</span></span><br><span class="line"><span class="comment"># include c:\path\to\other.conf</span></span><br><span class="line">可通过include 包含其他文件</span><br><span class="line"></span><br><span class="line">网络</span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment">#绑定ip</span></span><br><span class="line">port 6379<span class="comment">#端口</span></span><br><span class="line">protected-mode yes <span class="comment">#保护模式，默认开启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GENERAL通用配置模块</span><br><span class="line">daemonize yes <span class="comment">#以守护进程执行（后台与运行）</span></span><br><span class="line">pidfile /var/run/redis.pid <span class="comment">#如果以守护进程方式运行，需指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice <span class="comment">#日志级别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment">#日志文件位置</span></span><br><span class="line">databases 16 <span class="comment">#数据库数量</span></span><br><span class="line"></span><br><span class="line">Tcp-keepalive <span class="comment">#连接检测，单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </span></span><br><span class="line">tcp-backlog</span><br><span class="line"><span class="comment">#设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境</span></span><br><span class="line"><span class="comment">#下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以</span></span><br><span class="line"><span class="comment">#需要确认增大somaxconntcp_max_syn_backlog两个值来达到想要的效果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SNAPSHOTTING快照模块</span><br><span class="line"><span class="comment">#达到已下条件，就进行保存</span></span><br><span class="line">save 900 1 <span class="comment">#15分钟内改了1次。</span></span><br><span class="line">save 300 10 <span class="comment">#5分钟内改了10次，</span></span><br><span class="line">save 60 10000 <span class="comment">#1分钟内改了1万次，</span></span><br><span class="line"><span class="comment">#如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#持久化操作出错，是否继续工作</span></span><br><span class="line">rdbcompression yes  <span class="comment">#对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes <span class="comment">#存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</span></span><br><span class="line">dir ./ <span class="comment">#db文件的保存路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECURITY安全模块</span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass <span class="string">&quot;&quot;</span>  <span class="comment">#配置redis密码，默认空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LIMITS限制模块</span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"><span class="comment">#设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment">#设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</span></span><br><span class="line"><span class="comment">#如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信</span></span><br><span class="line"><span class="comment">#息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从#redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，</span></span><br><span class="line"><span class="comment">#才不用考虑这个因素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction  <span class="comment">#内存达到上限后处理策略</span></span><br><span class="line"><span class="comment">#（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（2）allkeys-lru：使用LRU算法移除key</span></span><br><span class="line"><span class="comment">#（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（4）allkeys-random：移除随机的key</span></span><br><span class="line"><span class="comment">#（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</span></span><br><span class="line"><span class="comment">#（6）noeviction：不进行移除。针对写操作，只是返回错误信息</span></span><br><span class="line"></span><br><span class="line">maxmemory-samples 5 <span class="comment">#设置检查的样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，</span></span><br><span class="line"><span class="comment">#redis默认会检查这么多个key并选择其中LRU的那个，LRU和最小TTL算法不是精确算法而是近似算法，该值越大越精准，但cpu成本高，</span></span><br><span class="line"><span class="comment">#3较快，默认5，10非常接近</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APPEND ONLY MODE附加模块</span><br><span class="line">appendonly no <span class="comment">#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时</span></span><br><span class="line"><span class="comment">#导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</span></span><br><span class="line"><span class="comment">#默认为no</span></span><br><span class="line">appendfsync everysec  <span class="comment">#指定更新日志条件，共有3个可选值： </span></span><br><span class="line"><span class="comment">#  no：表示等操作系统进行数据缓存同步到磁盘（快） </span></span><br><span class="line"><span class="comment">#  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span></span><br><span class="line"><span class="comment">#  everysec：表示每秒同步一次（折衷，默认值）</span></span><br><span class="line"></span><br><span class="line">appendfilename appendonly.aof <span class="comment">#指定更新日志文件名，默认为appendonly.aof</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">No-appendfsync-on-rewrite no <span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</span></span><br><span class="line"></span><br><span class="line">Auto-aof-rewrite-min-size 64mb <span class="comment">#设置重写的基准值 大小</span></span><br><span class="line">Auto-aof-rewrite-percentage  100 <span class="comment"># 设置重写的基准值 百分比</span></span><br><span class="line"></span><br><span class="line">vm-enabled no <span class="comment">#指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷</span></span><br><span class="line"><span class="comment">#数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span><br><span class="line">   </span><br><span class="line">vm-swap-file /tmp/redis.swap <span class="comment"># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span><br><span class="line">   </span><br><span class="line">vm-max-memory 0 <span class="comment">#将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span></span><br><span class="line">   </span><br><span class="line">vm-page-size 32 <span class="comment"># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，</span></span><br><span class="line"><span class="comment">#vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很</span></span><br><span class="line"><span class="comment">#大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span></span><br><span class="line">   </span><br><span class="line">vm-pages 134217728 <span class="comment"># 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘</span></span><br><span class="line"><span class="comment">#上每8个pages将消耗1byte的内存。</span></span><br><span class="line">   </span><br><span class="line">vm-max-threads 4 <span class="comment"># 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，</span></span><br><span class="line"><span class="comment">#可能会造成比较长时间的延迟。默认值为4</span></span><br><span class="line">   </span><br><span class="line">glueoutputbuf yes <span class="comment"># 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://redis.io/">官网</a></p><p><a href="http://www.redis.cn/">中文文档</a></p><p><a href="https://github.com/redis/">git地址</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。（百度百科）</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</li><li>redis默认16个数据库，类似数组下表从零开始，默认数据库为0，可以使用SELECT  id 命令切换指定数据库。</li><li>Redis索引都是从零开始</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li><li>redis6.0前是单线程的，6.0后支持多线程，默认单线程</li></ul><h4 id="redis使用单线程原因"><a href="#redis使用单线程原因" class="headerlink" title="redis使用单线程原因"></a>redis使用单线程原因</h4><ol><li>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li></ol><!--注：Redis进行持久化的时候会以子进程或者子线程的方式执行--><h4 id="Redis的高并发和快速原因"><a href="#Redis的高并发和快速原因" class="headerlink" title="Redis的高并发和快速原因"></a><strong>Redis的高并发和快速原因</strong></h4><ol><li>redis是基于内存的，内存的读写速度比硬盘快得多；（CPU高速缓存&gt;内存&gt;外存（硬盘、光盘、U盘等））</li><li>redis是单线程的，省去了很多CPU上下文切换线程的时间；(CPU上下文切换是很耗内存的)</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll（Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。）和自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。“多路”指的是多个socket连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>keys * ：查看所有key（*匹配所有字符，？匹配单个字符,如 keys  ?ist可匹配 list，aist，bist……）</li><li>info 查看redis详细信息，key数量也在里面</li><li>set key value：存入键值对</li><li>get key：获取key对应值</li><li>DBSIZE：查看当前基本数据库大小（当前数据库的key的数量）。</li><li>Flushdb：清空当前库 | Flushall：通杀全部库</li><li>exists key : 判断key是否存在（存在返回1，不存在返回2）</li><li>del key：删除key</li><li>rename key newname：重命名key</li><li>move key  db_id  ：将当前数据库的 key 移动到给定的数据库 db 当中。</li><li>type key ：查看当前key存储类型</li><li>expire key second(秒) 设置超时时间（即几秒后过期）</li><li>ttl key 查看key剩余时间（-1表示永久有效，-2表示当前key不存在）</li><li>persist key 移除过期时间，让key永久有效</li><li>set key value [EX seconds] [PX milliseconds] [NX|XX] (EX 200：200秒后过期，NX：key不存在才操作，XX： key已存在才操作)</li><li>shutdown：关闭redis</li></ul><h3 id="设置修改密码"><a href="#设置修改密码" class="headerlink" title="设置修改密码"></a>设置修改密码</h3><h4 id="1-客户端连接修改"><a href="#1-客户端连接修改" class="headerlink" title="1.客户端连接修改"></a>1.<strong>客户端连接修改</strong></h4><!--立即生效，具有临时性，重启失效--><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##到安装目录下打开命令行</span></span><br><span class="line"><span class="comment">#wingdow下客户端连接 redis-cli.exe -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"><span class="comment">#Linux下客户端连接 ./redis-cli -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##查看密码（默认为空）</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;&quot;  //默认空</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码 config set requirepass 123456</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; config set requirepass 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass //密码设置后必须先验证通过密码，否则所有命令都不可用</span></span><br><span class="line"><span class="meta">(error)</span> <span class="string">NOAUTH Authentication required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证密码 auth &#123;密码&#125;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; auth 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.<strong>修改配置文件</strong></h4><!-- 永久生效--><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到redis.conf配置文件中的requirepass</span></span><br><span class="line"><span class="comment">#requirepass foobared</span></span><br><span class="line"><span class="comment">#去掉注释配置自己密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">&#123;密码&#125;</span></span><br><span class="line"><span class="attr">保存后重启</span></span><br></pre></td></tr></table></figure><h3 id="五大基本类型"><a href="#五大基本类型" class="headerlink" title="五大基本类型"></a>五大基本类型</h3><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><p>​        String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>​        底层没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了<strong>SDS</strong>(简单动态字符串/Simple Dynamic String)</p><p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p><p>补：String内部编码有三种方式，可使用object encoding key 查看。</p><ol><li>int ： 长度小于20且保存的是64位有符号整型类型。</li><li>embstr：长度小于等于44，对于嵌入式的String，从内存结构上说，就是字符串sds结构体与其对应的redisObject对象分配在同一块连续的内存空间，<strong>只需一次内存分配</strong>。</li><li>raw：长度大于44，redisObject内存不在连续，采用指针的形式，实现连接。<strong>需要分配两次内存空间</strong>（分别为redisObject和sds分配空间）。</li></ol><h5 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h5><ol><li><p>append key value ：往字符串后面追加字符串（若key不存在，则新建key，相当于set key value）</p></li><li><p>strlen key ：返回字符串长度</p></li><li><p>incr key： 自增1</p></li><li><p>decr key：自减1</p></li><li><p>incrby key num：自增num</p></li><li><p>decrby key num：自减num</p></li><li><p>getrange key start end ：截取字符串[start,end] [0,-1]表示全部</p></li><li><p>setrange key start str ：用str替换指定位置开始的字符串</p></li><li><p>setex  key seconds value：保存key-value并设置过期时间（set with expire）</p></li><li><p>setnx key value：不存在则设置（set if not exist），成功返回1，若已存在，则创建失败，返回-1</p></li><li><p>mset  k1 v1 k2 v2 k3 v3：同时设置多个值</p></li><li><p>mget  k1 k2 k3： 同时获取多个值</p></li><li><p>getset key value：先get后set，如果不存在则返回null，如果存在，则返回旧值，再设置新值</p></li></ol><p><a href="https://blog.csdn.net/yangbodong22011/article/details/78419966">深入理解String</a></p><h4 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h4><p>​        列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层是<strong>压缩列表（ziplist）或双端链表（linkedlist）</strong>（Redis3.2后改为快表quicklist，前两个的结合）。</p><h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li><p>LPUSH list value1  value2 value3 …… ：将一个或多个值插入列表头部（左部）</p></li><li><p>LRANGE  list start end ：[start,end]通过区间获取列表具体值,[0,-1]获取list全部</p></li><li><p>RPUSH list  value1  value2 value3 …… ：将一个或多个值插入列表尾部（右部）</p></li><li><p>LPOP list ：移除列表的第一个元素</p></li><li><p>RPOP list：移除列表的最后一个值</p></li><li><p>Lindex list  index ：通过下标获取 元素</p></li><li><p>Llen list：返回列表长度</p></li><li><p>Lrem lsit  count value：移除list中count个value</p></li><li><p>ltrim list start end：通过下标截取list，原list已经被改变</p></li><li><p>rpoplpush sourceList newList：移除sourceList列表的最后一个元素，将他移动到newList列表中</p></li><li><p>lset list index newvalue： 替换将列表指定下标值（list或index不存在则报错）</p></li><li><p>linsert list value before|after newValue：将某一个具体的newValue插入到第一个value前面|后面</p></li></ol><h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><p>Set是string类型的无序集合，不可重复。它是通过<strong>整数集合（intset）或哈希表（hashtable）</strong>实现的。</p><h5 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li>sadd set value1 value2 value3 ……：往set集合添加元素</li><li>smembers set：查看set元素</li><li>sismembers set  value：是否存在指定元素（存在返回1，不存在返回0）</li><li>scard set：查看set集合元素数</li><li>srem set value ：移除set集合指定元素</li><li>srandmember set （count）：随机抽取num个元素（count不写默认一个）</li><li>spop  set （count）：随机移除count个元素</li><li>smove  set1 set2 value：将set1中value移动到set2中</li><li>sdiff set1 set2：set1与set2取差集，返回set1中存在，set2不存在的元素集合</li><li>sinter set1 set2 ：取交集</li><li>sunion set1 set2：取并集</li></ol><h4 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h4><p>hash 是一个键值对集合,是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;。底层是<strong>压缩列表（ziplist）或哈希表（hashtable）</strong>实现。</p><h5 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li>hset hash key value ：存入hash一个 key-value键值对</li><li>hget  hash key：获取hash中key的值</li><li>hmset hash key1 value1 key2 value2 ……：存入hash多个键值对</li><li>hmget hash key1 key2 ……：获取hash多个key字段的值</li><li>hgetall hash ：获取全部key-value内容</li><li>hdel hash key ：删除hash中指定key字段</li><li>hlen hash ：返回hash长度</li><li>hexists hash key：判断hash中key字段是否存在</li><li>hkeys hash：返回所有key字段</li><li>hvals  hash：放回所有value</li><li>hincrby hash key  num：指定key增量num</li><li>hsetnx hash key value：不存在则存入</li></ol><h4 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合(Zset)"></a>有序集合(Zset)</h4><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。底层使用<strong>压缩列表（ziplist）或跳跃表（skiplist）</strong>实现。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p><h5 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li><p>ZADD key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数.</p></li><li><p>ZCARD key 获取有序集合的成员数.</p></li><li><p>ZCOUNT key min max 计算在有序集合中指定区间分数[min,max]的成员数。</p></li><li><p>ZINCRBY key increment member:有序集合中对指定成员的分数加上增量 increment。</p></li><li><p>ZINTERSTORE newkey num key …:计算给定的一个或多(num)个有序集key的交集并将结果集存储在新的有序集合 newkey 中。</p></li><li><p>ZLEXCOUNT key min max:在有序集合中计算指定字典区间内成员数量。</p><p> min max: { - [a =(-∞，a]; -  (a=(-∞，a)；[a [b=[a,b];-  +=(-∞,+∞)</p></li><li><p>ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员。-inf +inf = -∞ +∞</p></li><li><p>ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员。</p></li><li><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员。</p></li><li><p>ZRANK key member 返回有序集合中指定成员的索引。</p></li><li><p>ZREM key member [member …] 移除有序集合中的一个或多个成员。</p></li><li><p>ZREMRANGEBYLEX key min max :移除有序集合中给定的字典区间的所有成员。</p></li><li><p>ZREMRANGEBYRANK key start stop:移除有序集合中给定的排名区间的所有成员。</p></li><li><p>ZREMRANGEBYSCORE key min max移除有序集合中给定的分数区间的所有成员。</p></li><li><p>ZREVRANGE key start stop [WITHSCORES]返回有序集中指定区间内的成员，通过索引，分数从高到低。</p></li><li><p>ZREVRANGEBYSCORE key max min [WITHSCORES]返回有序集中指定分数区间内的成员，分数从高到低排序。</p></li><li><p>ZREVRANK key member返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。</p></li><li><p>ZSCORE key member返回有序集中，成员的分数值。</p></li><li><p>ZUNIONSTORE destination numkeys key [key …]计算给定的一个或多个有序集的并集，并存储在新的 key 中。</p></li><li><p>ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）。</p></li></ol><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>​    集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，其实不太准确。</p><p>​    其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： </p><ul><li>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 </li><li>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) </li><li>其他的range操作复杂度一般为O(log(n))</li><li>当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</li></ul><h4 id="五大基本类型底层实现"><a href="#五大基本类型底层实现" class="headerlink" title="五大基本类型底层实现"></a>五大基本类型底层实现</h4><p><img src="/2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/Snipaste_2021-03-25_00-12-59.png" alt="Snipaste_2021-03-25_00-12-59"></p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="地理空间（geospatial-）"><a href="#地理空间（geospatial-）" class="headerlink" title="地理空间（geospatial ）"></a>地理空间（geospatial ）</h4><p>​    Redis的Geo，3.2版本推出，可以推算地理位置的信息，两地之间的距离</p><p>​    城市经纬度查询：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p><!--**注：有效经度为-180至180度。有效纬度为-85.05112878至85.05112878度。**--><h5 id="六大操作"><a href="#六大操作" class="headerlink" title="六大操作"></a>六大操作</h5><p><strong>geoadd   key  经度 维度 坐标名</strong>：添加地理位置（两级无法直接添加，可一次添加多个）， 先经度后维度（官方文档疑似写错了）</p><p>例：geoadd china:city   116.405285  39.904989     beijing    121.4   31.2  shanghai  ……</p><p>​                        key            经度     维度    地理名称</p><p><strong>geopos key  name1 name2……</strong>：获取key中name的地理位置</p><p>例：GEOPOS china:city beijing shanghai shenzhen xianggang</p><p><strong>georadius key  经度 维度 距离：</strong> 以给定的经纬度为中心，找出某一半径内所有的元素</p><p>例：GEORADIUS china:city 110 30 1000 km [withcoord] [withdist]</p><p><strong>GEORADIUSBYMEMBER key  坐标名（元素名） 距离</strong> ：根据给定的元素确定中心点，再进行查找</p><p>例：GEORADIUSBYMEMBER china:city beijing 1000 km [withcoord] [withdist]</p><!--注：withcoord：经纬度,withdist：距离坐标城市的距离，count num：筛选出num个结果--><p><strong>GEODIST  key name1  name2 [单位]</strong> ：返回指定单位中两个指定成员之间的距离。如果缺少一个或两个成员，该命令将返回NULL。</p><!--单位必须是以下之一，默认为米：m（米）、km（千米）、mi（英里）、ft（英尺）--><p>例：GEODIST china:city beijing xianggang km</p><p><strong>GEOHASH key name1 name2……</strong>：该命令返回11个字符的Geohash字符串，因此与Redis内部52位表示形式相比，不会损失任何精度。该命令返回一个数组，其中每个元素是与作为参数传递给命令的每个成员名称相对应的Geohash。</p><p>返回的Geohashhes具有以下属性：  </p><ol><li>以从右侧删除字符来缩短它们。它将失去精度，但仍将指向同一区域。</li><li>可以在<code>geohash.org</code>URL中使用它们，例如<code>http://geohash.org/&lt;geohash-string&gt;</code>。这是<a href="http://geohash.org/sqdtr74hyu0">此类URL</a>的<a href="http://geohash.org/sqdtr74hyu0">示例</a>。</li><li>前缀相似的字符串在附近，但事实并非如此，前缀不同的字符串也可能在附近。</li></ol><p>geo底层实现原理其实是zset，我们可以使用zset命令操作他</p><p>zrange key 0 -1：查看地图key中的所有元素</p><p>zrem key member：删除key中指定元素</p><h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p><strong>简介：Hyperloglog 可用于基数统计（基数：在数学上，是集合论中刻画任意集合集大小的一个概念。即一个集合中不重复的元素数。）</strong></p><p><strong>redis2.8.9后更新了hyperloglog数据结构</strong></p><p>示例：网页UV</p><p>uv（Unique Visitor）:网站的独立访客，统计1天内访问某站点的用户数(以cookie为依据);访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。</p><p>访问用户量大的情况下，若用传统的set集合统计将耗费大量内存。使用hyperloglog基数统计占用内存固定，2^64不同的元素，只需要废12kb内存。（官网统计hyperloglog有0.81%的错误率，但在统计UV任务上，我们可以忽略不计）</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>PFADD keyset  value1 value2 value3……往集合keyset中添加元素</p><p>PFCOUNT keyset：统计集合keyset的基数</p><p>PFMERGE  newset keyset1 ketset2：将集合keyset1和keyset2的元素合并（并集）到newset中</p><h4 id="Bitmap（位存储）"><a href="#Bitmap（位存储）" class="headerlink" title="Bitmap（位存储）"></a>Bitmap（位存储）</h4><p><strong>简介：</strong> Biymaps位图，该数据结构都是操作二进制位来记录数据的，就只有0和1两个状态。（适用于只有两个状态的数据）</p><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p>setbit  sign index  value：往sign的index（从0开始）位置上存value（0或1）</p><p>getbit sign index ：获取sign中index位上的值（默认0）</p><p>bitcount sign：统计sgin中为1的数量</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql中distinct简单使用</title>
      <link href="2020/09/22/SQL/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/09/22/SQL/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"><a href="#简介：distinct常用于sql语句中查出重复数据时需要去重的时候" class="headerlink" title="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"></a><strong>简介：distinct常用于sql语句中查出重复数据时需要去重的时候</strong></h3><!--distinct不会过滤掉null值，返回结果包含null值--><p>示例：table</p><table><thead><tr><th>column1</th><th>column2</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>1</td><td>b</td></tr><tr><td>2</td><td>c</td></tr><tr><td>2</td><td>c</td></tr><tr><td>3</td><td>d</td></tr><tr><td>null</td><td>e</td></tr><tr><td>null</td><td>f</td></tr><tr><td></td><td>g</td></tr></tbody></table><h3 id="只有一字段："><a href="#只有一字段：" class="headerlink" title="只有一字段："></a><strong>只有一字段</strong>：</h3><p>​        <strong>直接在字段前加distinct</strong></p><p>​        select distinct column1 from table</p><p>结果：</p><table><thead><tr><th>column1</th></tr></thead><tbody><tr><td>1</td></tr><tr><td>2</td></tr><tr><td>3</td></tr><tr><td>null</td></tr><tr><td></td></tr></tbody></table><h3 id="需要查出多个字段："><a href="#需要查出多个字段：" class="headerlink" title="需要查出多个字段："></a><strong>需要查出多个字段</strong>：</h3><p>​    distinct 需要放在第一个字段前面，否者报错</p><p>select distinct colum1 , colum2 from table;</p><p>结果：多个字段其实是多个字段查出后拼接再去重</p><table><thead><tr><th>column1</th><th>column2</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>1</td><td>b</td></tr><tr><td>2</td><td>c</td></tr><tr><td>3</td><td>d</td></tr><tr><td>null</td><td>e</td></tr><tr><td>null</td><td>f</td></tr><tr><td></td><td>g</td></tr></tbody></table><h3 id="只想一个字段唯一"><a href="#只想一个字段唯一" class="headerlink" title="只想一个字段唯一"></a><strong>只想一个字段唯一</strong></h3><p><strong>1.使用group by</strong></p><p>​    select column1, column2 from table group by column1</p><p><strong>2.使用GROUP_CONCAT函数</strong></p><p>​    <strong>GROUP_CONCAT在连接查询的时候，能让查出的这字段的多个数，按字符拼接的方式存放在一起。</strong></p><p>select GROUP_CONCAT(distinct column1) as column1, column2 from table group by column1</p><table><thead><tr><th>column1</th><th>column2</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>c</td></tr><tr><td>3</td><td>d</td></tr><tr><td>null</td><td>e</td></tr><tr><td></td><td>g</td></tr></tbody></table><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2.3.1.RELEASE与javaFx整合</title>
      <link href="2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/"/>
      <url>2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><figure class="highlight xml"><figcaption><span>&lt;dependency&gt;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.roskenet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-javafx-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动类继承AbstractJavaFxApplicationSupport"><a href="#启动类继承AbstractJavaFxApplicationSupport" class="headerlink" title="启动类继承AbstractJavaFxApplicationSupport"></a>启动类继承AbstractJavaFxApplicationSupport</h2><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375394146.png" alt="启动类"></p><h2 id="采用mvc模式"><a href="#采用mvc模式" class="headerlink" title="采用mvc模式"></a>采用mvc模式</h2><ul><li><h3 id="每个fxml页面都有对应的java视图类"><a href="#每个fxml页面都有对应的java视图类" class="headerlink" title="每个fxml页面都有对应的java视图类"></a>每个fxml页面都有对应的java视图类</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375588.png" alt="视图"></p><ul><li><h3 id="视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）"><a href="#视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）" class="headerlink" title="视图类需继承AbstractFxmlView且有**@FXMLView注解**（value值为对应的fxml文件路径）"></a>视图类需继承<strong>AbstractFxmlView</strong>且有**@FXMLView注解**（value值为对应的fxml文件路径）</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375950(1).jpg" alt="视图类"></p><ul><li><h3 id="fxml文件中需指定对应controller类"><a href="#fxml文件中需指定对应controller类" class="headerlink" title="fxml文件中需指定对应controller类"></a>fxml文件中需指定对应controller类</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376230(1).jpg" alt="fxml文件"></p><ul><li><h3 id="controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息"><a href="#controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息" class="headerlink" title="controller类需实现Initializable接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)"></a>controller类需实现<strong>Initializable</strong>接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376444(1).jpg"></p><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376926(1).jpg"></p><ul><li><h3 id="fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法"><a href="#fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法" class="headerlink" title="fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法"></a>fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377406(1).jpg"></p><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377507(1).jpg"></p><h2 id="示例页面效果展示-只是简单项目，页面可能有点丑"><a href="#示例页面效果展示-只是简单项目，页面可能有点丑" class="headerlink" title="示例页面效果展示(只是简单项目，页面可能有点丑)"></a>示例页面效果展示(只是简单项目，页面可能有点丑)</h2><ul><li><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377745(1).jpg" alt="登陆"></p><ul><li><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377865(1).jpg" alt="主页"></p><ul><li><h3 id="点击住宿按钮弹出住宿页面进行信息登记"><a href="#点击住宿按钮弹出住宿页面进行信息登记" class="headerlink" title="点击住宿按钮弹出住宿页面进行信息登记"></a>点击住宿按钮弹出住宿页面进行信息登记</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377915(1).jpg"></p><ul><li><h3 id="双击对应表格中的宿舍即可查看详情"><a href="#双击对应表格中的宿舍即可查看详情" class="headerlink" title="双击对应表格中的宿舍即可查看详情"></a>双击对应表格中的宿舍即可查看详情</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378007(1).jpg"></p><ul><li><h3 id="宿舍管理页面"><a href="#宿舍管理页面" class="headerlink" title="宿舍管理页面"></a>宿舍管理页面</h3></li></ul><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378103(1).jpg"></p><h2 id="获取项目"><a href="#获取项目" class="headerlink" title="获取项目"></a>获取项目</h2><ul><li><h3 id="Git仓库地址"><a href="#Git仓库地址" class="headerlink" title="Git仓库地址"></a><a href="https://github.com/czmDeRepository/javaFx">Git仓库地址</a></h3></li><li><h3 id="注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql"><a href="#注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql" class="headerlink" title="注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql"></a><strong>注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql</strong></h3></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间问题</title>
      <link href="2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL数据库问题"><a href="#MySQL数据库问题" class="headerlink" title="MySQL数据库问题"></a>MySQL数据库问题</h3><p><strong>查询数据库时间</strong></p><ol><li>select sysdate();</li><li>select now();</li><li>select current_date;</li></ol><p><strong>连接url需指定serverTimezone</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://&#123;host&#125;:&#123;port&#125;/&#123;database&#125;?</span></span><br><span class="line"><span class="attr">useUnicode</span>=<span class="string">true&amp; //驱动程序在处理字符串时是否应使用Unicode字符编码？默认位true，设置false可能出现乱码</span></span><br><span class="line"><span class="attr">characterEncoding</span>=<span class="string">UTF-8&amp; //指定字符编码</span></span><br><span class="line"><span class="attr">serverTimezone</span>=<span class="string">Asia/Shanghai&amp; //指定时区位亚洲上海</span></span><br><span class="line"><span class="attr">useSSL</span>=<span class="string">false&amp; // 与服务器通信时使用ssl（true/false），连接到MySQL5.5.45+、5.6.26+或5.7.6+时默认为“true”，否则默认为“false”</span></span><br><span class="line"><span class="attr">allowPublicKeyRetrieval</span>=<span class="string">true //如果用户使用了 sha256_password 认证，密码在传输过程中必须使用 TLS 协议保护，但是如果 RSA 公钥不可用，可以使用服务器提供的公钥；可以在连接中通过 ServerRSAPublicKeyFile 指定服务器的 RSA 公钥，或者AllowPublicKeyRetrieval=True参数以允许客户端从服务器获取公钥；但是需要注意的是 AllowPublicKeyRetrieval=True可能会导致恶意的代理通过中间人攻击(MITM)获取到明文密码，所以默认是关闭的，必须显式开启</span></span><br></pre></td></tr></table></figure><h3 id="服务器时间"><a href="#服务器时间" class="headerlink" title="服务器时间"></a>服务器时间</h3><ul><li>进入linux：输入date查看服务器时间</li></ul><p><img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222100673.png" alt="image-20200915222100673"></p><ul><li><p>使用timedatectl命令</p><p>  timedatectl对于RHEL / CentOS 7和基于Fedora 21+的分布式系统来说，是一个新工具，它作为systemd系统和服务管理器的一部分，代替旧的传统的用在基于Linux分布式系统的sysvinit守护进程的date命令。</p><p>  <img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222429047.png" alt="显示当前系统时间"></p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">使用timedatectl命令</span></span><br><span class="line"><span class="comment"># timedatectl list-timezones |grep Shanghai    #查找上海的完整名称</span></span><br><span class="line"><span class="attr">Asia/Shanghai</span></span><br><span class="line"><span class="comment"># timedatectl set-timezone Asia/Shanghai    #其他时区以此类推</span></span><br><span class="line"><span class="attr">或者直接手动创建软链接</span></span><br><span class="line"><span class="comment"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="docker容器时间"><a href="#docker容器时间" class="headerlink" title="docker容器时间"></a>docker容器时间</h3><p>进入docker命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &#123;容器名或容器id&#125;  /bin/bash</span><br></pre></td></tr></table></figure><p>查看时间命令：date</p><p>复制相应的时区文件，替换系统时区文件；</p><p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p><p>有的容器基础镜像是有这个文件的，直接拷贝就可以，如果不能拷贝，则是因为创建镜像时依赖的基础镜像 运行的容器没有这两个文件，使用下面的办法</p><ol><li><p>创建文件夹</p><p> mkdir -p /usr/share/zoneinfo/Asia</p></li><li><p>回到宿主机，复制宿主机里的文件到容器中</p><p> docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或容器名:/usr/share/zoneinfo/Asia</p></li></ol><p>​    3.进入容器执行命令 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p><h3 id="tomcat容器时区问题"><a href="#tomcat容器时区问题" class="headerlink" title="tomcat容器时区问题"></a>tomcat容器时区问题</h3><p><strong>描述：</strong>java的war包部署在Linux上的tomcat容器中相差8小时</p><p>解决：在tomcat的bin目录下找到catalina.sh文件在JAVA_OPTS追加添加如下配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Duser.timezone</span>=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915221437392.png" alt="image-20200915221437392"></p><!--注：若是在docker中的容器可先将其拷贝出来修改后再拷贝到docker中原来对应位置--><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
