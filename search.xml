<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>时间问题</title>
    <url>/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="MySQL数据库问题"><a href="#MySQL数据库问题" class="headerlink" title="MySQL数据库问题"></a>MySQL数据库问题</h3><p><strong>查询数据库时间</strong></p>
<ol>
<li>select sysdate();</li>
<li>select now();</li>
<li>select current_date;</li>
</ol>
<p><strong>连接url需指定serverTimezone</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://&#123;host&#125;:&#123;port&#125;/&#123;database&#125;?</span></span><br><span class="line"><span class="attr">useUnicode</span>=<span class="string">true&amp; //驱动程序在处理字符串时是否应使用Unicode字符编码？默认位true，设置false可能出现乱码</span></span><br><span class="line"><span class="attr">characterEncoding</span>=<span class="string">UTF-8&amp; //指定字符编码</span></span><br><span class="line"><span class="attr">serverTimezone</span>=<span class="string">Asia/Shanghai&amp; //指定时区位亚洲上海</span></span><br><span class="line"><span class="attr">useSSL</span>=<span class="string">false&amp; // 与服务器通信时使用ssl（true/false），连接到MySQL5.5.45+、5.6.26+或5.7.6+时默认为“true”，否则默认为“false”</span></span><br><span class="line"><span class="attr">allowPublicKeyRetrieval</span>=<span class="string">true //如果用户使用了 sha256_password 认证，密码在传输过程中必须使用 TLS 协议保护，但是如果 RSA 公钥不可用，可以使用服务器提供的公钥；可以在连接中通过 ServerRSAPublicKeyFile 指定服务器的 RSA 公钥，或者AllowPublicKeyRetrieval=True参数以允许客户端从服务器获取公钥；但是需要注意的是 AllowPublicKeyRetrieval=True可能会导致恶意的代理通过中间人攻击(MITM)获取到明文密码，所以默认是关闭的，必须显式开启</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器时间"><a href="#服务器时间" class="headerlink" title="服务器时间"></a>服务器时间</h3><ul>
<li>进入linux：输入date查看服务器时间</li>
</ul>
<p><img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222100673.png" alt="image-20200915222100673"></p>
<ul>
<li><p>使用timedatectl命令</p>
<p>  timedatectl对于RHEL / CentOS 7和基于Fedora 21+的分布式系统来说，是一个新工具，它作为systemd系统和服务管理器的一部分，代替旧的传统的用在基于Linux分布式系统的sysvinit守护进程的date命令。</p>
<p>  <img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222429047.png" alt="显示当前系统时间"></p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">使用timedatectl命令</span></span><br><span class="line"><span class="comment"># timedatectl list-timezones |grep Shanghai    #查找上海的完整名称</span></span><br><span class="line"><span class="attr">Asia/Shanghai</span></span><br><span class="line"><span class="comment"># timedatectl set-timezone Asia/Shanghai    #其他时区以此类推</span></span><br><span class="line"><span class="attr">或者直接手动创建软链接</span></span><br><span class="line"><span class="comment"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="docker容器时间"><a href="#docker容器时间" class="headerlink" title="docker容器时间"></a>docker容器时间</h3><p>进入docker命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker exec -it &#123;容器名或容器id&#125;  /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看时间命令：date</p>
<p>复制相应的时区文件，替换系统时区文件；</p>
<p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<p>有的容器基础镜像是有这个文件的，直接拷贝就可以，如果不能拷贝，则是因为创建镜像时依赖的基础镜像 运行的容器没有这两个文件，使用下面的办法</p>
<ol>
<li><p>创建文件夹</p>
<p> mkdir -p /usr/share/zoneinfo/Asia</p>
</li>
<li><p>回到宿主机，复制宿主机里的文件到容器中</p>
<p> docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或容器名:/usr/share/zoneinfo/Asia</p>
</li>
</ol>
<p>​    3.进入容器执行命令 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<h3 id="tomcat容器时区问题"><a href="#tomcat容器时区问题" class="headerlink" title="tomcat容器时区问题"></a>tomcat容器时区问题</h3><p><strong>描述：</strong>java的war包部署在Linux上的tomcat容器中相差8小时</p>
<p>解决：在tomcat的bin目录下找到catalina.sh文件在JAVA_OPTS追加添加如下配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Duser.timezone</span>=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915221437392.png" alt="image-20200915221437392"></p>
<!--注：若是在docker中的容器可先将其拷贝出来修改后再拷贝到docker中原来对应位置-->

<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm对象分析与执行引擎</title>
    <url>/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ol>
<li>使用new关键字</li>
<li>Class的newInstance();</li>
<li>Constructor的newInstance();</li>
<li>使用clone();方法</li>
<li>对象反序列化</li>
</ol>
<p>注：前三个会调用构造函数，后两个不会。</p>
<h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol>
<li>判断对象对应的类是否加载、链接、初始化。</li>
<li>为对象分配内存（内存规划与并发问题）</li>
<li>初始化（所有属性设置默认值，保证对象的实例属性不赋值可直接使用）</li>
<li>设置对象头</li>
<li>执行init方法初始化</li>
<li></li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205538656.png" alt="image-20201116205538656"></p>
<p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205552066.png" alt="image-20201116205552066"></p>
<h2 id="对象的访问与定位"><a href="#对象的访问与定位" class="headerlink" title="对象的访问与定位"></a>对象的访问与定位</h2><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205753071.png" alt="image-20201116205753071"></p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205802784.png" alt="image-20201116205802784"></p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212053763.png" alt="image-20201116212053763"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>执行引擎室Java虚拟机核心的组成部分之一，“虚拟机”是一个相对于”物理机“的概念，这两钟机器都有代码执行能力，物理机执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，能够执行硬件不支持的指令集格式。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>将字节码指令解释/编译成对应平台上的本地机器指令，即将字节码指令翻译为机器指令。输入是字节码二进制流，输出的是执行结果。</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a><strong>工作过程</strong></h4><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212237168.png" alt="image-20201116212237168"></p>
<h4 id="字节码执行过程"><a href="#字节码执行过程" class="headerlink" title="字节码执行过程"></a>字节码执行过程</h4><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212749868.png" alt="image-20201116212749868"></p>
<h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><p>​    当java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容”翻译”为对应平台的本地机器码执行。</p>
<h4 id="JIT（Just-In-Time-Compiler）"><a href="#JIT（Just-In-Time-Compiler）" class="headerlink" title="JIT（Just In Time Compiler）"></a>JIT（Just In Time Compiler）</h4><p>​    即时编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<p><a href="https://www.cnblogs.com/yanl55555/p/13334713.html?utm_source=tuicool">执行引擎参考</a></p>
<p><a href="https://www.cnblogs.com/guanghe/p/11880577.html">解释器与JIT参考</a></p>
<h2 id="源代码到机器码过程的三种编译器"><a href="#源代码到机器码过程的三种编译器" class="headerlink" title="源代码到机器码过程的三种编译器"></a>源代码到机器码过程的三种编译器</h2><p><a href="https://blog.csdn.net/fuxiaoxiaoyue/article/details/93497558">参考链接</a></p>
<h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p><strong>java代码-》字节码</strong></p>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p><strong>字节码-》机器码</strong></p>
<h2 id="AOP编译器"><a href="#AOP编译器" class="headerlink" title="AOP编译器"></a>AOP编译器</h2><p><strong>java代码-》机器码</strong></p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM常用知识</title>
    <url>/2020/11/14/JVM/jvm%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">官网链接</a></p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="打开JDK自带可视化工具jvisualvm"><a href="#打开JDK自带可视化工具jvisualvm" class="headerlink" title="打开JDK自带可视化工具jvisualvm"></a>打开JDK自带可视化工具jvisualvm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1，到jdk的bin目录找到jvisualvm.exe，双击运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2，或配置了jdk环境变量后可直接命令行执行以下命令打开</span></span><br><span class="line">C:\Users\CZM&gt;jvisualvm</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="查看当前所有进程id"><a href="#查看当前所有进程id" class="headerlink" title="查看当前所有进程id"></a>查看当前所有进程id</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;jps</span><br><span class="line">12984</span><br><span class="line">10684 Jps</span><br><span class="line">48476 Launcher</span><br></pre></td></tr></table></figure>



<h3 id="查看指定参数信息"><a href="#查看指定参数信息" class="headerlink" title="查看指定参数信息"></a>查看指定参数信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -flag jvm参数 进程ip</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2020/11/30/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="判断对象存活方式"><a href="#判断对象存活方式" class="headerlink" title="判断对象存活方式"></a>判断对象存活方式</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>引用计数算法(Reference Counting) ，对每个对象保存<strong>一个整型的引用计数器属性</strong>。用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1;当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><p>实现简单，垃圾对象便于辨识;判定效率高，回收没有延迟性。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>引用计数器有- -个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，</li>
<li>导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制,以提高吞吐量的尝试。</p>
<p>Java并没有选择引用计数，是因为其存在-一个基本的难题，也就是很难处理循环引用关系。</p>
<p>引用计数算法，是很多语言的资源回收选择，如Python，同时支持引用计数和垃圾收集机制。</p>
<p>​    Python如何解决循环引用?</p>
<p>​    手动解除:很好理解，就是在合适的时机，解除引用关系。</p>
<p>​    使用弱引用weakref，weakref是Python提供的标准库， 旨在解决循环引用。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>可达性分析算法是以根对象集合(GC Roots[<strong>所谓”GC Roots”根集 合就是一组必须活跃的引用</strong>])为起始点，按照从上至下的方式搜索被根对象集合所<strong>连接的目标对象是否可达</strong>。使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链(Reference Chain)**如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
<h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>Java的GC Roots包括以几类元素:</p>
<ol>
<li>虚拟机栈中引用的对象。如:各个线程被调用的方法中使用到的参数、局部变量等。</li>
<li>本地方法栈内JNI (通常说的本地方法)引用的对象</li>
<li>方法区中类静态属性引用的对象。如: Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象。如:字符串常量池(String Table) 里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虛拟机内部的引用。</li>
<li>基本数据类型对应的Class对象，一些常驻的异常对象(如:NullPointerException、OutOfMemoryError)，系统类加载器。</li>
<li>反映java虛拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
<li>在分代收集和局部回收时，GC Roots集临时性的加入其他对象，比如针对新生代回收，老年代的对象也要纳入GC Roots集中。</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须“StopTheWorld”的一个重要原因。即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><ul>
<li><p>Java语言提供了对象终止(finalization) 机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即:垃圾回收此对象之前，总会先调用这个对象的finalize()方法。.</p>
</li>
<li><p>finalize ()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
</ul>
<h3 id="不重写finalize-方法的原因"><a href="#不重写finalize-方法的原因" class="headerlink" title="不重写finalize()方法的原因"></a>不重写finalize()方法的原因</h3><ol>
<li>在finalize()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的，它完全由Gc线程决定，极端情况下,</li>
<li>若不发生GC，则finalize ()方法将没有执行机会。</li>
<li>一个糟糕的finalize()会严重影响GC的性能。</li>
</ol>
<h3 id="虚拟机中Java对象的三种状态"><a href="#虚拟机中Java对象的三种状态" class="headerlink" title="虚拟机中Java对象的三种状态"></a>虚拟机中Java对象的三种状态</h3><ol>
<li>可触及的:从根节点开始，可以到达这个对象。</li>
<li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li>不可触及的:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及 的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ol>
<h3 id="判定一个对象是否可回收，至少要经历两次标记过程"><a href="#判定一个对象是否可回收，至少要经历两次标记过程" class="headerlink" title="判定一个对象是否可回收，至少要经历两次标记过程:"></a>判定一个对象是否可回收，至少要经历两次标记过程:</h3><ol>
<li><h4 id="如果对象到GC-Roots没有-引用链，则进行第一次标记。"><a href="#如果对象到GC-Roots没有-引用链，则进行第一次标记。" class="headerlink" title="如果对象到GC Roots没有 引用链，则进行第一次标记。"></a>如果对象到GC Roots没有 引用链，则进行第一次标记。</h4></li>
<li><h4 id="进行筛选，判断此对象是否有必要执行finalize-方法"><a href="#进行筛选，判断此对象是否有必要执行finalize-方法" class="headerlink" title="进行筛选，判断此对象是否有必要执行finalize()方法"></a>进行筛选，判断此对象是否有必要执行finalize()方法</h4><p> ① 如果对象没有 重写finalize()方法，或者finalize ()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，被判定为不可触及的。</p>
<p> ② 如果对象重写 了finalize()方法，且还未执行过，那么该对象会被插入到E-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize ()方法执行。</p>
<p> ③ finalize()方法是对象逃脱死亡的最后机会，稍后Gc会对E-Queue队列中的对象进行第二次标记。如果对象在finalize()方法中与引用链上的任何一-个对象建立了联系，那么在第二次标记时，对象会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p>
</li>
</ol>
<h1 id="垃圾清除"><a href="#垃圾清除" class="headerlink" title="垃圾清除"></a>垃圾清除</h1><h2 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记 - 清除算法( Mark-Sweep)"></a>标记 - 清除算法( Mark-Sweep)</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序(也被称为stop the world) ，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<p>标记: Collector从引用 根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p>
<p>清除:Collector对堆 内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>效率不算高。</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差。</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表。</li>
</ol>
<h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h2><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ol>
<li>没有标记和清除过程，实现简单，运行高效。</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h3><ol>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ol>
<h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的:"></a>特别的:</h3><ol>
<li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</li>
<li>即特别适合垃圾对象很多,存活对象很少的场景;例如:Young区的Survivor0和Survivor1区</li>
</ol>
<h2 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记 - 压缩算法(Mark-Compact )"></a>标记 - 压缩算法(Mark-Compact )</h2><p>第一阶段和标记清除算法- -样，从根节点开始标记所有被引用对象,第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。<br>之后，清理边界外所有的空间。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h3><ol>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只 需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ol>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><ol>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>
<li>移动过程中，需要全程暂停用户应用程序。即: STW。</li>
</ol>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。目前几乎所有的GC都是采用分代收集(Generational Collecting) 算法执行垃圾回收的。</p>
<h3 id="年轻代-Young-Gen"><a href="#年轻代-Young-Gen" class="headerlink" title="年轻代(Young Gen)"></a>年轻代(Young Gen)</h3><p>算法：复制算法。</p>
<p>特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>速度最快。效率只和当前存活对象大小有关，而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<h3 id="老年代-Tenured-Gen"><a href="#老年代-Tenured-Gen" class="headerlink" title="老年代(Tenured Gen)"></a>老年代(Tenured Gen)</h3><p>算法：一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<p>特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</p>
<h4 id="各阶段开销"><a href="#各阶段开销" class="headerlink" title="各阶段开销"></a>各阶段开销</h4><p>Mark（标记）阶段的开销与存活对象的数量成正比。</p>
<p>Sweep（清除）阶段的开销与所管理区域的大小成正相关。</p>
<p>Compact（压缩/整理）阶段的开销与存活对象的数据成正比。</p>
<h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。降低系统停顿时间，但线程切换和上下文转换消耗，导致垃圾回收成本增加。总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>为了更好地控制GC产生的停顿时间，将一块大的内存区 域分割成多个小块，根据目标的停顿时间，每次合理地回收若千个小区间，而不是整个堆空间，从而减少一 次GC所产生的停顿。分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成<br>连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器（Garbage Collector）</title>
    <url>/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="查看默认的垃圾收集器"><a href="#查看默认的垃圾收集器" class="headerlink" title="查看默认的垃圾收集器"></a>查看默认的垃圾收集器</h2><ol>
<li>运行时带上JVM参数-Xx: +PrintCommandLineFlags:查看命令行相关参数(包含使用的垃圾收集器) 。</li>
<li>使用命令行指令: jinfo -flag相关垃圾回收器参数进程ID。</li>
</ol>
<h2 id="GC的性能指标"><a href="#GC的性能指标" class="headerlink" title="GC的性能指标"></a>GC的性能指标</h2><ul>
<li><strong>吞吐量</strong>: 运行用户代码的时间占总运行时间的比例(总运行时间:程序的运行时间+内存回收的时间)。</li>
<li><strong>垃圾收集开销</strong>: 吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>: 执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li><strong>收集频率</strong>: 相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用</strong>:  Java堆区所占的内存大小。</li>
<li><strong>快速</strong>: 一个对象从诞生到被回收所经历的时间。</li>
</ul>
<h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201202233303029.png" alt="image-20201202233303029"></p>
<ul>
<li>红色虚线：在JDK 8时将Serial+CMS、ParNew+Serial Oldd这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了<br>  这些组合的支持(JEP214)。</li>
<li>绿色虚线：在jdk14中弃用Paral1el Scavenge 和Serial0ld GC组合(JEP366)</li>
<li>青色虚线：在jdk14中:删除CMS垃圾回收器(JEP 363)</li>
</ul>
<h2 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>第一款GC，1999年随jdk1.3发布，<strong>负责回收年轻代</strong>。HotSpot中Client模式下的默认新生代垃圾收集器。<strong>采用复制算法</strong>、在HotSpot虚拟机中，使用-XX:+UseSerialGC 指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC， 且老年代用Serial Old GC。</p>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p><strong>负责回收老年代</strong>，内存回收算法使用的是<strong>标记-压缩算法</strong>。是运行在Client模式下默认的老年代的垃圾回收器。在Server模式下主要有两个用途: 与新生代的Parallel Scavenge配合使用或作为老年代CMS收集器的后备垃圾收集方案。</p>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>串行回收器意味着使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束(Stop The World)。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>简单而高效</strong>(与其他收集器的单线程比)，<strong>单CPU</strong>的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。一般用于用户的桌面应用等资源有限环境。</p>
<h2 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h2><h2 id="ParNew（Parallel-New）"><a href="#ParNew（Parallel-New）" class="headerlink" title="ParNew（Parallel New）"></a>ParNew（Parallel New）</h2><p><strong>负责回收年轻代</strong>，相当于Serial的多线程版，在多CPU的环境下，充分利用多CPU、多核心等物理硬件资源优势。采用<strong>复制算法</strong>。ParNew是很多JVM运行在<strong>Server模式下新生代的默认垃圾收集器。</strong></p>
<h3 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h3><p>在单个CPU的环境下，ParNew收集 器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的-一些额外开销。除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</p>
<p>-XX: +UseParNewGC 指定ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p>-XX:ParallelGCThreads 指定线程数量，默认开启和CPU数据相同的线程数。</p>
<h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>jdk1.6后默认使用，<strong>负责回收年轻代</strong>。采用了复制算法、并行回收。和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，它也被称为<strong>吞吐量优先</strong>（高吞吐量可以充分利用CPU）的垃圾收集器。自适应调节策略也是Parallel Scavenge 与ParNew一个重要区别。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置:"></a>参数配置:</h3><p>-XX: +UseParallelGC  指定年轻代使用Parallel。</p>
<p>-XX:+UseParallel0ldGC 指定老年代都是使用并行回收收集器。</p>
<p>分别适用于新生代和老年代。默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。(互相激活)。</p>
<p>-XX: ParallelGCThreads设置年轻代并行收集器的线程数。一般地与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p>在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量。当CPU数量大于8个， ParallelGCThreads的值等于3+ [5*CPU_ Count]/8]。</p>
<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</p>
<p>-XX: GCTimeRatio 垃圾收集时间占总时间的比例( 1 / (N+ 1))。用于衡量吞吐量的大小。取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。与前一个-XX:MaxGCPauseMillis参数有一 定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>
<p>-XX: +UseAdaptiveSizePolicy ,设置Parallel Scavenge收集器具有自适应调节策略<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、 晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿<br>时间之间的平衡点。</p>
<h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p><strong>负责回收老年代</strong>，用来代替老年代的Serial 0ld收集器。采用了标记-压缩算法，基于并行回收和”Stop- the-World”机制。</p>
<h3 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h3><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld 收集器的组合，在Server模式下的内存回收性能很不错。在jdk8中，默认是此垃圾收集器。</p>
<h2 id="并发回收器"><a href="#并发回收器" class="headerlink" title="并发回收器"></a>并发回收器</h2><h3 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h3><p><strong>负责回收老年代</strong>，jdk1.5推出，采用<strong>标记-清除算法</strong>，并且也会”Stop- the-world”。是HotSpot虚拟机中<strong>第一 款</strong>真正意义上的<strong>并发收集器</strong>，它第一次实现了让<strong>垃圾收集线程与用户线程同时工作</strong>（<strong>低延迟</strong>）。缩短垃圾收集时间、用户线程的停顿时。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203152900355.png" alt="image-20201203152900355"></p>
<h4 id="初始标记阶段-Initial-Mark"><a href="#初始标记阶段-Initial-Mark" class="headerlink" title="初始标记阶段(Initial-Mark)"></a>初始标记阶段(Initial-Mark)</h4><p>会出现“Stop- the-World”，只标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
<h4 id="并发标记阶段-Concurrent-Mark"><a href="#并发标记阶段-Concurrent-Mark" class="headerlink" title="并发标记阶段(Concurrent-Mark)"></a>并发标记阶段(Concurrent-Mark)</h4><p>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
<h4 id="重新标记阶段-Remark"><a href="#重新标记阶段-Remark" class="headerlink" title="重新标记阶段(Remark)"></a>重新标记阶段(Remark)</h4><p>在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导<br>致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
<h4 id="并发清除阶段-Concurrent-Sweep"><a href="#并发清除阶段-Concurrent-Sweep" class="headerlink" title="并发清除阶段(Concurrent -Sweep)"></a>并发清除阶段(Concurrent -Sweep)</h4><p>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。</p>
<h3 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h3><p>CMS无法与JDK 1.4 中已经存在的新生代收集器Paral1el Scavenge配合工作，所以在jdk1. 5中使用时，新生代只能选择ParNew或者Serial收集器中的一个。</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>jdk9默认使用，<strong>年轻代和老年代都有涉及</strong></p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见指令笔记</title>
    <url>/2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>查看Linux内存CPU使用情况</p>
<img src="/2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/image-20201201160508354.png" alt="image-20201201160508354">

<h4 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h4><p>当前时间16：04：49</p>
<p>系统已运行时间 188天4小时32分</p>
<p>当前登陆用户数 1个user</p>
<p>负载情况 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<h4 id="第二行："><a href="#第二行：" class="headerlink" title="第二行："></a>第二行：</h4><p>  Tasks（ 任务/进程）100个进程，其中处于运行中的有1个，99个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<h4 id="第三行：cpu状态"><a href="#第三行：cpu状态" class="headerlink" title="第三行：cpu状态"></a>第三行：cpu状态</h4><p> us — 用户空间占用CPU的百分比。</p>
<p> sy — 内核空间占用CPU的百分比。</p>
<p> ni — 改变过优先级的进程占用CPU的百分比。</p>
<p> id — 空闲CPU百分比。</p>
<p> wa — IO等待占用CPU的百分比。</p>
<p> hi — 硬中断（Hardware IRQ）占用CPU的百分比。</p>
<p> si — 软中断（Software Interrupts）占用CPU的百分比 。</p>
<h4 id="第四行：内存状态"><a href="#第四行：内存状态" class="headerlink" title="第四行：内存状态"></a>第四行：内存状态</h4><p> total — 物理内存总量。</p>
<p> used — 使用中的内存总量。</p>
<p> free — 空闲内存总量。</p>
<p> buffers — 缓存的内存量 。</p>
<h4 id="第五行：swap交换分区"><a href="#第五行：swap交换分区" class="headerlink" title="第五行：swap交换分区"></a>第五行：swap交换分区</h4><p>total — 交换区总量。</p>
<p>used — 使用的交换区总量。</p>
<p>free — 空闲交换区总量。</p>
<p>cached — 缓冲的交换区总量。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>PID — 进程id。</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值。负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p> S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程。</p>
<p>%CPU — 上次更新到现在的CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><ul>
<li>b: 打开/关闭高亮效果</li>
<li>x:打开/关闭排序列高亮效果</li>
<li>shift + ‘&lt;’  或  ‘&gt;’ 向左向右改变排序列</li>
</ul>
<h2 id="free-h"><a href="#free-h" class="headerlink" title="free -h"></a>free -h</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>查看内存使用使用情况</p>
<p><img src="/2020/12/01/Linux/Linux%E6%8C%87%E4%BB%A4/image-20201201170143345.png" alt="image-20201201170143345"></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="find-目录-条件-动作"><a href="#find-目录-条件-动作" class="headerlink" title="find [目录] [条件] [动作]"></a>find [目录] [条件] [动作]</h3><p>如 find . -name ‘name*’ 查找当前目录下以name开头的文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment"># find . -name &quot;name*&quot;</span></span><br><span class="line">./node_modules/continuation-local-storage/<span class="built_in">test</span>/namespaces.tap.js</span><br><span class="line">./node_modules/argparse/lib/namespace.js</span><br><span class="line">./node_modules/ast-types/gen/namedTypes.js</span><br><span class="line">./node_modules/ast-types/gen/namedTypes.d.ts</span><br><span class="line">./node_modules/@pm2/js-api/src/namespace.js</span><br></pre></td></tr></table></figure>



<h3 id="whitch"><a href="#whitch" class="headerlink" title="whitch"></a>whitch</h3><p>在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@~]<span class="comment"># which ps</span></span><br><span class="line">/usr/bin/ps</span><br></pre></td></tr></table></figure>



<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment"># whereis npm</span></span><br><span class="line">npm: /usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># whereis java</span></span><br><span class="line">java: /usr/java/jdk1.8.0_221/bin/java /usr/java/jdk1.8.0_221/jre/bin/java</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># whereis nodejs</span></span><br><span class="line">nodejs: /usr/<span class="built_in">local</span>/nodejs</span><br></pre></td></tr></table></figure>



<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment">#  type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">[root@iZwz9 ~]<span class="comment">#  type npm</span></span><br><span class="line">npm is /usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment">#  type -p npm</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事务与配置</title>
    <url>/2020/09/24/Redis/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="通常情况下的事务"><a href="#通常情况下的事务" class="headerlink" title="通常情况下的事务"></a>通常情况下的事务</h3><h4 id="事务的基本要素即四大特性（ACID）"><a href="#事务的基本要素即四大特性（ACID）" class="headerlink" title="事务的基本要素即四大特性（ACID）"></a>事务的基本要素即四大特性（ACID）</h4><ul>
<li><p>原子性（Atomicity）：事务所有操作指令，要么全部完成，要么全部不做。</p>
</li>
<li><p>一致性（Consistency）：事务提交后，数据库从一个一致性状态变到另一个一致性状态。</p>
<p>  如事务（a-100，b+100）执行后a减100，b一定加100，不然a，b就都不变</p>
</li>
<li><p>隔离性（Isolation）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。</p>
</li>
<li><p>持久性（Durability）：事务一旦提交后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
</li>
</ul>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>​     本质：一组指令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li><p><strong>Redis事务没有隔离级别的概念！</strong></p>
<p> 一个事务的所有指令并没有被直接执行，而是存入队列中，只有发起执行命令（Exec）的时候才会顺序执行！</p>
</li>
<li><p><strong>Redis单条命令保证原子性，但是事务不保证原子性！</strong></p>
</li>
<li><p><strong>单独的隔离操作</strong></p>
<p> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
</ol>
<h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol>
<li>开启事务：multi</li>
<li>输入命令入队列：set key value  ……</li>
<li>提交事务：exec  或 撤销事务：discard</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><p>​        命令有问题，事务所有的命令都不会被执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2  <span class="comment">#错误命令</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">EXECABORT Transaction discarded because of previous errors.  <span class="comment">#执行事务报错</span></span><br><span class="line">&gt; get key2  </span><br><span class="line">null</span><br><span class="line">&gt; get key1 <span class="comment">#所有命令都不会被执行</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>​    如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的（Redis事务不保证原子性）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k1 abc</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k1  <span class="comment">#k1为字符串，无法加1</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range  <span class="comment"># incr k1执行报错</span></span><br><span class="line">4) <span class="string">&quot;abc&quot;</span></span><br><span class="line">5) <span class="string">&quot;3&quot;</span></span><br><span class="line">&gt; get k2  <span class="comment">#其他命令正常执行</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="监控watch"><a href="#监控watch" class="headerlink" title="监控watch"></a>监控watch</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​    很悲观，总是认为最坏情况，拿数据的时候数据都会被别人修改，无论什么时候都加锁，效率低下</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​    很乐观，总是认为最好情况，拿数据的时候数据都不会被别人修改，所以不加锁，在更新数据的时候先判断下，拿数据这期间有没有人修改过此数据（mysql中可增加一版本字段version，更新前比较此字段）</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi   </span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#事务正常结束，数据期间没有发生变动，这时候事务正常执行</span></span><br><span class="line">80</span><br><span class="line">20</span><br><span class="line">&gt; get money</span><br><span class="line">80</span><br></pre></td></tr></table></figure>

<p>使用多客户端即多线程修改值，使用watch可以当作Redis的乐观锁操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#执行之前，其他客户端执行 set money 10</span></span><br><span class="line">null  <span class="comment">#对比watch监控的money，发生变化，修改失败</span></span><br><span class="line"></span><br><span class="line">&gt; unwatch  <span class="comment">#执行失败，就先解锁</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money <span class="comment">#获取最新值，再次监控（此时money=10，usedMoney=0）</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">&gt; get money</span><br><span class="line">5</span><br><span class="line">&gt; get usedMoney</span><br><span class="line">5</span><br></pre></td></tr></table></figure>



<h2 id="配置文件Redis-conf"><a href="#配置文件Redis-conf" class="headerlink" title="配置文件Redis.conf"></a>配置文件Redis.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unit(单位)</span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line">只支持bytes，不支持bit，对大小写不敏感</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INCLUDES模块</span><br><span class="line"><span class="comment"># include .\path\to\local.conf</span></span><br><span class="line"><span class="comment"># include c:\path\to\other.conf</span></span><br><span class="line">可通过include 包含其他文件</span><br><span class="line"></span><br><span class="line">网络</span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment">#绑定ip</span></span><br><span class="line">port 6379	<span class="comment">#端口</span></span><br><span class="line">protected-mode yes <span class="comment">#保护模式，默认开启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GENERAL通用配置模块</span><br><span class="line">daemonize yes <span class="comment">#以守护进程执行（后台与运行）</span></span><br><span class="line">pidfile /var/run/redis.pid <span class="comment">#如果以守护进程方式运行，需指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice <span class="comment">#日志级别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment">#日志文件位置</span></span><br><span class="line">databases 16 <span class="comment">#数据库数量</span></span><br><span class="line"></span><br><span class="line">Tcp-keepalive <span class="comment">#连接检测，单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </span></span><br><span class="line">tcp-backlog</span><br><span class="line"><span class="comment">#设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境</span></span><br><span class="line"><span class="comment">#下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以</span></span><br><span class="line"><span class="comment">#需要确认增大somaxconntcp_max_syn_backlog两个值来达到想要的效果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SNAPSHOTTING快照模块</span><br><span class="line"><span class="comment">#达到已下条件，就进行保存</span></span><br><span class="line">save 900 1 <span class="comment">#15分钟内改了1次。</span></span><br><span class="line">save 300 10 <span class="comment">#5分钟内改了10次，</span></span><br><span class="line">save 60 10000 <span class="comment">#1分钟内改了1万次，</span></span><br><span class="line"><span class="comment">#如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#持久化操作出错，是否继续工作</span></span><br><span class="line">rdbcompression yes  <span class="comment">#对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes <span class="comment">#存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</span></span><br><span class="line">dir ./ <span class="comment">#db文件的保存路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECURITY安全模块</span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass <span class="string">&quot;&quot;</span>  <span class="comment">#配置redis密码，默认空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LIMITS限制模块</span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"><span class="comment">#设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment">#设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</span></span><br><span class="line"><span class="comment">#如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信</span></span><br><span class="line"><span class="comment">#息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从#redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，</span></span><br><span class="line"><span class="comment">#才不用考虑这个因素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction  <span class="comment">#内存达到上限后处理策略</span></span><br><span class="line"><span class="comment">#（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（2）allkeys-lru：使用LRU算法移除key</span></span><br><span class="line"><span class="comment">#（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（4）allkeys-random：移除随机的key</span></span><br><span class="line"><span class="comment">#（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</span></span><br><span class="line"><span class="comment">#（6）noeviction：不进行移除。针对写操作，只是返回错误信息</span></span><br><span class="line"></span><br><span class="line">maxmemory-samples 5 <span class="comment">#设置检查的样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，</span></span><br><span class="line"><span class="comment">#redis默认会检查这么多个key并选择其中LRU的那个，LRU和最小TTL算法不是精确算法而是近似算法，该值越大越精准，但cpu成本高，</span></span><br><span class="line"><span class="comment">#3较快，默认5，10非常接近</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APPEND ONLY MODE附加模块</span><br><span class="line">appendonly no <span class="comment">#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时</span></span><br><span class="line"><span class="comment">#导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</span></span><br><span class="line"><span class="comment">#默认为no</span></span><br><span class="line">appendfsync everysec  <span class="comment">#指定更新日志条件，共有3个可选值： </span></span><br><span class="line"><span class="comment">#  no：表示等操作系统进行数据缓存同步到磁盘（快） </span></span><br><span class="line"><span class="comment">#  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span></span><br><span class="line"><span class="comment">#  everysec：表示每秒同步一次（折衷，默认值）</span></span><br><span class="line"></span><br><span class="line">appendfilename appendonly.aof <span class="comment">#指定更新日志文件名，默认为appendonly.aof</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">No-appendfsync-on-rewrite no <span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</span></span><br><span class="line"></span><br><span class="line">Auto-aof-rewrite-min-size 64mb <span class="comment">#设置重写的基准值 大小</span></span><br><span class="line">Auto-aof-rewrite-percentage  100 <span class="comment"># 设置重写的基准值 百分比</span></span><br><span class="line"></span><br><span class="line">vm-enabled no <span class="comment">#指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷</span></span><br><span class="line"><span class="comment">#数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span><br><span class="line">   </span><br><span class="line">vm-swap-file /tmp/redis.swap <span class="comment"># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span><br><span class="line">   </span><br><span class="line">vm-max-memory 0 <span class="comment">#将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span></span><br><span class="line">   </span><br><span class="line">vm-page-size 32 <span class="comment"># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，</span></span><br><span class="line"><span class="comment">#vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很</span></span><br><span class="line"><span class="comment">#大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span></span><br><span class="line">   </span><br><span class="line">vm-pages 134217728 <span class="comment"># 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘</span></span><br><span class="line"><span class="comment">#上每8个pages将消耗1byte的内存。</span></span><br><span class="line">   </span><br><span class="line">vm-max-threads 4 <span class="comment"># 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，</span></span><br><span class="line"><span class="comment">#可能会造成比较长时间的延迟。默认值为4</span></span><br><span class="line">   </span><br><span class="line">glueoutputbuf yes <span class="comment"># 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之java简单使用</title>
    <url>/2020/09/25/Redis/Redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​    Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉 </p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h5 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="代码示例（与命令行操作基本一致）"><a href="#代码示例（与命令行操作基本一致）" class="headerlink" title="代码示例（与命令行操作基本一致）"></a>代码示例（与命令行操作基本一致）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"> <span class="comment">//验证密码，如果没有设置密码这段代码省略</span></span><br><span class="line">jedis.auth(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.print(<span class="string">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line">System.out.println(<span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());</span><br><span class="line">System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());</span><br><span class="line">System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());</span><br><span class="line">System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());</span><br><span class="line">System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span>+jedis.mset(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;key04&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="comment">//添加名称为hash（key）的hash元素</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;hash&quot;</span>,map);</span><br><span class="line"><span class="comment">//向名称为hash的hash中添加key为key5，value为value5元素</span></span><br><span class="line">jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Map&lt;String,String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span>+jedis.hkeys(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span>+jedis.hvals(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return List&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">6</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span>+jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span>+jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;key4&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//……其他类型操作类似，可参考redis命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis事务</span></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">String result = jsonObject.toJSONString();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result);</span><br><span class="line">    <span class="comment">//再存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result);</span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果出现异常，回滚</span></span><br><span class="line">    multi.discard();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>));</span><br><span class="line">    <span class="comment">//最终关闭客户端</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis与SpringBoot整合"><a href="#Redis与SpringBoot整合" class="headerlink" title="Redis与SpringBoot整合"></a>Redis与SpringBoot整合</h2><h3 id="maven依赖-1"><a href="#maven依赖-1" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#数据库索引，默认0</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">      <span class="attr">jedis:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池最大连接数 </span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment">#连接池最大阻塞连接时间，负值表示无限制</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">5</span> <span class="comment">#连接池中最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池最小空闲连接</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">shutdown-timeout:</span> <span class="string">100ms</span> <span class="comment">#关闭超时时间，默认100ms</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义Redistemplate模板"><a href="#自定义Redistemplate模板" class="headerlink" title="自定义Redistemplate模板"></a>自定义Redistemplate模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(factory);</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> 							</span><br><span class="line">          													Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      <span class="comment">//解决缓存转换异常的问题</span></span><br><span class="line">      ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//设置所有访问权限以及所有的实际类型都可序列化和反序列化</span></span><br><span class="line">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">       <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的 </span></span><br><span class="line">      om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">      </span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">      template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//必须执行这个函数,初始化RedisTemplate</span></span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级</title>
    <url>/2020/09/27/Redis/Redis%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="为什么持久化"><a href="#为什么持久化" class="headerlink" title="为什么持久化"></a>为什么持久化</h3><p>​    Redis是内存数据库，数据都保存在内存中，因此数据读取速度快，效率高，但也容易发生丢失（如Redis宕机，突然断电等）。所以必须要有持久化的机制保存数据到硬盘，防止数据丢失。</p>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        RDB(默认的持久化方式)指在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb,它恢复时是将快照文件直接读到内存里。</p>
<h4 id="持久化过程"><a href="#持久化过程" class="headerlink" title="持久化过程"></a>持久化过程</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<h4 id="触发RDB快照条件"><a href="#触发RDB快照条件" class="headerlink" title="触发RDB快照条件"></a>触发RDB快照条件</h4><ol>
<li>配置文件save配置</li>
<li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li>
<li>执行命令save或者bgsave</li>
</ol>
<p>注：save：save时只管保存，其它不管，全部阻塞</p>
<p>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave命令获取最后一次成功执行快照的时间。</p>
<h4 id="停用"><a href="#停用" class="headerlink" title="停用"></a>停用</h4><ol>
<li>动态所有停止RDB保存规则的方法：redis-cli config set save “”</li>
<li>修改配置文件save “”</li>
</ol>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ol>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ol>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF默认存储文件名appendonly.aof</p>
<h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>修改配置appendonly no改为yes</p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>修复受损appendonly.aof文件命令： Redis-check-aof –fix  appendonly.aof</p>
<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p>
<h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ol>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol>
<li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no   从不同步，性能最好</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
</ol>
<h4 id="同时开启两种持久化方式"><a href="#同时开启两种持久化方式" class="headerlink" title="同时开启两种持久化方式"></a>同时开启两种持久化方式</h4><ol>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ol>
<h4 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h4><ol>
<li> 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li>
<li>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</li>
</ol>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​    进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。复杂情况下可使用专门的消息中间件，如RabbitMQ。</p>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>PSUBSCRIBE pattern [pattern …]     订阅一个或多个符合给定模式的频道。<br>PUBSUB subcommand [argument [argument …]]      查看订阅与发布系统状态。<br>PUBLISH channel message     将信息发送到指定的频道。<br>PUNSUBSCRIBE [pattern [pattern …]]     退订所有给定模式的频道。<br>SUBSCRIBE channel [channel …]     订阅给定的一个或多个频道的信息。<br>UNSUBSCRIBE [channel [channel …]]    指退订给定的频道。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#窗口1</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel  <span class="comment">#订阅channel频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line"><span class="comment">#当下面发布消息到此频道时，显示下面信息</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1 <span class="comment">#数量 </span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span> <span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span> <span class="comment">#消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与上面同一时刻的另一个客户端窗口2</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#窗口3</span></span><br><span class="line"><span class="comment">#将信息发送到指定的频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH channel <span class="string">&quot;hello word&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 <span class="comment">#推送给两个订阅者</span></span><br><span class="line"><span class="comment">#获取当前系统所有频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">&quot;channel2&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主，实现读写分离，Slave无法写入数据</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Info replication <span class="comment">#查看</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment">#角色</span></span><br><span class="line">connected_slaves:0 <span class="comment">#从机数</span></span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>拷贝多个redis.conf文件</li>
<li>开启daemonize yes</li>
<li>修改port，pidfile，logfile，dbfilename</li>
<li>执行指令：redis-server 配置文件路径</li>
<li>在从机上运行SLAVEOF masterip  端口</li>
</ol>
<h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><h4 id="一主多仆："><a href="#一主多仆：" class="headerlink" title="一主多仆："></a>一主多仆：</h4><p>​        一个master多个slaver</p>
<h4 id="薪火相传："><a href="#薪火相传：" class="headerlink" title="薪火相传："></a>薪火相传：</h4><ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的。</li>
<li>Slaveof 新主库IP 新主库端口</li>
</ul>
<h4 id="反客为主："><a href="#反客为主：" class="headerlink" title="反客为主："></a>反客为主：</h4><p>​        执行指令SLAVEOF no one，使当前数据库停止与其他数据库的同步，转成主数据库</p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="哨兵模式-sentinel-（实际开发中常用）"><a href="#哨兵模式-sentinel-（实际开发中常用）" class="headerlink" title="哨兵模式(sentinel)（实际开发中常用）"></a>哨兵模式(sentinel)（实际开发中常用）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ol>
<li>新建sentinel.conf文件</li>
<li>写入基本配置：sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 （最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机）</li>
<li>在Redis根目录下执行命令启动哨兵：Redis-sentinel  sentinel.conf 文件路径</li>
</ol>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot全局异常处理</title>
    <url>/2020/10/27/Springboot/springboot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>​    @ControllerAdvice注解是Spring3.2中新增的注解，只能用于类上，与下面三个方法注解结合可进行一些全局操作。</p>
<h3 id="方法注解"><a href="#方法注解" class="headerlink" title="方法注解"></a>方法注解</h3><h3 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a>@InitBinder</h3><p>用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Date类型参数转换器的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalInitBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>表示其注解的方法将会在目标Controller方法执行之前执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute(value = &quot;key&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">globalModelAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加了全局属性。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;key_value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">list</span><span class="params">(<span class="meta">@ModelAttribute(&quot;key&quot;)</span> String key)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台打印：</p>
<p>​    添加了全局属性。</p>
<p>​    key: key_value</p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>用于捕获Controller中抛出的指定类型的异常</p>
<p>​    返回自定义实体 统一格式，特别是前后端分离自定义消息格式（记得加@ResponseBody）。</p>
<p>​    返回 ModelAndView 跳转到指定页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.czm.constants.ResultCodeEnum;</span><br><span class="line"><span class="keyword">import</span> com.czm.dto.ResultDto;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.NoHandlerFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">//返回ResultDto消息实体的json对象</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;未知错误：&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName() ,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.ERROR.getCode(), 		</span><br><span class="line">                                           ResultCodeEnum.ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MissingServletRequestParameterException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">ParameterExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        								MissingServletRequestParameterException exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误请求：&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName() ,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.BAG_REQUEST.getCode(), </span><br><span class="line">                                           ResultCodeEnum.BAG_REQUEST.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">NotFountHandler</span><span class="params">(NoHandlerFoundException exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;404错误:&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName(), exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.NOT_FOUND.getCode(), </span><br><span class="line">                                           ResultCodeEnum.NOT_FOUND.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置-否则拦截不到"><a href="#注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置-否则拦截不到" class="headerlink" title="注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置,否则拦截不到"></a>注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置,否则拦截不到</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#出现错误时, 直接抛出异常</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">   <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#不要为我们工程中的资源文件建立映射</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">   <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><a href="https://redis.io/">官网</a></p>
<p><a href="http://www.redis.cn/">中文文档</a></p>
<p><a href="https://github.com/redis/">git地址</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。（百度百科）</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</li>
<li>redis默认16个数据库，类似数组下表从零开始，默认数据库为0，可以使用SELECT  id 命令切换指定数据库。</li>
<li>Redis索引都是从零开始</li>
<li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li>
<li>redis6.0前是单线程的，6.0后支持多线程，默认单线程</li>
</ul>
<h4 id="redis使用单线程原因"><a href="#redis使用单线程原因" class="headerlink" title="redis使用单线程原因"></a>redis使用单线程原因</h4><ol>
<li>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
</ol>
<!--注：Redis进行持久化的时候会以子进程或者子线程的方式执行-->

<h4 id="Redis的高并发和快速原因"><a href="#Redis的高并发和快速原因" class="headerlink" title="Redis的高并发和快速原因"></a><strong>Redis的高并发和快速原因</strong></h4><ol>
<li>redis是基于内存的，内存的读写速度比硬盘快得多；（CPU高速缓存&gt;内存&gt;外存（硬盘、光盘、U盘等））</li>
<li>redis是单线程的，省去了很多CPU上下文切换线程的时间；(CPU上下文切换是很耗内存的)</li>
<li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll（Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。）和自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。“多路”指的是多个socket连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>keys * ：查看所有key（*匹配所有字符，？匹配单个字符,如 keys  ?ist可匹配 list，aist，bist……）</li>
<li>set key value：存入键值对</li>
<li>get key：获取key对应值</li>
<li>DBSIZE：查看当前基本数据库大小（当前数据库的key的数量）。</li>
<li>Flushdb：清空当前库 | Flushall：通杀全部库</li>
<li>exists key : 判断key是否存在（存在返回1，不存在返回2）</li>
<li>del key：删除key</li>
<li>rename key newname：重命名key</li>
<li>move key  db_id  ：将当前数据库的 key 移动到给定的数据库 db 当中。</li>
<li>type key ：查看当前key存储类型</li>
<li>expire key second(秒) 设置超时时间（即几秒后过期）</li>
<li>ttl key 查看key剩余时间（-1表示永久有效，-2表示当前key不存在）</li>
<li>shutdown：关闭redis</li>
</ul>
<h3 id="设置修改密码"><a href="#设置修改密码" class="headerlink" title="设置修改密码"></a>设置修改密码</h3><h4 id="1-客户端连接修改"><a href="#1-客户端连接修改" class="headerlink" title="1.客户端连接修改"></a>1.<strong>客户端连接修改</strong></h4><!--立即生效，具有临时性，重启失效-->

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##到安装目录下打开命令行</span></span><br><span class="line"><span class="comment">#wingdow下客户端连接 redis-cli.exe -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"><span class="comment">#Linux下客户端连接 ./redis-cli -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##查看密码（默认为空）</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;&quot;  //默认空</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码 config set requirepass 123456</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; config set requirepass 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass //密码设置后必须先验证通过密码，否则所有命令都不可用</span></span><br><span class="line"><span class="meta">(error)</span> <span class="string">NOAUTH Authentication required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证密码 auth &#123;密码&#125;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; auth 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.<strong>修改配置文件</strong></h4><!-- 永久生效-->

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到redis.conf配置文件中的requirepass</span></span><br><span class="line"><span class="comment">#requirepass foobared</span></span><br><span class="line"><span class="comment">#去掉注释配置自己密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">&#123;密码&#125;</span></span><br><span class="line"><span class="attr">保存后重启</span></span><br></pre></td></tr></table></figure>



<h3 id="五大基本类型"><a href="#五大基本类型" class="headerlink" title="五大基本类型"></a>五大基本类型</h3><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><p>​        String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h5 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h5><ol>
<li><p>append key value ：往字符串后面追加字符串（若key不存在，则新建key，相当于set key value）</p>
</li>
<li><p>strlen key ：返回字符串长度</p>
</li>
<li><p>incr key： 自增1</p>
</li>
<li><p>decr key：自减1</p>
</li>
<li><p>incrby key num：自增num</p>
</li>
<li><p>decrby key num：自减num</p>
</li>
<li><p>getrange key start end ：截取字符串[start,end] [0,-1]表示全部</p>
</li>
<li><p>setrange key start str ：用str替换指定位置开始的字符串</p>
</li>
<li><p>setex  key seconds value：保存key-value并设置过期时间（set with expire）</p>
</li>
<li><p>setnx key value：不存在则设置（set if not exist），成功返回1，若已存在，则创建失败，返回-1</p>
</li>
<li><p>mset  k1 v1 k2 v2 k3 v3：同时设置多个值</p>
</li>
<li><p>mget  k1 k2 k3： 同时获取多个值</p>
</li>
<li><p>getset key value：先get后set，如果不存在则返回null，如果存在，则返回旧值，再设置新值</p>
</li>
</ol>
<h4 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h4><p>​        列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表。</p>
<h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li><p>LPUSH list value1  value2 value3 …… ：将一个或多个值插入列表头部（左部）</p>
</li>
<li><p>LRANGE  list start end ：[start,end]通过区间获取列表具体值,[0,-1]获取list全部</p>
</li>
<li><p>RPUSH list  value1  value2 value3 …… ：将一个或多个值插入列表尾部（右部）</p>
</li>
<li><p>LPOP list ：移除列表的第一个元素</p>
</li>
<li><p>RPOP list：移除列表的最后一个值</p>
</li>
<li><p>Lindex list  index ：通过下标获取 元素</p>
</li>
<li><p>Llen list：返回列表长度</p>
</li>
<li><p>Lrem lsit  count value：移除list中count个value</p>
</li>
<li><p>ltrim list start end：通过下标截取list，原list已经被改变</p>
</li>
<li><p>rpoplpush sourceList newList：移除sourceList列表的最后一个元素，将他移动到newList列表中</p>
</li>
<li><p>lset list index newvalue： 替换将列表指定下标值（list或index不存在则报错）</p>
</li>
<li><p>linsert list value before|after newValue：将某一个具体的newValue插入到第一个value前面|后面</p>
</li>
</ol>
<h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><p>Set是string类型的无序集合，不可重复。它是通过HashTable实现实现的。</p>
<h5 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li>sadd set value1 value2 value3 ……：往set集合添加元素</li>
<li>smembers set：查看set元素</li>
<li>sismembers set  value：是否存在指定元素（存在返回1，不存在返回0）</li>
<li>scard set：查看set集合元素数</li>
<li>srem set value ：移除set集合指定元素</li>
<li>srandmember set （count）：随机抽取num个元素（count不写默认一个）</li>
<li>spop  set （count）：随机移除count个元素</li>
<li>smove  set1 set2 value：将set1中value移动到set2中</li>
<li>sdiff set1 set2：set1与set2取差集，返回set1中存在，set2不存在的元素集合</li>
<li>sinter set1 set2 ：取交集</li>
<li>sunion set1 set2：取并集</li>
</ol>
<h4 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h4><p>hash 是一个键值对集合,是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;。</p>
<h5 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li>hset hash key value ：存入hash一个 key-value键值对</li>
<li>hget  hash key：获取hash中key的值</li>
<li>hmset hash key1 value1 key2 value2 ……：存入hash多个键值对</li>
<li>hmget hash key1 key2 ……：获取hash多个key字段的值</li>
<li>hgetall hash ：获取全部key-value内容</li>
<li>hdel hash key ：删除hash中指定key字段</li>
<li>hlen hash ：返回hash长度</li>
<li>hexists hash key：判断hash中key字段是否存在</li>
<li>hkeys hash：返回所有key字段</li>
<li>hvals  hash：放回所有value</li>
<li>hincrby hash key  num：指定key增量num</li>
<li>hsetnx hash key value：不存在则存入</li>
</ol>
<h4 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合(Zset)"></a>有序集合(Zset)</h4><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h5 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li><p>ZADD key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数.</p>
</li>
<li><p>ZCARD key 获取有序集合的成员数.</p>
</li>
<li><p>ZCOUNT key min max 计算在有序集合中指定区间分数[min,max]的成员数。</p>
</li>
<li><p>ZINCRBY key increment member:有序集合中对指定成员的分数加上增量 increment。</p>
</li>
<li><p>ZINTERSTORE newkey num key …:计算给定的一个或多(num)个有序集key的交集并将结果集存储在新的有序集合 newkey 中。</p>
</li>
<li><p>ZLEXCOUNT key min max:在有序集合中计算指定字典区间内成员数量。</p>
<p> min max: { - [a =(-∞，a]; -  (a=(-∞，a)；[a [b=[a,b];-  +=(-∞,+∞)</p>
</li>
<li><p>ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员。-inf +inf = -∞ +∞</p>
</li>
<li><p>ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员。</p>
</li>
<li><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员。</p>
</li>
<li><p>ZRANK key member 返回有序集合中指定成员的索引。</p>
</li>
<li><p>ZREM key member [member …] 移除有序集合中的一个或多个成员。</p>
</li>
<li><p>ZREMRANGEBYLEX key min max :移除有序集合中给定的字典区间的所有成员。</p>
</li>
<li><p>ZREMRANGEBYRANK key start stop:移除有序集合中给定的排名区间的所有成员。</p>
</li>
<li><p>ZREMRANGEBYSCORE key min max移除有序集合中给定的分数区间的所有成员。</p>
</li>
<li><p>ZREVRANGE key start stop [WITHSCORES]返回有序集中指定区间内的成员，通过索引，分数从高到低。</p>
</li>
<li><p>ZREVRANGEBYSCORE key max min [WITHSCORES]返回有序集中指定分数区间内的成员，分数从高到低排序。</p>
</li>
<li><p>ZREVRANK key member返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。</p>
</li>
<li><p>ZSCORE key member返回有序集中，成员的分数值。</p>
</li>
<li><p>ZUNIONSTORE destination numkeys key [key …]计算给定的一个或多个有序集的并集，并存储在新的 key 中。</p>
</li>
<li><p>ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）。</p>
</li>
</ol>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>​    集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，其实不太准确。</p>
<p>​    其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： </p>
<ul>
<li>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 </li>
<li>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) </li>
<li>其他的range操作复杂度一般为O(log(n))</li>
<li>当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</li>
</ul>
<h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="地理空间（geospatial-）"><a href="#地理空间（geospatial-）" class="headerlink" title="地理空间（geospatial ）"></a>地理空间（geospatial ）</h4><p>​    Redis的Geo，3.2版本推出，可以推算地理位置的信息，两地之间的距离</p>
<p>​    城市经纬度查询：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p>
<!--**注：有效经度为-180至180度。有效纬度为-85.05112878至85.05112878度。**-->

<h5 id="六大操作"><a href="#六大操作" class="headerlink" title="六大操作"></a>六大操作</h5><p><strong>geoadd   key  经度 维度 坐标名</strong>：添加地理位置（两级无法直接添加，可一次添加多个）， 先经度后维度（官方文档疑似写错了）</p>
<p>例：geoadd china:city   116.405285  39.904989     beijing    121.4   31.2  shanghai  ……</p>
<p>​                        key            经度     维度    地理名称</p>
<p><strong>geopos key  name1 name2……</strong>：获取key中name的地理位置</p>
<p>例：GEOPOS china:city beijing shanghai shenzhen xianggang</p>
<p><strong>georadius key  经度 维度 距离：</strong> 以给定的经纬度为中心，找出某一半径内所有的元素</p>
<p>例：GEORADIUS china:city 110 30 1000 km [withcoord] [withdist]</p>
<p><strong>GEORADIUSBYMEMBER key  坐标名（元素名） 距离</strong> ：根据给定的元素确定中心点，再进行查找</p>
<p>例：GEORADIUSBYMEMBER china:city beijing 1000 km [withcoord] [withdist]</p>
<!--注：withcoord：经纬度,withdist：距离坐标城市的距离，count num：筛选出num个结果-->

<p><strong>GEODIST  key name1  name2 [单位]</strong> ：返回指定单位中两个指定成员之间的距离。如果缺少一个或两个成员，该命令将返回NULL。</p>
<!--单位必须是以下之一，默认为米：m（米）、km（千米）、mi（英里）、ft（英尺）-->

<p>例：GEODIST china:city beijing xianggang km</p>
<p><strong>GEOHASH key name1 name2……</strong>：该命令返回11个字符的Geohash字符串，因此与Redis内部52位表示形式相比，不会损失任何精度。该命令返回一个数组，其中每个元素是与作为参数传递给命令的每个成员名称相对应的Geohash。</p>
<p>返回的Geohashhes具有以下属性：  </p>
<ol>
<li>以从右侧删除字符来缩短它们。它将失去精度，但仍将指向同一区域。</li>
<li>可以在<code>geohash.org</code>URL中使用它们，例如<code>http://geohash.org/&lt;geohash-string&gt;</code>。这是<a href="http://geohash.org/sqdtr74hyu0">此类URL</a>的<a href="http://geohash.org/sqdtr74hyu0">示例</a>。</li>
<li>前缀相似的字符串在附近，但事实并非如此，前缀不同的字符串也可能在附近。</li>
</ol>
<p>geo底层实现原理其实是zset，我们可以使用zset命令操作他</p>
<p>zrange key 0 -1：查看地图key中的所有元素</p>
<p>zrem key member：删除key中指定元素</p>
<h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p><strong>简介：Hyperloglog 可用于基数统计（基数：在数学上，是集合论中刻画任意集合集大小的一个概念。即一个集合中不重复的元素数。）</strong></p>
<p><strong>redis2.8.9后更新了hyperloglog数据结构</strong></p>
<p>示例：网页UV</p>
<p>uv（Unique Visitor）:网站的独立访客，统计1天内访问某站点的用户数(以cookie为依据);访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。</p>
<p>访问用户量大的情况下，若用传统的set集合统计将耗费大量内存。使用hyperloglog基数统计占用内存固定，2^64不同的元素，只需要废12kb内存。（官网统计hyperloglog有0.81%的错误率，但在统计UV任务上，我们可以忽略不计）</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>PFADD keyset  value1 value2 value3……往集合keyset中添加元素</p>
<p>PFCOUNT keyset：统计集合keyset的基数</p>
<p>PFMERGE  newset keyset1 ketset2：将集合keyset1和keyset2的元素合并（并集）到newset中</p>
<h4 id="Bitmap（位存储）"><a href="#Bitmap（位存储）" class="headerlink" title="Bitmap（位存储）"></a>Bitmap（位存储）</h4><p><strong>简介：</strong> Biymaps位图，该数据结构都是操作二进制位来记录数据的，就只有0和1两个状态。（适用于只有两个状态的数据）</p>
<h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p>setbit  sign index  value：往sign的index（从0开始）位置上存value（0或1）</p>
<p>getbit sign index ：获取sign中index位上的值（默认0）</p>
<p>bitcount sign：统计sgin中为1的数量</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.3.1.RELEASE与javaFx整合</title>
    <url>/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><figure class="highlight xml"><figcaption><span>&lt;dependency&gt;</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.roskenet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-javafx-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动类继承AbstractJavaFxApplicationSupport"><a href="#启动类继承AbstractJavaFxApplicationSupport" class="headerlink" title="启动类继承AbstractJavaFxApplicationSupport"></a>启动类继承AbstractJavaFxApplicationSupport</h2><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375394146.png" alt="启动类"></p>
<h2 id="采用mvc模式"><a href="#采用mvc模式" class="headerlink" title="采用mvc模式"></a>采用mvc模式</h2><ul>
<li><h3 id="每个fxml页面都有对应的java视图类"><a href="#每个fxml页面都有对应的java视图类" class="headerlink" title="每个fxml页面都有对应的java视图类"></a>每个fxml页面都有对应的java视图类</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375588.png" alt="视图"></p>
<ul>
<li><h3 id="视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）"><a href="#视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）" class="headerlink" title="视图类需继承AbstractFxmlView且有**@FXMLView注解**（value值为对应的fxml文件路径）"></a>视图类需继承<strong>AbstractFxmlView</strong>且有**@FXMLView注解**（value值为对应的fxml文件路径）</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375950(1).jpg" alt="视图类"></p>
<ul>
<li><h3 id="fxml文件中需指定对应controller类"><a href="#fxml文件中需指定对应controller类" class="headerlink" title="fxml文件中需指定对应controller类"></a>fxml文件中需指定对应controller类</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376230(1).jpg" alt="fxml文件"></p>
<ul>
<li><h3 id="controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息"><a href="#controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息" class="headerlink" title="controller类需实现Initializable接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)"></a>controller类需实现<strong>Initializable</strong>接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376444(1).jpg"></p>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376926(1).jpg"></p>
<ul>
<li><h3 id="fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法"><a href="#fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法" class="headerlink" title="fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法"></a>fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377406(1).jpg"></p>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377507(1).jpg"></p>
<h2 id="示例页面效果展示-只是简单项目，页面可能有点丑"><a href="#示例页面效果展示-只是简单项目，页面可能有点丑" class="headerlink" title="示例页面效果展示(只是简单项目，页面可能有点丑)"></a>示例页面效果展示(只是简单项目，页面可能有点丑)</h2><ul>
<li><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377745(1).jpg" alt="登陆"></p>
<ul>
<li><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377865(1).jpg" alt="主页"></p>
<ul>
<li><h3 id="点击住宿按钮弹出住宿页面进行信息登记"><a href="#点击住宿按钮弹出住宿页面进行信息登记" class="headerlink" title="点击住宿按钮弹出住宿页面进行信息登记"></a>点击住宿按钮弹出住宿页面进行信息登记</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377915(1).jpg"></p>
<ul>
<li><h3 id="双击对应表格中的宿舍即可查看详情"><a href="#双击对应表格中的宿舍即可查看详情" class="headerlink" title="双击对应表格中的宿舍即可查看详情"></a>双击对应表格中的宿舍即可查看详情</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378007(1).jpg"></p>
<ul>
<li><h3 id="宿舍管理页面"><a href="#宿舍管理页面" class="headerlink" title="宿舍管理页面"></a>宿舍管理页面</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378103(1).jpg"></p>
<h2 id="获取项目"><a href="#获取项目" class="headerlink" title="获取项目"></a>获取项目</h2><ul>
<li><h3 id="Git仓库地址"><a href="#Git仓库地址" class="headerlink" title="Git仓库地址"></a><a href="https://github.com/czmDeRepository/javaFx">Git仓库地址</a></h3></li>
<li><h3 id="注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql"><a href="#注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql" class="headerlink" title="注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql"></a><strong>注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql</strong></h3></li>
</ul>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>sql中distinct简单使用</title>
    <url>/2020/09/22/SQL/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"><a href="#简介：distinct常用于sql语句中查出重复数据时需要去重的时候" class="headerlink" title="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"></a><strong>简介：distinct常用于sql语句中查出重复数据时需要去重的时候</strong></h3><!--distinct不会过滤掉null值，返回结果包含null值-->

<p>示例：table</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td>null</td>
<td>f</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="只有一字段："><a href="#只有一字段：" class="headerlink" title="只有一字段："></a><strong>只有一字段</strong>：</h3><p>​        <strong>直接在字段前加distinct</strong></p>
<p>​        select distinct column1 from table</p>
<p>结果：</p>
<table>
<thead>
<tr>
<th>column1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
</tr>
<tr>
<td>2</td>
</tr>
<tr>
<td>3</td>
</tr>
<tr>
<td>null</td>
</tr>
<tr>
<td></td>
</tr>
</tbody></table>
<h3 id="需要查出多个字段："><a href="#需要查出多个字段：" class="headerlink" title="需要查出多个字段："></a><strong>需要查出多个字段</strong>：</h3><p>​    distinct 需要放在第一个字段前面，否者报错</p>
<p>select distinct colum1 , colum2 from table;</p>
<p>结果：多个字段其实是多个字段查出后拼接再去重</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td>null</td>
<td>f</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="只想一个字段唯一"><a href="#只想一个字段唯一" class="headerlink" title="只想一个字段唯一"></a><strong>只想一个字段唯一</strong></h3><p><strong>1.使用group by</strong></p>
<p>​    select column1, column2 from table group by column1</p>
<p><strong>2.使用GROUP_CONCAT函数</strong></p>
<p>​    <strong>GROUP_CONCAT在连接查询的时候，能让查出的这字段的多个数，按字符拼接的方式存放在一起。</strong></p>
<p>select GROUP_CONCAT(distinct column1) as column1, column2 from table group by column1</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>mySQL&#39;1055&#39;错误</title>
    <url>/2020/11/06/SQL/mySQL%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>执行复杂sql（我是多表连接查询和group by分组一起使用）语句时，报以下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">translate SQLException with Error code <span class="string">&#x27;1055&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>mysql5.7后，sql_mode中默认存在ONLY_FULL_GROUP_BY(不要让GROUP BY部分中的查询指向未选择的列)，对 group by 用法的规定，select 的字段只能是group by的字段。或者需要加聚合函数的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在数据库中执行以下语句</span></span><br><span class="line">SELECT @@global.sql_mode <span class="comment">#查询sql_mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span></span><br><span class="line"><span class="comment">#ONLY_FULL_GROUP_BY　　        不要让GROUP BY部分中的查询指向未选择的列　　</span></span><br><span class="line"><span class="comment">#STRICT_TRANS_TABLES           为事务存储引擎启用严格模式，也可能为非事务存储引擎启用严格模式</span></span><br><span class="line"><span class="comment">#NO_ZERO_IN_DATE               在严格模式，不接受月或日部分为0的日期</span></span><br><span class="line"><span class="comment">#NO_ZERO_DATE                 在严格模式，不将 &#x27;0000-00-00&#x27;做为合法日期</span></span><br><span class="line"><span class="comment">#ERROR_FOR_DIVISION_BY_ZERO   在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误　　</span></span><br><span class="line"><span class="comment">#NO_AUTO_CREATE_USER          防止GRANT自动创建新用户，除非还指定了密码</span></span><br><span class="line"><span class="comment">#NO_ENGINE_SUBSTITUTION       如果需要的存储引擎被禁用或未编译，可以防止自动替换存储引擎</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去掉ONLY_FULL_GROUP_BY 执行以下语句</span></span><br><span class="line"><span class="built_in">set</span> global sql_mode = <span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启项目问题解决</span></span><br></pre></td></tr></table></figure>



<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>能不修改尽量不修改，一般这个是你使用group by分组后，在查出的数据中被分到同一组的数据的有其它字段不相同，可将这字段加入分组条件解决</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常问问题</title>
    <url>/2020/12/02/SQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数据库索引失效情况"><a href="#数据库索引失效情况" class="headerlink" title="数据库索引失效情况"></a>数据库索引失效情况</h2><h3 id="查询条件中使用or"><a href="#查询条件中使用or" class="headerlink" title="查询条件中使用or"></a>查询条件中使用or</h3><p>​    注：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p>
<h3 id="查询使用is-null判断"><a href="#查询使用is-null判断" class="headerlink" title="查询使用is null判断"></a>查询使用is null判断</h3><ul>
<li>单列索引无法存储null，复合索引无法储存全为null的值。</li>
<li>索引是有序的，插入数据时需要对其进行比较，null无法比较，无法确定其位置。</li>
</ul>
<p>（解决，可自定义特定值替代null值，或使用复合索引）</p>
<h3 id="模糊查询使用-开头-如-like-‘-this’"><a href="#模糊查询使用-开头-如-like-‘-this’" class="headerlink" title="模糊查询使用%开头 如 like ‘%this’"></a>模糊查询使用%开头 如 like ‘%this’</h3><p>​    注：若不是%开头的模糊查询，如’XX%’，可用XX去匹配索引列，当碰到其他开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。以%开头的就难以定位，执行引擎可能更倾向于全表扫描。</p>
<h3 id="若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引"><a href="#若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引" class="headerlink" title="若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引"></a>若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引</h3><h3 id="存在类型转换"><a href="#存在类型转换" class="headerlink" title="存在类型转换"></a>存在类型转换</h3><p>如：整型字段条件却用字符(where num =  ‘123’)</p>
<h3 id="如果mysql估计使用全表扫描要比使用索引快-则不使用索引"><a href="#如果mysql估计使用全表扫描要比使用索引快-则不使用索引" class="headerlink" title="如果mysql估计使用全表扫描要比使用索引快,则不使用索引"></a>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</h3><p>如：表中列与列间的对比，在同一表中的两个列都建了索引，条件是where column1 = column2时，会被认为不如走全表扫描</p>
<h2 id="索引列的数据都一样时"><a href="#索引列的数据都一样时" class="headerlink" title="索引列的数据都一样时"></a>索引列的数据都一样时</h2><p>注：索引不应被建在数据几乎一样的列上</p>
<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>​    B树索引底层使用多路平衡查找树，具有范围查找和前缀查找的能力，对于有N节点的B树，检索一条记录的复杂度为O(LogN)。相当于二分查找。InnoDB存储引擎的默认索引实现为:B+树索引。</p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>　　哈希索引底层是Hash表只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。如果值的差异性相对较差，并且以范围查找为主，B树是更好的选择，它支持范围查找。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>String理解</title>
    <url>/2020/11/17/java/String/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>jdk8及以前底层用char[]数组实现，jdk9以后改为byte[]。</p>
<p>jdk6及以前，字符串常量池存放在永久代。jdk7及其以后保存在Java堆中。</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>对String字符串重新赋值，拼接，replace指定字符，都不能使用原有value进行赋值。</p>
<h2 id="字符串拼接结果保存"><a href="#字符串拼接结果保存" class="headerlink" title="字符串拼接结果保存"></a>字符串拼接结果保存</h2><ol>
<li>两个常量拼接结果在常量池，原理是编译器优化。</li>
<li>要是拼接表达式存在变量，结果就保存在堆中。底层使用String Builder拼接。</li>
<li>如果拼接结果调用intern()方法，则主动将常量池中还没有的字符串对象存入常量池中，并返回此对象地址。</li>
</ol>
<h2 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2020/11/17/java/String/image-20201130200723360.png" alt="image-20201130200723360"></p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	创建两对象</span></span><br><span class="line"><span class="comment">	1，堆空间的new 出来的对象</span></span><br><span class="line"><span class="comment">	2，字符串常量池的&quot;a&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//由于常量池已经有&quot;a&quot;,直接返回常量池&quot;a&quot;地址</span></span><br><span class="line">String ss = s.intern();</span><br><span class="line">String s2 =<span class="string">&quot;a&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//jdk6/7/8 : false</span></span><br><span class="line">System.out.println(ss == s2); <span class="comment">//jdk6/7/8 : true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	创建&quot;aa&quot;对象，但常量池中只有字符串&quot;a&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	jdk6</span></span><br><span class="line"><span class="comment">	由于此时常量池中无&quot;aa&quot;，常量池中存入&quot;aa&quot;字符串（相当于复制一份），返回常量池中字符串的引用地址</span></span><br><span class="line"><span class="comment">	所以s3和s4地址不相同</span></span><br><span class="line"><span class="comment">	jdk7/8</span></span><br><span class="line"><span class="comment">	由于此时常量池中无&quot;aa&quot;，所以把s3的对象地址存入常量池(复制的是对象的地址)，返回常量池中对象的地址</span></span><br><span class="line"><span class="comment">	所以s3和s4的地址是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>String 的String Pool 不存在相同的内容变量，是固定大小的HashTable，默认长度1009，当里面String过多时，Hash冲突严重，导致链表会很长，String.itern(用于将字符串放入常量池)性能严重下降。</p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p> -XX: StringTableSize 可设置JVM的StringTable长度。</p>
<ul>
<li>jdk6：StringTable固定大小，长度就是1009。</li>
<li>jdk7：长度默认60013。</li>
<li>jdk8：长度默认60013。1009是设置String Table的最小值。</li>
</ul>
<h2 id="问题！！！"><a href="#问题！！！" class="headerlink" title="问题！！！"></a>问题！！！</h2><h3 id="new-String-“ab”-；new-String-“a”-new-String-“b”-分别创建多少个对象？"><a href="#new-String-“ab”-；new-String-“a”-new-String-“b”-分别创建多少个对象？" class="headerlink" title="new String(“ab”)；new String(“a”) + new String(“b”); 分别创建多少个对象？"></a>new String(“ab”)；new String(“a”) + new String(“b”); 分别创建多少个对象？</h3><h2 id="new-String-“ab”-；"><a href="#new-String-“ab”-；" class="headerlink" title="new String(“ab”)；"></a>new String(“ab”)；</h2><p>两个：</p>
<p>一个是堆中new出来的对象，一个是常量池中的”ab”字符串。</p>
<h2 id="new-String-“a”-new-String-“b”"><a href="#new-String-“a”-new-String-“b”" class="headerlink" title="new String(“a”) + new String(“b”);"></a>new String(“a”) + new String(“b”);</h2><p>六个：</p>
<ol>
<li>StringBulider对象</li>
<li>new String(“a”)堆中new对象</li>
<li>常量池中的”a”字符串</li>
<li>new String(“b”)堆中new对象</li>
<li>常量池中的”b”字符串</li>
<li>StringBuilder的toString()方法返回new String(“ab”).注：调用toString()方法常量池不会生成字符串”ab”</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javadoc简单使用</title>
    <url>/2020/11/29/java/javadoc/</url>
    <content><![CDATA[<h2 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h2><p>Java 支持三种注释方式。前两种分别是 <strong>//</strong> 和 <strong>/* */<strong>，第三种被称作说明注释，它以 **/\</strong></strong> 开始，以 ***/**结束。</p>
<p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p>
<p>说明注释，使你更加方便的记录你的程序信息。</p>
<h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><ul>
<li>第一段：概要描述，通常用一句或者一段话简要描述该类的作用，以英文句号作为结束。</li>
<li>第二段：详细描述，通常用一段或者多段话来详细描述该类的作用，一般每段话都以英文句号作为结束。</li>
<li>第三段：文档标注，用于标注作者、创建时间、参阅类等信息。</li>
</ul>
<p><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">参考地址</a></p>
<h2 id="javadoc-标签"><a href="#javadoc-标签" class="headerlink" title="javadoc 标签"></a>javadoc 标签</h2><table>
<thead>
<tr>
<th align="left"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">@author</td>
<td align="center">标识一个类的作者</td>
<td align="center">@author description</td>
</tr>
<tr>
<td align="left">@deprecated</td>
<td align="center">指名一个过期的类或成员</td>
<td align="center">@deprecated description</td>
</tr>
<tr>
<td align="left">{@docRoot}</td>
<td align="center">指明当前文档根目录的路径</td>
<td align="center">Directory Path</td>
</tr>
<tr>
<td align="left">@exception</td>
<td align="center">标志一个类抛出的异常</td>
<td align="center">@exception exception-name explanation</td>
</tr>
<tr>
<td align="left">{@inheritDoc}</td>
<td align="center">从直接父类继承的注释</td>
<td align="center">Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td align="left">{@link}</td>
<td align="center">用于快速链接到相关代码</td>
<td align="center">{@link name text}</td>
</tr>
<tr>
<td align="left">{@linkplain}</td>
<td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td align="center">Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td align="left">@param</td>
<td align="center">说明一个方法的参数</td>
<td align="center">@param parameter-name explanation</td>
</tr>
<tr>
<td align="left">@return</td>
<td align="center">说明返回值类型</td>
<td align="center">@return explanation</td>
</tr>
<tr>
<td align="left">@see</td>
<td align="center">指定一个到另一个主题的链接</td>
<td align="center">@see anchor</td>
</tr>
<tr>
<td align="left">@serial</td>
<td align="center">说明一个序列化属性</td>
<td align="center">@serial description</td>
</tr>
<tr>
<td align="left">@serialData</td>
<td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td align="center">@serialData description</td>
</tr>
<tr>
<td align="left">@serialField</td>
<td align="center">说明一个ObjectStreamField组件</td>
<td align="center">@serialField name type description</td>
</tr>
<tr>
<td align="left">@since</td>
<td align="center">标记当引入一个特定的变化时</td>
<td align="center">@since release</td>
</tr>
<tr>
<td align="left">@throws</td>
<td align="center">和 @exception标签一样.</td>
<td align="center">The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td align="left">{@value}</td>
<td align="center">显示常量的值，该常量必须是static属性。</td>
<td align="center">Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td align="left">@version</td>
<td align="center">指定类的版本</td>
<td align="center">@version info</td>
</tr>
<tr>
<td align="left">@code</td>
<td align="center">将文本标记为code</td>
<td align="center">{@code text} 会被解析成<code>&lt;code&gt; text &lt;/code&gt;</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>easypoi导出动态列头excel文件（非注解）</title>
    <url>/2020/11/30/java/easypoi/</url>
    <content><![CDATA[<h2 id="easypoi"><a href="#easypoi" class="headerlink" title="easypoi"></a>easypoi</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>java对excel文件操作的工具类，使用简单，只需简单几个注解即可完成excel的简单导入导出，也可以基于map灵活定义的表头字段（适用于列数不定，动态生成，下面介绍）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springboot项目直接引入以下启动依赖也行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="用于生成excel文件所需数据"><a href="#用于生成excel文件所需数据" class="headerlink" title="用于生成excel文件所需数据"></a>用于生成excel文件所需数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 用于生成excel文件所需数据</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">transformToExcelMap</span><span class="params">(Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    List&lt;ExcelExportEntity&gt; colList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	添加列</span></span><br><span class="line"><span class="comment">    	public ExcelExportEntity(String name, Object key) &#123;</span></span><br><span class="line"><span class="comment">            super.name = name;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        key用于后面数据绑定</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;班级&quot;</span>, <span class="string">&quot;className&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;学号&quot;</span>, <span class="string">&quot;username&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;name&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;性别&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		表格内容</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();</span><br><span class="line">    List&lt;ExamCorrectDto&gt; examCorrectDtos = (List&lt;ExamCorrectDto&gt;) params.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    examCorrectDtos.forEach(examCorrectDto -&gt; &#123;</span><br><span class="line">        <span class="comment">//每一个valMap就是一行数据，key就是前面定义表头时的key</span></span><br><span class="line">        Map&lt;String, Object&gt; valMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        valMap.put(<span class="string">&quot;className&quot;</span>, examCorrectDto.getClassName());</span><br><span class="line">        valMap.put(<span class="string">&quot;username&quot;</span>, examCorrectDto.getUsername());</span><br><span class="line">        valMap.put(<span class="string">&quot;name&quot;</span>, examCorrectDto.getName());</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将每行数据添加在表格内容list中</span></span><br><span class="line">        list.add(valMap);</span><br><span class="line">    &#125;);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    String title = <span class="string">&quot;测验名：&quot;</span> + params.get(<span class="string">&quot;examName&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      课程：&quot;</span> + params.get(<span class="string">&quot;courseName&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      日期：&quot;</span> + simpleDateFormat.format(params.get(<span class="string">&quot;startTime&quot;</span>)) +</span><br><span class="line">        <span class="string">&quot;;      时长：&quot;</span> + params.get(<span class="string">&quot;durationTime&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      总题数：&quot;</span> + params.get(<span class="string">&quot;questionNum&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      总分：&quot;</span> + params.get(<span class="string">&quot;totalScore&quot;</span>);</span><br><span class="line">    ExportParams exportParams = <span class="keyword">new</span> ExportParams(title, params.get(<span class="string">&quot;examName&quot;</span>).toString(), ExcelType.XSSF);</span><br><span class="line">    <span class="comment">//设置标题高度</span></span><br><span class="line">    exportParams.setTitleHeight((<span class="keyword">short</span>) <span class="number">15</span>);</span><br><span class="line">    <span class="comment">//自定义标题样式（代码在下面）</span></span><br><span class="line">    exportParams.setStyle(ExcelTitleStyleConfig.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**    cn.afterturn.easypoi.entity.vo.NormalExcelConstants </span></span><br><span class="line"><span class="comment"> 	单Sheet导出 EASYPOI_EXCEL_VIEW = &quot;easypoiExcelView&quot;;</span></span><br><span class="line"><span class="comment">    数据列表 DATA_LIST			    = &quot;data&quot;;</span></span><br><span class="line"><span class="comment">    多Sheet 对象 MAP_LIST   		 = &quot;mapList&quot;;</span></span><br><span class="line"><span class="comment"> 	注解对象  CLASS    				= &quot;entity&quot;;</span></span><br><span class="line"><span class="comment">    表格参数 PARAMS   			 	= &quot;params&quot;;</span></span><br><span class="line"><span class="comment">    下载文件名称 FILE_NAME 		   = &quot;fileName&quot;;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    res.put(NormalExcelConstants.CLASS, ExcelExportEntity.class);</span><br><span class="line">    res.put(NormalExcelConstants.DATA_LIST, list);</span><br><span class="line">    res.put(NormalExcelConstants.PARAMS, exportParams);</span><br><span class="line">    res.put(NormalExcelConstants.MAP_LIST, colList);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/11/29</span></span><br><span class="line"><span class="comment"> * 设置样式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelTitleStyleConfig</span> <span class="keyword">extends</span> <span class="title">ExcelExportStylerDefaultImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelTitleStyleConfig</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(workbook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getHeaderStyle</span><span class="params">(<span class="keyword">short</span> color)</span> </span>&#123;</span><br><span class="line">        CellStyle headStyle = <span class="keyword">super</span>.getHeaderStyle(color);</span><br><span class="line">        headStyle.setWrapText(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置前景色填充颜色</span></span><br><span class="line">        headStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex());</span><br><span class="line">        <span class="comment">//设置填充模式！！！注，必要设置，否则ForegroundColor设置无效</span></span><br><span class="line">        headStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        <span class="keyword">return</span> headStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 生成多sheet文件</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> paramList 参数列表，每个Map表示一个Tab，即Sheet</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exportToExcel</span><span class="params">(List&lt;Map&lt;String, Object&gt;&gt; paramList)</span> </span>&#123;</span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">    ExcelExportService server = <span class="keyword">new</span> ExcelExportService();</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; sheetList = <span class="keyword">new</span> ArrayList(paramList.size());</span><br><span class="line">    <span class="comment">//将信息组装成相应信息，一个map就是一个sheet</span></span><br><span class="line">    paramList.forEach(param -&gt; sheetList.add(transformToExcelMap(param)));</span><br><span class="line">    </span><br><span class="line">    sheetList.forEach(sheet -&gt; &#123;</span><br><span class="line">        server.createSheetForMap(</span><br><span class="line">            workbook,</span><br><span class="line">            (ExportParams) sheet.get(NormalExcelConstants.PARAMS),</span><br><span class="line">            (List&lt;ExcelExportEntity&gt;) sheet.get(NormalExcelConstants.MAP_LIST),</span><br><span class="line">            (List&lt;Map&lt;String, Object&gt;&gt;) sheet.get(NormalExcelConstants.DATA_LIST));</span><br><span class="line">    &#125;);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;文件名.xlsx&quot;</span>);</span><br><span class="line">        <span class="comment">//写出文件</span></span><br><span class="line">        workbook.write(fos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (workbook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                workbook.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="/2020/11/30/java/easypoi/image-20201130170342374.png" alt="image-20201130170342374"></p>
<h3 id="注解形式直接看官方文档即可"><a href="#注解形式直接看官方文档即可" class="headerlink" title="注解形式直接看官方文档即可"></a>注解形式直接看官方文档即可</h3><p><a href="http://easypoi.mydoc.io/">参考文档1</a></p>
<p><a href="http://doc.wupaas.com/docs/easypoi/easypoi-1c0u6ksp2r091">参考文档2</a></p>
<p>注：也可使用<a href="https://github.com/alibaba/easyexcel">easyexcel</a> （阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称）。</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jwt生产校验token</title>
    <url>/2020/10/21/java/jwt%E7%94%9F%E6%88%90%E6%A0%A1%E9%AA%8Ctoken/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <strong>Jwt</strong>（JSON Web Token）是一种基于RFC 7519标准定义的一种可以安全传输的小巧和自包含的JSON对象。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token计为紧凑且安全,也可直接被用于认证，也可被加密。允许我们在用户和服务器之间传递安全可靠的信息。<strong>特别适用于分布式站点的单点登录</strong>(SingleSignOn，SSO)。JWT可以使用HMAC算法对secret进行加密或者使用RSA的公钥私钥对其进行签名。</p>
<h2 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h2><ul>
<li><p><strong>Header 头部</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#令牌的类型（即JWT）和使用的签名算法组成</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Payload 负载</strong> </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由预定义（Registered） 公有（public） 私有（private）三类属性组成</span></span><br><span class="line"><span class="comment">#Registered，由官方预定，非必需</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    iss (issuer)：签发人</span><br><span class="line"></span><br><span class="line">    sub (subject)：主题</span><br><span class="line"></span><br><span class="line">    aud (audience)：受众</span><br><span class="line"></span><br><span class="line">    exp (expiration time)：过期时间</span><br><span class="line"></span><br><span class="line">    nbf (Not Before)：生效时间，在此之前是无效的</span><br><span class="line"></span><br><span class="line">    iat (Issued At)：签发时间</span><br><span class="line"></span><br><span class="line">    jti (JWT ID)：编号</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#public: 在使用 JWT 时可以额外定义的载荷</span></span><br><span class="line"><span class="comment">#private:在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>Signature 签名/签证</strong></p>
<p>  主要是把头部的base64UrlEncode与负载的base64UrlEncode拼接起来，再进行HMACSHA256加密，加密结果再进行base64url加密，最终得到的结果作为签名部分</p>
</li>
</ul>
<h3 id="JWT示例"><a href="#JWT示例" class="headerlink" title="JWT示例"></a>JWT示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiItMSIsInJvbGVJZCI6LTEsInVzZXJJZCI6MSwiaWF0IjoxNjAzMjc1OTE5LCJleHAiOjE2MDMzNjIzMTl9.KVJTpGYMX8IOBFjdNQvmGAsDRQ3J7_2McajtI2WYlss</span><br></pre></td></tr></table></figure>



<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Jwt工具类代码"><a href="#Jwt工具类代码" class="headerlink" title="Jwt工具类代码"></a>Jwt工具类代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/20 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间，一天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long EXPIRED_TIME = <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String KEY = <span class="string">&quot;密钥&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(String userName, Long userId)</span></span>&#123;</span><br><span class="line">        String token = Jwts</span><br><span class="line">                .builder()</span><br><span class="line">                .setSubject(String.valueOf(roleId)) <span class="comment">//设置这个JWT的主体，即它的所有人</span></span><br><span class="line">                .claim(<span class="string">&quot;userName&quot;</span>, userName)</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date()) <span class="comment">//jwt的签发时间</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis()+EXPIRED_TIME))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, KEY) <span class="comment">//设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Claims claims = Jwts.parser()  //得到DefaultJwtParser</span></span><br><span class="line"><span class="comment">//                .setSigningKey(KEY)         //设置签名的秘钥</span></span><br><span class="line"><span class="comment">//                .parseClaimsJws(jwt).getBody();//设置需要解析的jwt</span></span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody().get(<span class="string">&quot;userName&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getUserId</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims body = Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> body.get(<span class="string">&quot;userId&quot;</span>,Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExpiration</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>maven简单介绍</title>
    <url>/2020/10/15/java/maven%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p>
</li>
<li><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p>
</li>
<li><p>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p>
<p> 注：摘自[菜鸟教程]:<a href="https://www.runoob.com/maven/maven-tutorial.html">https://www.runoob.com/maven/maven-tutorial.html</a></p>
</li>
</ol>
<h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><h4 id="减少冗余"><a href="#减少冗余" class="headerlink" title="减少冗余"></a>减少冗余</h4><p>在项目开发中，我们常常需要引入第三方的框架和工具包来提高开发速度，以前要使用这些 jar 包就是复制粘贴到 WEB-INF/lib 目录下。当你建了多个项目时有项目都需要引入同一jar包，需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，使工程显得很臃肿。 </p>
<p>使用maven后会在本地建一个统一的仓库，用于存放所有jar包、源文件等，当项目需要引入某个jar包时，只需复制其依赖坐标至pom文件中，maven就会自动帮我们导入到项目中。每个jar包本地只保存一份，不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</p>
<h4 id="解决jar包依赖"><a href="#解决jar包依赖" class="headerlink" title="解决jar包依赖"></a>解决jar包依赖</h4><p>jar包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来， 无需人工参与，节约了我们大量的时间和精力。</p>
<h4 id="统一下载"><a href="#统一下载" class="headerlink" title="统一下载"></a>统一下载</h4><p>我们通常在查找第三方jar包，选择版本上花费很多时间，maven提供个中央仓库，只需你依赖坐标填对，就会自动去 [中央仓库]:<a href="https://mvnrepository.com/">https://mvnrepository.com/</a>  下载。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本，打包项目等</p>
<h2 id="maven项目构建过程的几个主要环节"><a href="#maven项目构建过程的几个主要环节" class="headerlink" title="maven项目构建过程的几个主要环节"></a>maven项目构建过程的几个主要环节</h2><ol>
<li>清理：删除以前的编译结果，为重新编译做好准备。 </li>
<li>编译：将 Java 源程序编译为字节码文件。</li>
<li>测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 </li>
<li>报告：在每一次测试后以标准的格式记录和展示测试结果。 </li>
<li>打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 </li>
<li>安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 </li>
<li>部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 </li>
</ol>
<h2 id="pom文件常用标签介绍"><a href="#pom文件常用标签介绍" class="headerlink" title="pom文件常用标签介绍"></a>pom文件常用标签介绍</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的全球唯一标识符(项目名) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。默认值是../pom.xml。</span></span><br><span class="line"><span class="comment">		Maven首先在构建当前项目的地方寻找父项目的pom，</span></span><br><span class="line"><span class="comment">		其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目.(公司或组织的域名倒序) --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.czm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。(当前项目的模块名称) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>back<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--当前模块的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--项目打包格式：pom、jar、war</span></span><br><span class="line"><span class="comment">	父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">&lt;!--统一管理所依赖 jar 包的版本 对同一个框架的一组 jar 包最好使用相同的版本。</span></span><br><span class="line"><span class="comment">	为了方便升级框架，可以将 jar 包的版本信息统一提取出来  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR8<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.12<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--项目描述 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>just a demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">     <span class="comment">&lt;!--jar包依赖坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用上面统一声明的版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			依赖的范围 ：compile、test、provided </span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。</span></span><br><span class="line"><span class="comment">			即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">          <span class="comment">&lt;!--描述与项目关联的文件是什么和在哪里--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span> <span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span> </span><br><span class="line">              <span class="comment">&lt;!-- true/false，表示为这个resource，filter是否激活--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!--定义resource文件所在的文件夹，默认为$&#123;basedir&#125;/src/main/resources--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span> <span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!--  指定哪些文件将被匹配，以*作为通配符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>configuration.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!-- 指定哪些文件将被忽略--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 定义和resource类似，只不过在test时使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">        ...  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>  </span><br><span class="line"> 	<span class="comment">&lt;!--指定使用的插件--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="父项目pom常用坐标"><a href="#父项目pom常用坐标" class="headerlink" title="父项目pom常用坐标"></a>父项目pom常用坐标</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!--引入springboot开始依赖--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明子模块，指定模块工程的相对路径即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>model1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>model2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--统一声明--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot-maven-plugin</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-maven-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意使用import标签时，不再使用&lt;parent&gt;标签</span></span><br><span class="line"><span class="comment">			表示将父项目的dependencyManagement拿到本POM中，不再继承parent</span></span><br><span class="line"><span class="comment">			type必须是pom--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--与dependencyManagement类似，只声明--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-maven-plugin&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--添加配置跳过测试类构建--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij IDEA常用快捷键</title>
    <url>/2020/10/10/%E5%85%B6%E4%BB%96/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="Intellij-IDEA常用快捷键"><a href="#Intellij-IDEA常用快捷键" class="headerlink" title="Intellij IDEA常用快捷键"></a>Intellij IDEA常用快捷键</h2><ol>
<li><p>Alt+回车 导入包,自动修正</p>
</li>
<li><p>Ctrl＋Alt＋V 插入变量名。</p>
</li>
<li><p>Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</p>
</li>
<li><p>Ctrl＋Q可以看到当前方法的声明（注释文档）</p>
</li>
<li><p>Alt＋Insert可以生成构造器/Getter/Setter等</p>
</li>
<li><p>Alt+Shift+C 对比最近修改的代码</p>
</li>
<li><p>Ctrl+N   查找类</p>
</li>
<li><p>Alt + 7 查看当前所有方法</p>
</li>
<li><p>Alt+f7 查看方法被调用(顺序)</p>
</li>
<li><p>Ctrl+Alt+H 查看方法被调用（逆推）</p>
</li>
<li><p>Ctrl+H 显示类结构图（继承结构）</p>
</li>
<li><p>Ctrl+Shift+N 查找文件</p>
</li>
<li><p>Ctrl+Alt+L  格式化代码</p>
</li>
<li><p>Ctrl+E查看最近文件</p>
</li>
<li><p>Ctrl+R 替换文本</p>
</li>
<li><p>Ctrl+F 查找文本</p>
</li>
<li><p>Ctrl+Shift+Space 代码提示</p>
</li>
<li><p>Ctrl+Alt+Space 类名或接口名提示</p>
</li>
<li><p>Ctrl+P 方法参数提示</p>
</li>
<li><p>Shift+F6  重构-重命名</p>
</li>
<li><p>Ctrl+X 复制行</p>
</li>
<li><p>Ctrl+D 删除行</p>
</li>
<li><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）</p>
</li>
<li><p>Alt+F1 查找代码所在位置</p>
</li>
<li><p>Ctrl+Alt+ left/right 返回至上次浏览的位置</p>
</li>
<li><p>Alt+ left/right 切换代码视图</p>
</li>
<li><p>Alt+ Up/Down 在方法间快速移动定位</p>
</li>
<li><p>Ctrl+Shift+Up/Down 代码向上/下移动。</p>
</li>
<li><p>F2 或Shift+F2 高亮错误或警告快速定位</p>
</li>
<li><p>代码标签输入完成后，按Tab，生成代码。</p>
</li>
<li><p>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</p>
</li>
<li><p>Ctrl+W 选中代码，连续按会有其他效果</p>
</li>
<li><p>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</p>
</li>
<li><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下</p>
</li>
<li><p>Ctrl+B 快速打开光标处的类或方法 </p>
</li>
<li><p>Shift＋Click可以关闭文件</p>
</li>
<li><p>Ctrl＋[或]可以跳到大括号的开头结尾</p>
</li>
<li><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>
</li>
<li><p>Ctrl＋F12，可以显示当前文件的结构</p>
</li>
<li><p>Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</p>
</li>
<li><p>Ctrl＋W可以选择单词继而语句继而行继而函数</p>
</li>
<li><p>Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger简单入门</title>
    <url>/2020/10/16/java/swagger/</url>
    <content><![CDATA[<h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a><strong>前后端分离</strong></h2><ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合</li>
</ul>
<h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a><strong>产生的问题</strong></h2><ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a><strong>Swagger</strong></h2><ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p>jdk 1.8 +</p>
<h3 id="方式一-使用官方依赖"><a href="#方式一-使用官方依赖" class="headerlink" title="方式一:使用官方依赖"></a>方式一:使用官方依赖</h3><h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编写一个配置类-SwaggerConfig来配置-Swagger"><a href="#编写一个配置类-SwaggerConfig来配置-Swagger" class="headerlink" title="编写一个配置类-SwaggerConfig来配置 Swagger"></a>编写一个配置类-SwaggerConfig来配置 Swagger</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;配置类</span><br><span class="line">@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问测试-：http-localhost-8080-swagger-ui-html-，可以看到swagger的界面；"><a href="#访问测试-：http-localhost-8080-swagger-ui-html-，可以看到swagger的界面；" class="headerlink" title="访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面；"></a>访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</h4><p><img src="/2020/10/16/java/swagger/image-20201016202312084.png" alt="image-20201016202312084"></p>
<h4 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.swagger.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Profiles;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.VendorExtension;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/16 16:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(ApiInfo apiInfo, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断当前是否处于该环境，环境配置：spring.profiles.active=dev</span></span><br><span class="line">        <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo)</span><br><span class="line">                .groupName(<span class="string">&quot;czm&quot;</span>) <span class="comment">//配置API分组名</span></span><br><span class="line">                .enable(flag)<span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">                .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  // 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.any()</span></span><br><span class="line"><span class="comment">                 *  // 不扫描接口</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.none()</span></span><br><span class="line"><span class="comment">                 *  // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span></span><br><span class="line"><span class="comment">                 *  // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.basePackage(final String basePackage) // 根据包路径扫描接口</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.czm.swagger.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/czm开头的接口</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/czm/**&quot;</span>))</span><br><span class="line">                <span class="comment">/***其他参数</span></span><br><span class="line"><span class="comment">                 * PathSelectors.any() // 任何请求都扫描</span></span><br><span class="line"><span class="comment">                 * PathSelectors.none() // 任何请求都不扫描</span></span><br><span class="line"><span class="comment">                 * PathSelectors.regex(final String pathRegex) // 通过正则表达式控制</span></span><br><span class="line"><span class="comment">                 * PathSelectors.ant(final String antPattern) // 通过ant()控制</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//配置文档信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         *    Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span></span><br><span class="line"><span class="comment">         *    return new ApiInfo(</span></span><br><span class="line"><span class="comment">         *            &quot;Swagger学习&quot;, // 标题</span></span><br><span class="line"><span class="comment">         *            &quot;学习演示如何配置Swagger&quot;, // 描述</span></span><br><span class="line"><span class="comment">         *            &quot;v1.0&quot;, // 版本</span></span><br><span class="line"><span class="comment">         *            &quot;http://terms.service.url/组织链接&quot;, // 组织链接</span></span><br><span class="line"><span class="comment">         *            contact, // 联系人信息</span></span><br><span class="line"><span class="comment">         *            &quot;Apach 2.0 许可&quot;, // 许可</span></span><br><span class="line"><span class="comment">         *            &quot;许可链接&quot;, // 许可连接</span></span><br><span class="line"><span class="comment">         *            new ArrayList&lt;&gt;()// 扩展</span></span><br><span class="line"><span class="comment">         *   );</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;czm&quot;</span>, <span class="string">&quot;baidu.com&quot;</span>, <span class="string">&quot;1233@qq.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(<span class="string">&quot;swagger的测试API&quot;</span>, <span class="string">&quot;Api Documentation的描述&quot;</span>, <span class="string">&quot;1.0版&quot;</span>, <span class="string">&quot;urn:tos&quot;</span>,</span><br><span class="line">                contact, <span class="string">&quot;Apache 2.0&quot;</span>, <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>, <span class="keyword">new</span> ArrayList&lt;VendorExtension&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 其他多个API组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h4><p>1、新建一个实体类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体类&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;用户账号&quot;)</span><br><span class="line">    private String account;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;用户密码&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public User(String account, String password) &#123;</span><br><span class="line">        this.account &#x3D; account;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccount(String account) &#123;</span><br><span class="line">        this.account &#x3D; account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;getUser&quot;)</span><br><span class="line">public User getUser()&#123;</span><br><span class="line">   return new User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/16/java/swagger/image-20201016210951882.png" alt="image-20201016210951882"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api(tags = “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
<tr>
<td>@ApiImplicitParam()</td>
<td>作用在方法上，表示单独的请求参数</td>
</tr>
<tr>
<td>@ApiImplicitParams()</td>
<td>作用于方法，包含多个 @ApiImplicitParam</td>
</tr>
</tbody></table>
<p>注：@ApiImplicitParam(name–参数名，value–参数说明 ，dataType–数据类型 ，example–举例说明，required–是否必填,</p>
<p>paramType–参数类型 )</p>
<p>paramType表示参数放在哪个地方</p>
<ul>
<li>header–&gt;请求参数的获取：@RequestHeader(代码中接收注解)</li>
<li>query–&gt;请求参数的获取：@RequestParam(代码中接收注解)</li>
<li>path（用于restful接口）–&gt;请求参数的获取：@PathVariable(代码中接收注解)</li>
<li>body–&gt;请求参数的获取：@RequestBody(代码中接收注解)</li>
<li>form（不常用）</li>
</ul>
<p>我们也可以给请求的接口配置一些注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.czm.swagger.controller;</span><br><span class="line"></span><br><span class="line">import com.czm.swagger.entity.User;</span><br><span class="line">import io.swagger.annotations.*;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author CZM</span><br><span class="line"> * @create 2020&#x2F;10&#x2F;16 16:49</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@Api(value&#x3D;&quot;swagger的hello模块&quot;,tags&#x3D;&#123;&quot;用户操作接口&quot;&#125;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;getUser&quot;)</span><br><span class="line">    @ApiOperation(&quot;获取一个默认user对象&quot;)</span><br><span class="line">    @ApiResponses(&#123;@ApiResponse(code &#x3D; 200, message &#x3D; &quot;good&quot;),@ApiResponse(code &#x3D; 401, message &#x3D; &quot;no power&quot;)&#125;)</span><br><span class="line">    public User getUser(@ApiParam(value &#x3D; &quot;这是参数1&quot;,name &#x3D; &quot;param&quot;) @RequestParam String param,</span><br><span class="line">                        @ApiParam(value &#x3D; &quot;这是参数2&quot;,name &#x3D; &quot;param2&quot;) @RequestParam String param2)&#123;</span><br><span class="line">        return new User(param+&quot;123&quot;,param2+&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;getUser2&#x2F;&#123;account&#125;&#x2F;&#123;password&#125;&quot;)</span><br><span class="line">    @ApiOperation(&quot;获取一个指定user对象&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * name–参数ming</span><br><span class="line">             * value–参数说明</span><br><span class="line">             * dataType–数据类型</span><br><span class="line">             * paramType–参数类型</span><br><span class="line">             * example–举例说明</span><br><span class="line">             * required–是否必填</span><br><span class="line">             *&#x2F;</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;account&quot;,value&#x3D;&quot;用户名&quot;,dataType&#x3D;&quot;String&quot;, paramType &#x3D; &quot;path&quot;,</span><br><span class="line">            example &#x3D; &quot;username&quot;,required &#x3D; true),</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;password&quot;,value&#x3D;&quot;用户密码&quot;,dataType&#x3D;&quot;String&quot;, paramType &#x3D; 						&quot;path&quot;,example &#x3D; &quot;password&quot;)     </span><br><span class="line">    &#125;)</span><br><span class="line">    public User getUser2(@PathVariable(&quot;account&quot;) String account, </span><br><span class="line">    					@PathVariable(&quot;password&quot;) String password) &#123;</span><br><span class="line">        System.out.println(account+password);</span><br><span class="line">        return new User(account,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h3 id="方式二：使用第三方依赖"><a href="#方式二：使用第三方依赖" class="headerlink" title="方式二：使用第三方依赖"></a>方式二：使用第三方依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/SpringForAll/spring-boot-starter-swagger">github上有配置详情</a></p>
<h2 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h2><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<ul>
<li>bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/16/java/swagger/image-20201016210544771.png" alt="image-20201016210544771"></p>
<ul>
<li>Layui-ui  <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.caspar-chen&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-ui-layer&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注：需注入一个groupName为默认的Docket</p>
<p><img src="/2020/10/16/java/swagger/image-20201016210310198.png" alt="image-20201016210310198"></p>
<ul>
<li>mg-ui  <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.zyplayer&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-mg-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/16/java/swagger/image-20201016202725022.png" alt="image-20201016202725022"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>RK机械键盘快捷键</title>
    <url>/2020/11/15/%E5%85%B6%E4%BB%96/RK%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="Fn-A后："><a href="#Fn-A后：" class="headerlink" title="Fn+A后："></a>Fn+A后：</h1><ul>
<li>Caps Lock = 长按2s后 切换到大写；点按切换中英文</li>
<li>按住shift= 打印大写字母</li>
<li>ctrl + backspace=切换中英文</li>
<li>🔒 + A = 全选</li>
<li>ctrl+ ⬅️ 或者 ➡️ 桌面切换</li>
<li>ctrl+⬇️ 显示当前桌面所有窗口   ===作用等同 F3</li>
<li>ctrl+⬆️ 显示当前桌面所有窗口  ===作用等同 F3</li>
</ul>
<p>FX系列使用说明</p>
<ul>
<li>F1 亮度调暗  </li>
<li>F2 亮度调亮</li>
<li>F3 显示当前桌面所有窗口</li>
<li>F4 启动台</li>
<li>F5 +command  启动旁白</li>
<li>F8 启动苹果音乐</li>
<li>F10 静音</li>
<li>F10 + Alt 或 F11 + Alt 或 F11 + Alt 打开声音配置</li>
<li>F11 降低声音</li>
<li>F12 增加音量</li>
</ul>
<ul>
<li>Fn+SCR LK 切换灯光效果</li>
<li>Fn+A: 切换到mac 键盘 Fn+S: 切换到win键盘</li>
<li>🔒键==command键 alt==option</li>
</ul>
<h1 id="Fn-S后："><a href="#Fn-S后：" class="headerlink" title="Fn+S后："></a>Fn+S后：</h1><ul>
<li>Caps Lock = 长按2s后 切换到大写；点按切换中英文</li>
<li>按住shift= 打印大写字母</li>
<li>ctrl + backspace=切换中英文</li>
<li>ALT + A = 全选</li>
</ul>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>打包vue项目部署到Nginx</title>
    <url>/2020/10/19/%E9%83%A8%E7%BD%B2/%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0nginx/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    <strong>前后端分离，前后端项目往往分开部署，有的甚至部署到不同的服务器，大二的软件工程团队作业项目强后端分离，下面讲下用Nginx部署Vue项目及遇到的坑。</strong></p>
<h2 id="Vue项目打包"><a href="#Vue项目打包" class="headerlink" title="Vue项目打包"></a>Vue项目打包</h2><p><strong>打开命令行进入项目根目录</strong></p>
<p><strong>注：本机需先安装<a href="https://nodejs.org/en/">NodeJS</a></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装项目所需模块</span></span><br><span class="line">npm install </span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">npm run serve</span><br><span class="line"><span class="comment">#打包项目 ,该指令执行后会生成一个dist目录（存放项目的静态文件）</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p><strong>将整个dist目录上传到服务器</strong></p>
<h2 id="Nginx环境搭建"><a href="#Nginx环境搭建" class="headerlink" title="Nginx环境搭建"></a>Nginx环境搭建</h2><p><strong>这里使用docker的Nginx镜像快速搭建。</strong></p>
<p><strong>连接云服务器，命令行输入如下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从Docker Hub查找镜像</span></span><br><span class="line"><span class="comment">#docker search [OPTIONS] TERM</span></span><br><span class="line"><span class="comment">#--automated :只列出 automated build类型的镜像；</span></span><br><span class="line"><span class="comment">#--no-trunc :显示完整的镜像描述；</span></span><br><span class="line"><span class="comment">#-s :列出收藏数不小于指定值的镜像。</span></span><br><span class="line">docker search -s 100 nginx <span class="comment">#从Docker Hub查找所有镜像名包含nginx，并且收藏数大于1000的镜像</span></span><br><span class="line">INDEX       NAME             DESCRIPTION                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/nginx  Official build of Nginx.        13876     [OK]       </span><br><span class="line"><span class="comment">#参数说明：</span></span><br><span class="line"><span class="comment">#NAME: 镜像仓库源的名称</span></span><br><span class="line"><span class="comment">#DESCRIPTION: 镜像的描述</span></span><br><span class="line"><span class="comment">#OFFICIAL: 是否 docker 官方发布</span></span><br><span class="line"><span class="comment">#stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</span></span><br><span class="line"><span class="comment">#AUTOMATED: 自动构建。 </span></span><br><span class="line"></span><br><span class="line">docker pull nginx <span class="comment">#拉取镜像，默认最新版</span></span><br><span class="line"></span><br><span class="line">docker images <span class="comment">#列出本机镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的容器并运行 （--volume , -v: 绑定一个卷，相当于将容器相应路径映射到服务器上）--name=&quot;&quot;: 为容器指定一个名称</span></span><br><span class="line">docker run --name nginx -p 本机端口:容器端口（nginx默认80） -d （后台运行）</span><br><span class="line">-v ……/nginx.conf（服务器配置文件路径）:/etc/nginx/nginx.conf（容器配置文件路径） </span><br><span class="line">-v ……/dist（前端打包文件上传路径）:/usr/share/nginx/html（容器内部目录） nginx:latest （镜像名或id）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p><strong>注：此处若未配置 try_files $uri $uri/ /index.html;项目除根路径外刷新后会直接报404，下面有说明</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ……/nginx.conf(服务器上映射的配置文件)</span><br><span class="line"><span class="comment">#找到80端口的server模块</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  【你的域名或ip】;</span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html; <span class="comment">#根路径</span></span><br><span class="line"><span class="comment">#	    proxy_pass http://127.0.0.1:8080</span></span><br><span class="line">            index  index.html index.htm; <span class="comment">#首页</span></span><br><span class="line">                 </span><br><span class="line">           try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment">#方法1</span></span><br><span class="line">       <span class="comment"># try_files $uri $uri/ =404;</span></span><br><span class="line">	   <span class="comment"># try_files $uri $uri/ @router; #方法2</span></span><br><span class="line">	   <span class="comment">#参数: $uri</span></span><br><span class="line">       <span class="comment">#解释: 表示当前请求的URI(域名后的内容),不带任何参数 例如访问: http://localhost/about</span></span><br><span class="line">       <span class="comment">#$uri: &quot;/about&quot;</span></span><br><span class="line">       <span class="comment">#第一个参数$uri Nginx首先会查找/下有没有名为$uri的文件，本例中为名为demo的文件，如有则将请求传递给$uri</span></span><br><span class="line">       <span class="comment">#第二个参数$uri/ 如找不到名为$uri的文件，Nginx接着会查找/下有没有名为$uri的文件夹，本例中为名为about的文件			夹，如有则将请求传递给$uri/ ，访问该文件夹下的index</span></span><br><span class="line">       <span class="comment"># 第三个参数 </span></span><br><span class="line">       		<span class="comment">#= 404 如前两个参数都无法接收请求 就返回状态码404</span></span><br><span class="line">	   		<span class="comment">#若是路径，则访问，本例是请求http://ip:80/index.html	</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	<span class="comment">#之所以出现刷新404的现象，是因为在nginx配置的根目录 /usr/share/nginx/html下面压根没有&#x27;about/find&#x27;这个真实资源存	在，这些访问资源都是在js里渲染的</span></span><br><span class="line">	<span class="comment">#在服务端nginx配置里添加vue-route的跳转设置</span></span><br><span class="line">	<span class="comment">#location @router &#123;</span></span><br><span class="line">        <span class="comment">#	rewrite ^.*$ /index.html last;</span></span><br><span class="line">   	<span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">	location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>改完后保存退出。</strong></p>
<p><strong>执行docker restart nginx 重启容器后配置生效</strong></p>
<p><strong>到此部署结束</strong></p>
<h3 id="扩展Nginx热加载"><a href="#扩展Nginx热加载" class="headerlink" title="扩展Nginx热加载"></a>扩展Nginx热加载</h3><p><strong>docker exec -it nginx /bin/bash 进入容器，执行 service nginx  reload  按ctrl+P+Q退出容器</strong></p>
<p><strong>或者直接docker exec -i nginx（容器名） service nginx reload （执行命令）</strong></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>bug</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础</title>
    <url>/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    Java编译器输入的指令流基本上是一种基于栈的指令集架构，与之对比的是另外一种基于寄存器的指令集架构。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="基于栈式架构特点："><a href="#基于栈式架构特点：" class="headerlink" title="基于栈式架构特点："></a>基于栈式架构特点：</h4><ol>
<li>设计简单，资源受限等小型系统也适用。</li>
<li>避开寄存器的分配难题，直接使用零地址指令，指令集更小，实现更加简单。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台。</li>
</ol>
<h4 id="基于寄存器架构特点"><a href="#基于寄存器架构特点" class="headerlink" title="基于寄存器架构特点"></a>基于寄存器架构特点</h4><ol>
<li>指令集架构完全依赖硬件，可移植性差。</li>
<li>指令执行更高效，性能更好。</li>
<li>花费更少指令完成一项操作。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于跨平台的设计，java的指令都是根据栈来设计的，不同平台的CPU架构不同，所以不能设计基于寄存器的。基于栈来设计的<strong>优点</strong>是跨平台，指令集小，编译器更容易实现。<strong>缺点</strong>是性能下降，实现同一项操作需要更多指令。</p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>通过引导类加载器（bootstrap class loader）创建一个初始类来完成，一个Jvm启动后就是一个进程。</p>
<p>注：可在命令窗口使用jps指令查看当前进程id</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>执行Java程序，即执行一个叫做java虚拟机的进程。</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ol>
<li>程序执行结束正常退出。</li>
<li>程序执行过程中遇到异常或错误而异常终止。</li>
<li>操作系统出现错误导致JVM进程终止。</li>
<li>程序中执行System.exit(status)或Runtime.getRuntime().halt(status)方法。</li>
<li>除此之外，JNI(Java Native Interface)规范描述了JNI Invocation API来加载或卸载java虚拟机时，java虚拟机退出的情况。</li>
</ol>
<h2 id="字节码执行过程"><a href="#字节码执行过程" class="headerlink" title="字节码执行过程"></a>字节码执行过程</h2><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/1.png" alt="jvm整体架构"></p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>​    负责将字节码文件即class文件加载到JVM中，加载的类信息将存储于JVM运行时数据区的方法区中。（除类信息外，方法区还存放运行时的常量池信息等）</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/2.png" alt="image-20201115151642295"></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过类的全限定类名获取此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>1.验证（Verify）</p>
<p>目的：保证Class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性以及虚拟机自身安全。</p>
<ul>
<li>​    文件格式验证</li>
<li>​    元数据验证</li>
<li>​    字节码验证</li>
<li>​    符号引用验证</li>
</ul>
<p>2.准备（Prepare）</p>
<p>​    为类变量（静态属性）分配内存并设置默认初始值，即零值。</p>
<p>注：</p>
<ul>
<li>final修饰的static除外，因为final在编译的时候就分配了，准备阶段会显式初始化。</li>
<li>实例变量（普通属性）不会被分配初始化，类变量会被分配在方法区中，而实例变量会随java对象一起分配在堆中。</li>
</ul>
<p>3.解析(Pesolve)</p>
<p>​    将常量池的符号引用转换为直接引用（直接引用就是直接指向目标的指针，相对偏移量或间接定位到目标的句柄）。主要针对的是类的接口、字段、类方法、接口方法、方法类型等。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>本质：就是执行类构造方法<clinit>()的过程。</clinit></li>
<li>此方法不需要定义，javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句。</li>
<li>指令的执行顺序会按代码在源文件出现的顺序执行。</li>
<li>若该类有父类，JVM会先加载并执行完父类的<clinit>()方法。<clinit>()方法在多线程下是被同步加锁的。</clinit></clinit></li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>注：所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器（User-Defined ClassLoader）（即只有Bootstrap 不是）。</p>
<h4 id="引导（启动）类加载器（Bootstrap-ClassLoader）"><a href="#引导（启动）类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导（启动）类加载器（Bootstrap ClassLoader）"></a>引导（启动）类加载器（Bootstrap ClassLoader）</h4><ol>
<li>由C/C++语言实现，嵌套在JVM内部。</li>
<li>用来加载Java核心库（JAVA_HOME/jre/lib/rt.jar、resourse.jar或sun.boot.class.path路径下的内容），提供JVM自身所需类。</li>
<li>并不继承自java.lang.ClassLoader,没有父加载器，加载扩展类加载器并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动加载器只加载包名为java、javax、sun等开头的类。</li>
</ol>
<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><ol>
<li>Java语言编写，由sun.mis.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader类，父类加载器为Bootsrap ClassLoader 。</li>
<li>从java.ext.dirs系统属性所加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR包放在此目录下，也会自动由扩展类加载器加载。</li>
</ol>
<h4 id="系统类（应用程序类）加载器（AppClassLoader）"><a href="#系统类（应用程序类）加载器（AppClassLoader）" class="headerlink" title="系统类（应用程序类）加载器（AppClassLoader）"></a>系统类（应用程序类）加载器（AppClassLoader）</h4><ol>
<li>Java语言编写，由sun.mis.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader类，父类加载器为Bootsrap ClassLoader 。</li>
<li>负责加载类环境变量classpath或系统属性 java.class.path 指定路径下的类库</li>
<li>程序中的默认加载器，一般来说，Java应用类都是由它来完成加载</li>
<li>可以通过ClassLoader.getSystemClassLoader()方法获取</li>
</ol>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ol>
<li>作用：隔离加载类、修改加载方式、扩展加载源、防止源码泄露。</li>
<li>实现：可继承java.lang.ClassLoader或java.net.URLClassLoader类实现自己的类加载器，</li>
</ol>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>一个加载器收到类加载请求，不会自己先去加载，而是先将请求委托给父类的加载器去执行，若父类加载器还有其父类加载器，则进一步向上委托，依次递归到启动类加载器，父类加载器可以加载则成功返回，无法加载则子类再去加载。</p>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a><strong>优势：</strong></h4><p>避免类重复加载，保护程序安全，防止核心API被随意算改</p>
<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>​    如我们在程序中自己定义了一个 String 类，但是加载自定义 String 类的时候会先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 java\lang\String.class），这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    又称PC计数器、指令计数器，程序钩子。JVM的PC寄存器是对物理PC寄存器的抽象模拟。占用内存少，几乎可忽略不记，运行速度最快的存储区域。在JVM规范中，<strong>每个线程独享一个程序计数器</strong>，生命周期与线程一致。任何时期每个线程都只有一个方法在执行，也就是当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是正在执行本地方法，则是未指定值（undefned）。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</li>
<li>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时需要通过计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>
<h3 id="虚拟机栈-JVM-Stacks"><a href="#虚拟机栈-JVM-Stacks" class="headerlink" title="虚拟机栈(JVM Stacks)"></a>虚拟机栈(JVM Stacks)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，<strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。生命周期与线程一致。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM对Java的栈操作只有两个：进栈（入栈、压栈）【方法执行】，出栈【方法结束】。</li>
<li><strong>栈不存在垃圾回收问题。</strong></li>
</ol>
<h4 id="可能存在异常"><a href="#可能存在异常" class="headerlink" title="可能存在异常"></a>可能存在异常</h4><ul>
<li>栈大小固定：StackOverflowError</li>
<li>栈大小可动态扩展：OutOfMemoryError</li>
</ul>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ul>
<li><h5 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h5></li>
</ul>
<p>又称局部变量数组或本地变量表，定义为一个数字数组，主要存储方法参数和定义在方法体内的局部变量【基本数据类型、对象引用、以及returnAddress类型】，局部变量表是建立在线程栈上的，线程私有，不存在数据安全问题，表容量大小是编译期确定下来，最基本单位是slot（变量槽）32位以内类型占一个slot，64位类型占两个。</p>
<p><strong>注：若当前帧是由构造方法或实例方法创建的，那么该栈帧的slot的index=0存放的是该对象的引用—this</strong></p>
<ul>
<li><h5 id="操作数栈-Operand-Stack-或-表达式栈"><a href="#操作数栈-Operand-Stack-或-表达式栈" class="headerlink" title="操作数栈(Operand Stack)(或 表达式栈)"></a>操作数栈(Operand Stack)(或 表达式栈)</h5></li>
</ul>
<p>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。主要用于保存计算过程的中间结果。其栈深度在编译期就定义好，保存在方法的Code属性中，为max_stack的值。32位占一个、64位占两个单位的栈深度。</p>
<p>栈顶缓存（Top-of-Stack Cashing）技术：将栈顶元素全部缓存在物理cpc的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</p>
<ul>
<li><h5 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h5></li>
</ul>
<p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用。动态链接就是将变量和方法的引用转换为调用方法的直接引用</p>
<ul>
<li><h5 id="方法返回值-Return-Address-（或方法退出或异常退出的定义）"><a href="#方法返回值-Return-Address-（或方法退出或异常退出的定义）" class="headerlink" title="方法返回值(Return Address)（或方法退出或异常退出的定义）"></a>方法返回值(Return Address)（或方法退出或异常退出的定义）</h5></li>
</ul>
<p>正常退出：调用者的pc计数器的值作为返回地址，即调用该方法的下一条指令地址。</p>
<p>异常退出：异常表来确定。</p>
<p>区别：异常退出的不会给他的上层调用者产生任何返回值。</p>
<ul>
<li><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5></li>
</ul>
<p>对程序调试提供支持的信息</p>
<h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h3><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域（最大的内存空间），堆可以在物理上不连续，但在逻辑上它应该被视为连续的，<strong>堆区域是所有线程共享的</strong>，但也有划分出线程私有的缓存区Thread Local Allocation Biffer（TLAB，解决指针冲突）。</p>
<p>可细分为新生区和养老区；</p>
<p>新生区又可细分为Eden，Survivor0，Survivor1三个空间 （也称Eden, from, to）， 官网说默认比例是8:1:1 。</p>
<p>实际操作发现并不是，需关闭自适应内存分配策略：-XX:-UseAdaptiveSizePolicy，或直接通过-XX:SurvivorRatio=8调整此比例</p>
<h4 id="设置堆空间新生代和老年代占比"><a href="#设置堆空间新生代和老年代占比" class="headerlink" title="设置堆空间新生代和老年代占比"></a>设置堆空间新生代和老年代占比</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:NewRatio= <span class="comment">#设置新生代和老年代空间占比，默认2</span></span><br><span class="line">-XX:NewRatio=2 <span class="comment">#表示新生代占1，老年代占2，新生代占整个堆空间的1/3</span></span><br><span class="line">-XX:NewRatio=4 <span class="comment">#表示新生代占1，老年代占4，新生代占整个堆空间的1/5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行查看此参数</span></span><br><span class="line">&gt;jinfo -flag NewRatio 【进程id】</span><br><span class="line">-XX:NewRatio=2</span><br></pre></td></tr></table></figure>



<p>idea可直接在Run-&gt;Eidt Configurations-&gt;VM options里设置（注：设置多个时用空格隔开）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-X 是jvm的运行参数 m是memory， s是start， x是max</span></span><br><span class="line"><span class="comment">#官网建议： For server deployments, -Xms and -Xmx are often set to the same value.</span></span><br><span class="line">-Xms300m <span class="comment">#设置堆空间（年轻代+老年代）的初始内存大小300M ,单位不指定默认字节（k,m,g）</span></span><br><span class="line">-Xmx300m <span class="comment">#设置堆空间（年轻代+老年代）的最大内存大小300M</span></span><br><span class="line"><span class="comment">#不设置默认值：初始内存大小=物理电脑内存/64，最大内存大小=物理电脑内存/4</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">#控制台打印相关参数</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsInitial <span class="comment">#查看所有参数的默认值（就算有指定，也显示默认值）</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsFinal <span class="comment">#查看所有参数的最终值</span></span><br><span class="line"><span class="comment">#具体查看某个参数指令：命令行输入 </span></span><br><span class="line"><span class="comment">#jps #查看进程id</span></span><br><span class="line"><span class="comment">#jinfo -flag 参数 进程id</span></span><br><span class="line">如：</span><br><span class="line">&gt;jps</span><br><span class="line">2932 Jps</span><br><span class="line">6628</span><br><span class="line">11944 Launcher</span><br><span class="line">12952 RemoteMavenServer</span><br><span class="line">13096 Launcher</span><br><span class="line">6392 Launcher</span><br><span class="line">&gt;jinfo -flag SurvivorRatio 13096</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line"></span><br><span class="line">-Xmn <span class="comment">#设置新生代大小</span></span><br><span class="line"></span><br><span class="line">-XX:NewRatio <span class="comment">#配置新生代与老年代在堆中占比</span></span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio <span class="comment">#设置新生代中Eden和s0/s1空间比例</span></span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold <span class="comment">#设置新生代垃圾最大年龄 （默认15岁进入老年代）</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">#输出详细的Gc处理日志</span></span><br><span class="line"><span class="comment">#打印GC简要信息 -XX:+PrintGC 或 -verbose:gc</span></span><br><span class="line"></span><br><span class="line">-XX:HandlePromotionFailure <span class="comment">#是否设置空间分配担保</span></span><br></pre></td></tr></table></figure>



<h4 id="命令行查看运行参数"><a href="#命令行查看运行参数" class="headerlink" title="命令行查看运行参数"></a>命令行查看运行参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstat -gc 【进程id】 【打印间隔时间单位（秒或毫秒），不指定默认毫秒】(不写只打印一次)<span class="comment">#查看进程GC情况</span></span><br><span class="line"></span><br><span class="line">&gt;jstat -gc 48476</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC …… </span><br><span class="line">7680.0 1024.0  0.0   768.0  63488.0  34050.8   70656.0     5471.6   24064.0 23307.3 2816.0 2640.8  5…… </span><br></pre></td></tr></table></figure>



<h4 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h4><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/image-20201115210033571.png" alt="image-20201115210033571"></p>
<h5 id="STW（Stop-The-World）："><a href="#STW（Stop-The-World）：" class="headerlink" title="STW（Stop The World）："></a>STW（Stop The World）：</h5><p>​    指在进行垃圾回收时，暂停其它用户线程，等垃圾回收结束，用户线程才能恢复运行。</p>
<h5 id="新生代收集MinorGC（Young-GC）"><a href="#新生代收集MinorGC（Young-GC）" class="headerlink" title="新生代收集MinorGC（Young GC）"></a>新生代收集MinorGC（Young GC）</h5><p>清理年轻代的内存，Survivor中基数达到15的对象移至老年代，当年轻代Eden空间满时触发，Survuivor满不会触发GC</p>
<h5 id="老年代收集MajorGC-Old-GC"><a href="#老年代收集MajorGC-Old-GC" class="headerlink" title="老年代收集MajorGC(Old GC)"></a>老年代收集MajorGC(Old GC)</h5><p>目前只有CMS GC会有单独收集老年代的行为，很多时候Major GC会和Full GC混合使用。Major GC的速度一般会比Minor GC慢10倍以上。STW更长</p>
<p>Major GC经常会胖随至少一次Minor  GC，若Major GC后内存还不足，就直接报OOM。</p>
<h5 id="混合收集（Mixed-GC）"><a href="#混合收集（Mixed-GC）" class="headerlink" title="混合收集（Mixed GC）"></a>混合收集（Mixed GC）</h5><p>目前只有G1 GC会有这种行为。</p>
<h5 id="整堆收集FullGC"><a href="#整堆收集FullGC" class="headerlink" title="整堆收集FullGC"></a>整堆收集FullGC</h5><p>收集整个java堆和方法区的垃圾。</p>
<p>触发条件：</p>
<ol>
<li>调用System.gc(),系统建议执行，但不是必须执行。</li>
<li>老年代空间不足。</li>
<li>方法区空间不足。</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</li>
</ol>
<h3 id="方法区-Metaspace"><a href="#方法区-Metaspace" class="headerlink" title="方法区(Metaspace)"></a>方法区(Metaspace)</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>方法区是线程共享的，jdk7以前永久代实现，jdk8后改为元空间（Metaspace ）使用本地内存。存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><a href="https://blog.csdn.net/duoyu779553/article/details/105878755/">参考链接</a></p>
<p><a href="https://blog.csdn.net/qingtiantianqing/article/details/51405517">参考链接</a></p>
<h2 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h2><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
<p><a href="https://www.hollischuang.com/archives/2398">参考链接</a></p>
<p><a href="https://blog.csdn.net/hollis_chuang/article/details/80922794">参考链接2</a></p>
<p>jdk1.7后默认开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis #开启方法逃逸</span><br><span class="line">-XX:-DoEscapeAnalysis #关闭方法逃逸</span><br></pre></td></tr></table></figure>



<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>一、<strong>为什么要字节码，用不同平台虚拟机直接将java代码编译成对应指令集不就行？</strong></p>
<ol>
<li>准备工作：（源代码———&gt; 机器码）每次执行都需要检查语法和语义检查，每次执行语义分析的结果都不会被保留下来，都要重新编译，重新去分析，整体性能会受到影响，做很多重复的事情，因此引出中间字节码，保证一次编译，多次运行时不需要重复校验。</li>
<li>兼容性：也可以将别的语言解析成字节码，例如scala，生成字节码同样也可以被JVM调用执行，提高平台兼容扩展能力，符合软件设计的中庸之道。</li>
</ol>
<p>二、<strong>堆是内存分配对象的唯一选择码？</strong></p>
<p>　    随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。<br>　　在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。<br>　　此外，基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (Gcinvisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且Gc不能管理GCIH内部的Java对象，以此达到降低Gc的回收频率和提升GC的回收效率的目的。</p>
<p>注：《深入理解Java虚拟机》</p>
<p>三、 <strong>什么是解释器（Interpreter），什么是即时编译器(JIT)</strong></p>
<p>​    <strong>解释器：</strong>当java虚拟机启动时，会根据预定义的规范对字节码文件进行逐行解释的方式执行。每条指令都会被翻译成机械指令执行。</p>
<p>​    <strong>JIT（Just In Time）编译器：</strong>虚拟机直接将源码转换成可以直接发送给处理器的指令的程序。</p>
<p>四、 <strong>为什么说java是半编译半解释型语言</strong></p>
<ol>
<li>jdk1.0时代，java虚拟机的执行引擎只用解释器将字节码逐行翻译成机械指令执行，效率较慢，此时可算解释型语言。</li>
<li>现在虚拟机的执行引擎里有JIT编译器，可直接将方法编译成机械码后再执行，通常两者会结合使用，所以说java是半编译半解释型语言。</li>
</ol>
<p>五、<strong>JIT比解释器快，为啥不直接只使用JIT</strong></p>
<p>​    虚拟机刚启动时，解释器可以先发挥作用（表现为启动时响应用户更快），即时编译器全部编译完再执行，需要一定时间等待。随着时间的推移，即时编译器逐渐发挥作用，利用热点探测功能， 将有价值的字节码编译成本地机械指令，以换取更高的之心效率。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaNIO</title>
    <url>/2020/10/10/java/JavaNIO/</url>
    <content><![CDATA[<h2 id="Java共支持3种网络编程模型-IO模式：BIO、NIO、AIO"><a href="#Java共支持3种网络编程模型-IO模式：BIO、NIO、AIO" class="headerlink" title="Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO"></a>Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</h2><ol>
<li><p>​    Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端 有连接请求时服务器端就需要启动一个线程    进行处理，如果这个连接不做任何事情会造成 不必要的线程开销 。</p>
</li>
<li><p>​    Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发 送的连接请求都会注册到多路复用器上，多</p>
<p> ​    路复用器轮询到连接有I/O请求就进行处理 。</p>
</li>
<li><p>​     Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简 化了程序编写，有效的请求才启动线程，</p>
<p> ​    它的特点是先由操作系统完成后才通知服务端程。</p>
</li>
</ol>
<h2 id="I-O模型-BIO、NIO、AIO适用场景分析"><a href="#I-O模型-BIO、NIO、AIO适用场景分析" class="headerlink" title="I/O模型 BIO、NIO、AIO适用场景分析"></a>I/O模型 BIO、NIO、AIO适用场景分析</h2><ol>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕 系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分 调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ol>
<h2 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h2><p>Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io 2) BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连 接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。 </p>
<p> BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p>
<h3 id="BIO编程简单流程"><a href="#BIO编程简单流程" class="headerlink" title="BIO编程简单流程"></a>BIO编程简单流程</h3><ol>
<li>服务器端启动一个ServerSocket</li>
<li>客户端启动Socket对服务器进行通 信，默认情况下服务器端需要对每 个客户 建立一个线程与之通讯</li>
<li>客户端发出请求后, 先咨询服务器 是否有线程响应，如果没有则会等 待，或者被拒绝</li>
<li>如果有响应，客户端线程会等待请 求结束后，在继续执行</li>
</ol>
<h4 id="Java-BIO-问题分析"><a href="#Java-BIO-问题分析" class="headerlink" title="Java BIO 问题分析"></a>Java BIO 问题分析</h4><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占 用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</li>
</ol>
<h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol>
<li>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</li>
<li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</li>
<li>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) 4) NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个 它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就 增加了处理过程中的灵活性，使用它可以提供非阻塞式的高 伸缩性网络。</li>
<li>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得 到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线 程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞 写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。</li>
<li>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来, 根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分 配10000个。</li>
<li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求 的数量比HTTP1.1大了好几个数量级。</li>
</ol>
<h3 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h3><ol>
<li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多 。</li>
<li>BIO 是阻塞的，NIO 则是非阻塞的。</li>
<li>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 </li>
</ol>
<h3 id="NIO-三大核心关系"><a href="#NIO-三大核心关系" class="headerlink" title="NIO 三大核心关系"></a>NIO 三大核心关系</h3><p>​    <strong>Selector 、 Channel 和 Buffer</strong></p>
<ol>
<li><p>每个channel 都会对应一个Buffer </p>
</li>
<li><p>Selector 对应一个线程， 一个线程对应多个channel(连接) </p>
</li>
<li><p>该图反应了有三个channel 注册到 该selector //程序 </p>
</li>
<li><p>程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念 </p>
</li>
<li><p>Selector 会根据不同的事件，在各个通道上切换 </p>
</li>
<li><p>Buffer 就是一个内存块 ， 底层是有一个数组 </p>
</li>
<li><p>数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是 输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换 </p>
</li>
<li><p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统 通道就是双向的.</p>
</li>
</ol>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个 容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对 象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>BIO 中的 stream 是单向的，例如 FileInputStream 对 象只能进行读取数据的操作，而 NIO 中的通道 (Channel)是双向的，可以读操作，也可以写操作。</li>
<li>Channel在NIO中是一个接口 public interface Channel extends Closeable{} 。</li>
<li>常用的 Channel 类有：FileChannel、 DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li>
<li>FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</li>
<li>NIO的通道类似于流，但有些区别如下：</li>
</ol>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写。</li>
<li>通道可以实现异步读写数据。</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲。</li>
</ul>
<h3 id="关于Buffer-和-Channel的注意事项和细节"><a href="#关于Buffer-和-Channel的注意事项和细节" class="headerlink" title="关于Buffer 和 Channel的注意事项和细节"></a>关于Buffer 和 Channel的注意事项和细节</h3><ol>
<li>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</li>
<li>可以将一个普通Buffer 转成只读Buffer 。</li>
<li>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成。</li>
<li>前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</li>
</ol>
<h3 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a>Selector(选择器)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)。</li>
<li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以 事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</li>
<li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少 了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 4) 避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类 似Socket。</p>
</li>
<li><p>注册进Select的Channel必须是非阻塞的，所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socketchannel可以正常使用。</p>
</li>
<li><p>selector 相关方法说明：</p>
<p> ​    selector.select()//阻塞 </p>
<p> ​    selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回 </p>
<p> ​    selector.wakeup();//唤醒selector </p>
<p> ​    selector.selectNow();//不阻塞，立马返还</p>
</li>
</ol>
<h3 id="NIO写入文件代码示例"><a href="#NIO写入文件代码示例" class="headerlink" title="NIO写入文件代码示例"></a>NIO写入文件代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是  FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对byteBuffer 进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="NIO聊天室代码示例"><a href="#NIO聊天室代码示例" class="headerlink" title="NIO聊天室代码示例"></a>NIO聊天室代码示例</h3><p>Server端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel =  ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;<span class="comment">//有事件处理</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//遍历得到selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出selectionkey</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable()) &#123; <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line"></span><br><span class="line">                            readData(key);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Client端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有可以用的通道...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个线程, 读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        Thread.currentThread().sleep(3000);</span></span><br><span class="line"><span class="comment">//                    &#125;catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol>
<li>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式： Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得 到通知，进行相应的处理 。</li>
<li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作 系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时 间较长的应用。</li>
</ol>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>注：笔记参考自尚硅谷-韩顺平的Netty相关教程</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ入门</title>
    <url>/2020/09/25/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/rabbitMq/</url>
    <content><![CDATA[<h2 id="消息中间件（MQ）"><a href="#消息中间件（MQ）" class="headerlink" title="消息中间件（MQ）"></a>消息中间件（MQ）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。——百度百科</p>
<p>​    MQ全称为Message Queue，消息队列是程序和程序之间的通信方法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>实现项目通讯与解耦   </li>
</ul>
<p>MQ相当于一个中介，消息生产方将消息发给MQ，消息消费方接收消息并进行相应逻辑处理，它将两应用程序进行解耦合。</p>
<ul>
<li>处理异步任务</li>
</ul>
<p>​        在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<ul>
<li>   削峰填谷</li>
</ul>
<p>  如订单抢票系统，开始抢票瞬间高请求，高并发，若此时都操作数据库，需要大量IO操作，消耗系统性能，系统很可能崩溃，我们可以先将订单存消息队列里，然后系统就可以避开高峰期再按照自己的消费能力消费消息队列里的消息。</p>
<h2 id="主流实现方式"><a href="#主流实现方式" class="headerlink" title="主流实现方式"></a>主流实现方式</h2><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>​    AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF/1619218">消息</a>队列协议，是<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788">应用层</a>协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240">中间件</a>不同产品，不同的开发语言等条件的限制。<a href="https://baike.baidu.com/item/Erlang">Erlang</a>中的实现有<a href="https://baike.baidu.com/item/RabbitMQ">RabbitMQ</a>等。                                                                                                                               ——百度百科</p>
<p>AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>​    JMS即Java消息服务（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/5899771">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中发送消息，进行<a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/2273903">异步通信</a>。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。                                                                                                                                                                                                    ——百度百科</p>
<h3 id="AMQP-与-JMS-区别"><a href="#AMQP-与-JMS-区别" class="headerlink" title="AMQP 与 JMS 区别"></a>AMQP 与 JMS 区别</h3><ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li>
</ul>
<h3 id="常见的消息队列"><a href="#常见的消息队列" class="headerlink" title="常见的消息队列"></a>常见的消息队列</h3><ul>
<li>ActiveMQ：基于JMS</li>
<li>ZeroMQ：基于C语言开发</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品</li>
<li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a href="http://www.rabbitmq.com/">官网</a></p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/%E5%BA%93">库</a>。        ——百度百科</p>
<h3 id="6种模式"><a href="#6种模式" class="headerlink" title="6种模式"></a>6种模式</h3><ul>
<li><p>简单模式：一个生产者发送消息到队列,一个消费者接收，不需要设置交换机（使用默认的交换机）</p>
</li>
<li><p>work工作队列模式，一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者竞争同一个队列的消息</p>
</li>
<li><p>Publish/Subscribe发布与订阅模式：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者</p>
</li>
<li><p>Routing路由模式（direct模式）：生产者发送消息到交换机并且要指定路由key，消费者将队列绑定到交换机时需要指定路由key</p>
</li>
<li><p>Topics通配符模式:  生产者发送消息到交换机，交换机类型设置topic，交换机根据绑定队列的routing key的值进行通配符匹配，</p>
<p>  “#”：匹配零个或者多个词topic.# 可以匹配topic，topic.text，topic.test.queue</p>
<p>  “<em>“：匹配l零个或一个词，topic.</em> 可以匹配topic，topic.text或topic.queue</p>
</li>
<li><p>RPC远程调用模式：功能如名，调用远程项目的功能并等待结果。</p>
</li>
</ul>
<h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><h4 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a><strong>maven坐标</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="java代码示例"><a href="#java代码示例" class="headerlink" title="java代码示例"></a>java代码示例</h4><p>注：这里以direct模式示例，其他模式类似</p>
<h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置Rabbitmq主机地址,默认localhost</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//设置端口,默认5672</span></span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line"><span class="comment">//设置虚拟主机，默认 /</span></span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line"><span class="comment">//连接密码；默认为guest</span></span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//通过连接工厂创建连接</span></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">// 通过connection创建一个Channel通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的信息</span></span><br><span class="line">String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">				.deliveryMode(<span class="number">2</span>)<span class="comment">//2消息持久化；1重启消息丢失</span></span><br><span class="line">				.contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">				.expiration(<span class="string">&quot;10000&quot;</span>)<span class="comment">//十秒失效</span></span><br><span class="line">				.headers(headers)</span><br><span class="line">				.build();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span></span><br><span class="line"><span class="comment">* 参数2：路由key,简单模式可以传递队列名称</span></span><br><span class="line"><span class="comment">* 参数3：消息其它属性</span></span><br><span class="line"><span class="comment">* 参数4：消息内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;test_direct_exchange&quot;</span>, <span class="string">&quot;test.direct&quot;</span>, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory() ;  </span><br><span class="line"></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//自动恢复连接</span></span><br><span class="line">connectionFactory.setAutomaticRecoveryEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//自动恢复在尝试重新连接之前要等待多长时间，默认5000ms</span></span><br><span class="line">connectionFactory.setNetworkRecoveryInterval(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">Channel channel = connection.createChannel();  </span><br><span class="line"><span class="comment">//4 声明</span></span><br><span class="line">String exchangeName = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line">String exchangeType = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">String queueName = <span class="string">&quot;test_direct_queue&quot;</span>;</span><br><span class="line">String routingKey = <span class="string">&quot;test.direct&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示声明了一个交换机</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, exchangeType, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 声明（创建）队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：队列名称</span></span><br><span class="line"><span class="comment">* 参数2：是否持久化队列</span></span><br><span class="line"><span class="comment">* 参数3：是否独占连接</span></span><br><span class="line"><span class="comment">* 参数4：是否在不使用的时候自动删除队列</span></span><br><span class="line"><span class="comment">* 参数5：队列其它参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//建立一个绑定关系:</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//durable 是否持久化消息</span></span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//参数：队列名称、是否自动ACK、Consumer</span></span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"><span class="comment">//循环获取消息  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">    <span class="comment">//获取消息，如果没有消息，这一步将会一直阻塞  </span></span><br><span class="line">    Delivery delivery = consumer.nextDelivery();  </span><br><span class="line">    String msg = <span class="keyword">new</span> String(delivery.getBody());    </span><br><span class="line">    System.out.println(<span class="string">&quot;收到消息：&quot;</span> + msg);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="用xml配置方式与spring整合"><a href="#用xml配置方式与spring整合" class="headerlink" title="用xml配置方式与spring整合"></a>用xml配置方式与spring整合</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><h5 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h5><p>注：以下配置rabbitMQ可靠性投递用到，消息的延迟投递，做二次确认，回调检查</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入spring配置文件 ，便于下方配置变量引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:application.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 创建连接类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;rabbitmqConnectionFactory&quot;  class=&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg value=&quot;localhost&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的账户,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;username&quot; value=&quot;$&#123;rmq.manager.user&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的密码,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;password&quot; value=&quot;$&#123;rmq.manager.password&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- host,RabbitMQ服务器地址，默认值&quot;localhost&quot; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;host&quot; value=&quot;$&#123;rmq.ip&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- port，RabbitMQ服务端口，默认值为5672 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;port&quot; value=&quot;$&#123;rmq.port&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- channel-cache-size，channel的缓存数量，默认值为25 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;channel-cache-size&quot; value=&quot;50&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--cache-mode，缓存连接模式，默认值为CHANNEL(单个connection连接，连接之后关闭，自动销毁) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;cache-mode&quot; value=&quot;CHANNEL&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--或者这样配置，connection-factory元素实际就是注册一个org.springframework.amqp.rabbit.connection.CachingConnectionFactory实例--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;$&#123;rmq.ip&#125;&quot;</span> <span class="attr">port</span>=<span class="string">&quot;$&#123;rmq.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    							<span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;rmq.manager.virtual&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;$&#123;rmq.manager.user&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;$&#123;rmq.manager.password&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span> <span class="attr">publisher-returns</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--注：publisher-confirms=&quot;true&quot; publisher-returns=&quot;true&quot;用于开启消息投递的回调监听，若想使用必须配置--&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产者部分 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发送消息的producer类，也就是生产者 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;RabbitmqProduct&quot;</span> <span class="attr">class</span>=<span class="string">&quot;生产者类路径&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--routingKey的 value中的值就是producer中的的routingKey，它与上面的rabbit:bindings标签中的key必须相同 -&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;exchange&quot; value=&quot;$&#123;rmq.manager.exchange&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;routingKey&quot; value=&quot;$&#123;rmq.manager.routingKey&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;delayKey&quot; value=&quot;$&#123;rmq.manager.key_delay&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;rabbitTemplate&quot; ref=&quot;rabbitTemplate&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;!-- spring amqp默认的是jackson 的一个插件,目的将生产者生产的数据转换为json存入消息队列，由于fastjson的速度快于jackson,这里替换为fastjson的一个实现 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;jsonMessageConverter&quot; class=&quot;com.jy.utils.FastJsonMessageConverter&quot;&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或者配置jackson --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--消息成功投递后回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--消息找不到对应交换机或routingkey，投递失败回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--exchange=&quot;Anyview_exchange&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span>  <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">confirm-callback</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">return-callback</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">mandatory</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费者部分 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义消息队列,durable:是否持久化，</span></span><br><span class="line"><span class="comment">    如果想在RabbitMQ退出或崩溃的时候，不会失去所有的queue和消息，需要同时标志队列(queue)和交换机(exchange)是持久化的，	即rabbit:queue标签和rabbit:direct-exchange中的durable=true,而消息(message)默认是持久化的可以看类			org.springframework.amqp.core.MessageProperties中的属性</span></span><br><span class="line"><span class="comment">	public static final MessageDeliveryMode DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span></span><br><span class="line"><span class="comment">    exclusive: 仅创建者可以使用的私有队列，断开后自动删除；</span></span><br><span class="line"><span class="comment">    auto_delete: 当所有消费客户端连接断开后，是否自动删除队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--延时队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_delay&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  队列过期时间 10秒--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;java.lang.Long&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过期后消息将通过以下交换机和routingkey发送到死信队列--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-routing-key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--绑定队列,</span></span><br><span class="line"><span class="comment">rabbitmq的exchangeType常用的三种模式：direct，fanout，topic三种,</span></span><br><span class="line"><span class="comment">我们用direct模式，即rabbit:direct-exchange标签，Direct交换器很简单，</span></span><br><span class="line"><span class="comment">如果是Direct类型，就会将消息中的RoutingKey与该Exchange关联的所有Binding中的BindingKey进行比较，</span></span><br><span class="line"><span class="comment">如果相等，则发送到该Binding对应的Queue中。有一个需要注意的地方：如果找不到指定的exchange，就会报错。</span></span><br><span class="line"><span class="comment">但routing key找不到的话，不会报错，这条消息会直接丢失，所以此处要小心,</span></span><br><span class="line"><span class="comment">auto-delete:自动删除，如果为Yes，则该交换机所有队列queue删除后，自动删除交换机，默认为false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.routingKey&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_delay&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--死信队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange_dead&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于消息的监听的代理类MessageListenerAdapter --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;testQueueListenerAdapter&quot; class=&quot;org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter&quot; &gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg ref=&quot;Handler&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;defaultListenerMethod&quot; value=&quot;handlerTest&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;messageConverter&quot; ref=&quot;jsonMessageConverter&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;rabbit:direct-exchange id=&quot;$&#123;rmq.manager.exchange&#125;&quot; name=&quot;$&#123;rmq.manager.exchange&#125;&quot;  durable=&quot;false&quot; auto-delete=&quot;false&quot; &gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;/rabbit:direct-exchange&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义接口类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Handler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;消息类路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置监听acknowledeg=&quot;manual&quot;设置手动应答，它能够保证即使在一个worker处理消息的时候用CTRL+C来杀掉这个		worker，或者一个consumer挂了(channel关闭了、connection关闭了或者TCP连接断了)，也不会丢失消息。</span></span><br><span class="line"><span class="comment">    因为RabbitMQ知道没发送ack确认消息导致这个消息没有被完全处理，将会对这条消息做re-queue处理。</span></span><br><span class="line"><span class="comment">    如果此时有另一个consumer连接，消息会被重新发送至另一个consumer会一直重发,直到消息处理成功,</span></span><br><span class="line"><span class="comment">    监听容器acknowledge=&quot;auto&quot; concurrency=&quot;30&quot;设置发送次数,最多发送30次 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--concurrency=&quot;20&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Handler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="keyword">private</span> String routingKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String delayKey;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*此服务用于将消息持久化</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"> 	<span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rabbitmq发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketMsg 消息实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isFirst 是否第一次发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(SocketMsg socketMsg, <span class="keyword">boolean</span> isFirst)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次发送前先持久化</span></span><br><span class="line">        <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">            socketMsgService.insert(socketMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CorrelationData消息唯一ID</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object jsonSocketMsg = JSON.toJSON(socketMsg);</span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,routingKey, jsonSocketMsg, </span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()));</span><br><span class="line">            <span class="comment">//发送到延时队列</span></span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,delayKey, jsonSocketMsg,</span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()+<span class="string">&quot;delay&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExchange</span><span class="params">(String exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoutingKey</span><span class="params">(String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayKey</span><span class="params">(String delayKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayKey = delayKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="延时队列消费者代码"><a href="#延时队列消费者代码" class="headerlink" title="延时队列消费者代码"></a>延时队列消费者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitmqProduct rabbitmqProduct;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        Object parse = JSONObject.parse(message.getBody());</span><br><span class="line">        log.info(parse.toString());</span><br><span class="line">        SocketMsg socketMsg = JSONObject.parseObject(message.getBody(), SocketMsg.class);</span><br><span class="line">        log.info(socketMsg.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息未成功投递</span></span><br><span class="line">        <span class="keyword">if</span>(socketMsgService.findById(socketMsg.getId()).getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//未超过重试次数</span></span><br><span class="line">            <span class="keyword">if</span> (socketMsgService.getTryCountById(socketMsg.getId()) &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//添加重试次数</span></span><br><span class="line">                socketMsgService.addTryCountById(socketMsg.getId());</span><br><span class="line">                rabbitmqProduct.sendMessage(socketMsg, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="投递成功回调类"><a href="#投递成功回调类" class="headerlink" title="投递成功回调类"></a>投递成功回调类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;confirmCallBackListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallBackListener</span> <span class="keyword">implements</span> <span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;################发送到exchange成功:&quot;</span>+correlationData);</span><br><span class="line">            <span class="comment">//非延时队列的消息确认</span></span><br><span class="line">            <span class="keyword">if</span> (!correlationData.getId().endsWith(<span class="string">&quot;delay&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//将数据库消息标志置为成功发送</span></span><br><span class="line">                socketMsgService.succeedSendById(Long.parseLong(correlationData.getId()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;#########发送失败:&quot;</span>+correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="投递失败回调类"><a href="#投递失败回调类" class="headerlink" title="投递失败回调类"></a>投递失败回调类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallBackListener</span> <span class="keyword">implements</span> <span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, </span></span></span><br><span class="line"><span class="function"><span class="params">                                String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;无对应key队列，发送失败了&quot;</span>+message);</span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><h5 id="配置与上面延时队列的消息接收方类似，此处不再累赘"><a href="#配置与上面延时队列的消息接收方类似，此处不再累赘" class="headerlink" title="配置与上面延时队列的消息接收方类似，此处不再累赘"></a>配置与上面延时队列的消息接收方类似，此处不再累赘</h5><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
</search>
