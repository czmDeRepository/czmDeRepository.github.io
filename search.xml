<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis高级之事务</title>
      <link href="2020/09/24/Redis%E9%AB%98%E7%BA%A7%E4%B9%8B%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/09/24/Redis%E9%AB%98%E7%BA%A7%E4%B9%8B%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="通常情况下的事务"><a href="#通常情况下的事务" class="headerlink" title="通常情况下的事务"></a>通常情况下的事务</h3><h4 id="事务的基本要素即四大特性（ACID）"><a href="#事务的基本要素即四大特性（ACID）" class="headerlink" title="事务的基本要素即四大特性（ACID）"></a>事务的基本要素即四大特性（ACID）</h4><ul><li><p>原子性（Atomicity）：事务所有操作指令，要么全部完成，要么全部不做。</p></li><li><p>一致性（Consistency）：事务提交后，数据库从一个一致性状态变到另一个一致性状态。</p><p>  如事务（a-100，b+100）执行后a减100，b一定加100，不然a，b就都不变</p></li><li><p>隔离性（Isolation）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。</p></li><li><p>持久性（Durability）：事务一旦提交后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p></li></ul><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>​     本质：一组指令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p><p><strong>Redis事务没有隔离级别的概念！</strong></p><p>一个事务的所有指令并没有被直接执行，而是存入队列中，只有发起执行命令（Exec）的时候才会顺序执行！</p><p><strong>Redis单条命令保证原子性，但是事务不保证原子性！</strong></p><h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol><li>开启事务：multi</li><li>输入命令入队列：set key value  ……</li><li>提交事务：exec  或 撤销事务：discard</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><p>​        命令有问题（语法错误），事务所有的命令都不会被执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2  <span class="comment">#错误命令</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">EXECABORT Transaction discarded because of previous errors.  <span class="comment">#执行事务报错</span></span><br><span class="line">&gt; get key2  </span><br><span class="line">null</span><br><span class="line">&gt; get key1 <span class="comment">#所有命令都不会被执行</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure><h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>​    如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行的（Redis事务不保证原子性）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k1 abc</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k1  <span class="comment">#k1为字符串，无法加1</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range  <span class="comment"># incr k1执行报错</span></span><br><span class="line">4) <span class="string">&quot;abc&quot;</span></span><br><span class="line">5) <span class="string">&quot;3&quot;</span></span><br><span class="line">&gt; get k2  <span class="comment">#其他命令正常执行</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><h2 id="监控watch"><a href="#监控watch" class="headerlink" title="监控watch"></a>监控watch</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​    很悲观，总是认为最坏情况，拿数据的时候数据都会被别人修改，无论什么时候都加锁，效率低下</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​    很乐观，总是认为最好情况，拿数据的时候数据都不会被别人修改，所以不加锁，在更新数据的时候先判断下，拿数据这期间有没有人修改过此数据（mysql中可增加一版本字段version，更新前比较此字段）</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi   <span class="comment">#事务正常结束，数据期间没有发生变动，这时候事务正常执行</span></span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">80</span><br><span class="line">20</span><br><span class="line">&gt; get money</span><br><span class="line">80</span><br></pre></td></tr></table></figure><p>使用多客户端即多线程修改值，使用watch可以当作Redis的乐观锁操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#执行之前，其他客户端执行 set money 10</span></span><br><span class="line">null  <span class="comment">#对比watch监控的money，发生变化，修改失败</span></span><br><span class="line"></span><br><span class="line">&gt; unwatch  <span class="comment">#执行失败，就先解锁</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money <span class="comment">#获取最新值，再次监控（此时money=10，usedMoney=0）</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">&gt; get money</span><br><span class="line">5</span><br><span class="line">&gt; get usedMoney</span><br><span class="line">5</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="2020/09/23/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>2020/09/23/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p><a href="https://redis.io/">官网</a></p><p><a href="http://www.redis.cn/">中文文档</a></p><p><a href="https://github.com/redis/">git地址</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。（百度百科）</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</li><li>redis默认16个数据库，类似数组下表从零开始，默认数据库为0，可以使用SELECT  id 命令切换指定数据库。</li><li>Redis索引都是从零开始</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li><li>redis6.0前是单线程的，6.0后支持多线程，默认单线程</li></ul><h4 id="redis使用单线程原因"><a href="#redis使用单线程原因" class="headerlink" title="redis使用单线程原因"></a>redis使用单线程原因</h4><ol><li>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li></ol><!--注：Redis进行持久化的时候会以子进程或者子线程的方式执行--><h4 id="Redis的高并发和快速原因"><a href="#Redis的高并发和快速原因" class="headerlink" title="Redis的高并发和快速原因"></a><strong>Redis的高并发和快速原因</strong></h4><ol><li>redis是基于内存的，内存的读写速度比硬盘快得多；（CPU高速缓存&gt;内存&gt;外存（硬盘、bai光盘、U盘等））</li><li>redis是单线程的，省去了很多CPU上下文切换线程的时间；(CPU上下文切换是很耗内存的)</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll（Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。）和自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。“多路”指的是多个socket连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>keys * ：查看所有key（*匹配所有字符，？匹配单个字符,如 keys  ?ist可匹配 list，aist，bist……）</li><li>set key value：存入键值对</li><li>get key：获取key对应值</li><li>DBSIZE：查看当前基本数据库大小（当前数据库的key的数量）。</li><li>Flushdb：清空当前库 | Flushall：通杀全部库</li><li>exists key : 判断key是否存在（存在返回1，不存在返回2）</li><li>del key：删除key</li><li>rename key newname：重命名key</li><li>move key  db_id  ：将当前数据库的 key 移动到给定的数据库 db 当中。</li><li>type key ：查看当前key存储类型</li><li>expire key second(秒) 设置超时时间（即几秒后过期）</li><li>ttl key 查看key剩余时间（-1表示永久有效，-2表示当前key不存在）</li><li>shutdown：关闭redis</li></ul><h3 id="设置修改密码"><a href="#设置修改密码" class="headerlink" title="设置修改密码"></a>设置修改密码</h3><h4 id="1-客户端连接修改"><a href="#1-客户端连接修改" class="headerlink" title="1.客户端连接修改"></a>1.<strong>客户端连接修改</strong></h4><!--立即生效，具有临时性，重启失效--><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##到安装目录下打开命令行</span></span><br><span class="line"><span class="comment">#wingdow下客户端连接 redis-cli.exe -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"><span class="comment">#Linux下客户端连接 ./redis-cli -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##查看密码（默认为空）</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;&quot;  //默认空</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码 config set requirepass 123456</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; config set requirepass 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass //密码设置后必须先验证通过密码，否则所有命令都不可用</span></span><br><span class="line"><span class="meta">(error)</span> <span class="string">NOAUTH Authentication required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证密码 auth &#123;密码&#125;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; auth 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.<strong>修改配置文件</strong></h4><!-- 永久生效--><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找到redis.conf配置文件中的requirepass</span></span><br><span class="line"><span class="comment">#requirepass foobared</span></span><br><span class="line"><span class="comment">#去掉注释配置自己密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">&#123;密码&#125;</span></span><br><span class="line"><span class="attr">保存后重启</span></span><br></pre></td></tr></table></figure><h3 id="五大基本类型"><a href="#五大基本类型" class="headerlink" title="五大基本类型"></a>五大基本类型</h3><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><p>​        String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p><h5 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h5><ol><li><p>append key value ：往字符串后面追加字符串（若key不存在，则新建key，相当于set key value）</p></li><li><p>strlen key ：返回字符串长度</p></li><li><p>incr key： 自增1</p></li><li><p>decr key：自减1</p></li><li><p>incrby key num：自增num</p></li><li><p>decrby key num：自减num</p></li><li><p>getrange key start end ：截取字符串[start,end] [0,-1]表示全部</p></li><li><p>setrange key start str ：用str替换指定位置开始的字符串</p></li><li><p>setex  key seconds value：保存key-value并设置过期时间（set with expire）</p></li><li><p>setnx key value：不存在则设置（set if not exist），成功返回1，若已存在，则创建失败，返回-1</p></li><li><p>mset  k1 v1 k2 v2 k3 v3：同时设置多个值</p></li><li><p>mget  k1 k2 k3： 同时获取多个值</p></li><li><p>getset key value：先get后set，如果不存在则返回null，如果存在，则返回旧值，再设置新值</p></li></ol><h4 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h4><p>​        列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表。</p><h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li><p>LPUSH list value1  value2 value3 …… ：将一个或多个值插入列表头部（左部）</p></li><li><p>LRANGE  list start end ：[start,end]通过区间获取列表具体值,[0,-1]获取list全部</p></li><li><p>RPUSH list  value1  value2 value3 …… ：将一个或多个值插入列表尾部（右部）</p></li><li><p>LPOP list ：移除列表的第一个元素</p></li><li><p>RPOP list：移除列表的最后一个值</p></li><li><p>Lindex list  index ：通过下标获取 元素</p></li><li><p>Llen list：返回列表长度</p></li><li><p>Lrem lsit  count value：移除list中count个value</p></li><li><p>ltrim list start end：通过下标截取list，原list已经被改变</p></li><li><p>rpoplpush sourceList newList：移除sourceList列表的最后一个元素，将他移动到newList列表中</p></li><li><p>lset list index newvalue： 替换将列表指定下标值（list或index不存在则报错）</p></li><li><p>linsert list value before|after newValue：将某一个具体的newValue插入到第一个value前面|后面</p></li></ol><h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><p>Set是string类型的无序集合，不可重复。它是通过HashTable实现实现的。</p><h5 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li>sadd set value1 value2 value3 ……：往set集合添加元素</li><li>smembers set：查看set元素</li><li>sismembers set  value：是否存在指定元素（存在返回1，不存在返回0）</li><li>scard set：查看set集合元素数</li><li>srem set value ：移除set集合指定元素</li><li>srandmember set （count）：随机抽取num个元素（count不写默认一个）</li><li>spop  set （count）：随机移除count个元素</li><li>smove  set1 set2 value：将set1中value移动到set2中</li><li>sdiff set1 set2：set1与set2取差集，返回set1中存在，set2不存在的元素集合</li><li>sinter set1 set2 ：取交集</li><li>sunion set1 set2：取并集</li></ol><h4 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h4><p>hash 是一个键值对集合,是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;。</p><h5 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li>hset hash key value ：存入hash一个 key-value键值对</li><li>hget  hash key：获取hash中key的值</li><li>hmset hash key1 value1 key2 value2 ……：存入hash多个键值对</li><li>hmget hash key1 key2 ……：获取hash多个key字段的值</li><li>hgetall hash ：获取全部key-value内容</li><li>hdel hash key ：删除hash中指定key字段</li><li>hlen hash ：返回hash长度</li><li>hexists hash key：判断hash中key字段是否存在</li><li>hkeys hash：返回所有key字段</li><li>hvals  hash：放回所有value</li><li>hincrby hash key  num：指定key增量num</li><li>hsetnx hash key value：不存在则存入</li></ol><h4 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合(Zset)"></a>有序集合(Zset)</h4><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p><h5 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h5><ol><li><p>ZADD key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数.</p></li><li><p>ZCARD key 获取有序集合的成员数.</p></li><li><p>ZCOUNT key min max 计算在有序集合中指定区间分数[min,max]的成员数。</p></li><li><p>ZINCRBY key increment member:有序集合中对指定成员的分数加上增量 increment。</p></li><li><p>ZINTERSTORE newkey num key …:计算给定的一个或多(num)个有序集key的交集并将结果集存储在新的有序集合 newkey 中。</p></li><li><p>ZLEXCOUNT key min max:在有序集合中计算指定字典区间内成员数量。</p><p> min max: { - [a =(-∞，a]; -  (a=(-∞，a)；[a [b=[a,b];-  +=(-∞,+∞)</p></li><li><p>ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员。-inf +inf = -∞ +∞</p></li><li><p>ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员。</p></li><li><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员。</p></li><li><p>ZRANK key member 返回有序集合中指定成员的索引。</p></li><li><p>ZREM key member [member …] 移除有序集合中的一个或多个成员。</p></li><li><p>ZREMRANGEBYLEX key min max :移除有序集合中给定的字典区间的所有成员。</p></li><li><p>ZREMRANGEBYRANK key start stop:移除有序集合中给定的排名区间的所有成员。</p></li><li><p>ZREMRANGEBYSCORE key min max移除有序集合中给定的分数区间的所有成员。</p></li><li><p>ZREVRANGE key start stop [WITHSCORES]返回有序集中指定区间内的成员，通过索引，分数从高到低。</p></li><li><p>ZREVRANGEBYSCORE key max min [WITHSCORES]返回有序集中指定分数区间内的成员，分数从高到低排序。</p></li><li><p>ZREVRANK key member返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。</p></li><li><p>ZSCORE key member返回有序集中，成员的分数值。</p></li><li><p>ZUNIONSTORE destination numkeys key [key …]计算给定的一个或多个有序集的并集，并存储在新的 key 中。</p></li><li><p>ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）。</p></li></ol><h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>​    集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，其实不太准确。</p><p>​    其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： </p><ul><li>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 </li><li>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) </li><li>其他的range操作复杂度一般为O(log(n))</li><li>当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</li></ul><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="地理空间（geospatial-）"><a href="#地理空间（geospatial-）" class="headerlink" title="地理空间（geospatial ）"></a>地理空间（geospatial ）</h4><p>​    Redis的Geo，3.2版本推出，可以推算地理位置的信息，两地之间的距离</p><p>​    城市经纬度查询：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p><!--**注：有效经度为-180至180度。有效纬度为-85.05112878至85.05112878度。**--><h5 id="六大操作"><a href="#六大操作" class="headerlink" title="六大操作"></a>六大操作</h5><p><strong>geoadd   key  经度 维度 坐标名</strong>：添加地理位置（两级无法直接添加，可一次添加多个）， 先经度后维度（官方文档疑似写错了）</p><p>例：geoadd china:city   116.405285  39.904989     beijing    121.4   31.2  shanghai  ……</p><p>​                        key            经度     维度    地理名称</p><p><strong>geopos key  name1 name2……</strong>：获取key中name的地理位置</p><p>例：GEOPOS china:city beijing shanghai shenzhen xianggang</p><p><strong>georadius key  经度 维度 距离：</strong> 以给定的经纬度为中心，找出某一半径内所有的元素</p><p>例：GEORADIUS china:city 110 30 1000 km [withcoord] [withdist]</p><p><strong>GEORADIUSBYMEMBER key  坐标名（元素名） 距离</strong> ：根据给定的元素确定中心点，再进行查找</p><p>例：GEORADIUSBYMEMBER china:city beijing 1000 km [withcoord] [withdist]</p><!--注：withcoord：经纬度,withdist：距离坐标城市的距离，count num：筛选出num个结果--><p><strong>GEODIST  key name1  name2 [单位]</strong> ：返回指定单位中两个指定成员之间的距离。如果缺少一个或两个成员，该命令将返回NULL。</p><!--单位必须是以下之一，默认为米：m（米）、km（千米）、mi（英里）、ft（英尺）--><p>例：GEODIST china:city beijing xianggang km</p><p><strong>GEOHASH key name1 name2……</strong>：该命令返回11个字符的Geohash字符串，因此与Redis内部52位表示形式相比，不会损失任何精度。该命令返回一个数组，其中每个元素是与作为参数传递给命令的每个成员名称相对应的Geohash。</p><p>返回的Geohashhes具有以下属性：  </p><ol><li>以从右侧删除字符来缩短它们。它将失去精度，但仍将指向同一区域。</li><li>可以在<code>geohash.org</code>URL中使用它们，例如<code>http://geohash.org/&lt;geohash-string&gt;</code>。这是<a href="http://geohash.org/sqdtr74hyu0">此类URL</a>的<a href="http://geohash.org/sqdtr74hyu0">示例</a>。</li><li>前缀相似的字符串在附近，但事实并非如此，前缀不同的字符串也可能在附近。</li></ol><p>geo底层实现原理其实是zset，我们可以使用zset命令操作他</p><p>zrange key 0 -1：查看地图key中的所有元素</p><p>zrem key member：删除key中指定元素</p><h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p><strong>简介：Hyperloglog 可用于基数统计（基数：在数学上，是集合论中刻画任意集合集大小的一个概念。即一个集合中不重复的元素数。）</strong></p><p><strong>redis2.8.9后更新了hyperloglog数据结构</strong></p><p>示例：网页UV</p><p>uv（Unique Visitor）:网站的独立访客，统计1天内访问某站点的用户数(以cookie为依据);访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。</p><p>访问用户量大的情况下，若用传统的set集合统计将耗费大量内存。使用hyperloglog基数统计占用内存固定，2^64不同的元素，只需要废12kb内存。（官网统计hyperloglog有0.81%的错误率，但在统计UV任务上，我们可以忽略不计）</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>PFADD keyset  value1 value2 value3……往集合keyset中添加元素</p><p>PFCOUNT keyset：统计集合keyset的基数</p><p>PFMERGE  newset keyset1 ketset2：将集合keyset1和keyset2的元素合并（并集）到newset中</p><h4 id="Bitmap（位存储）"><a href="#Bitmap（位存储）" class="headerlink" title="Bitmap（位存储）"></a>Bitmap（位存储）</h4><p><strong>简介：</strong> Biymaps位图，该数据结构都是操作二进制位来记录数据的，就只有0和1两个状态。（适用于只有两个状态的数据）</p><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p>setbit  sign index  value：往sign的index（从0开始）位置上存value（0或1）</p><p>getbit sign index ：获取sign中index位上的值（默认0）</p><p>bitcount sign：统计sgin中为1的数量</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql中distinct简单使用</title>
      <link href="2020/09/22/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>2020/09/22/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"><a href="#简介：distinct常用于sql语句中查出重复数据时需要去重的时候" class="headerlink" title="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"></a><strong>简介：distinct常用于sql语句中查出重复数据时需要去重的时候</strong></h3><!--distinct不会过滤掉null值，返回结果包含null值--><p>示例：table</p><table><thead><tr><th>column1</th><th>column2</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>1</td><td>b</td></tr><tr><td>2</td><td>c</td></tr><tr><td>2</td><td>c</td></tr><tr><td>3</td><td>d</td></tr><tr><td>null</td><td>e</td></tr><tr><td>null</td><td>f</td></tr><tr><td></td><td>g</td></tr></tbody></table><h3 id="只有一字段："><a href="#只有一字段：" class="headerlink" title="只有一字段："></a><strong>只有一字段</strong>：</h3><p>​        <strong>直接在字段前加distinct</strong></p><p>​        select distinct column1 from table</p><p>结果：</p><table><thead><tr><th>column1</th></tr></thead><tbody><tr><td>1</td></tr><tr><td>2</td></tr><tr><td>3</td></tr><tr><td>null</td></tr><tr><td></td></tr></tbody></table><h3 id="需要查出多个字段："><a href="#需要查出多个字段：" class="headerlink" title="需要查出多个字段："></a><strong>需要查出多个字段</strong>：</h3><p>​    distinct 需要放在第一个字段前面，否者报错</p><p>select distinct colum1 , colum2 from table;</p><p>结果：多个字段其实是多个字段查出后拼接再去重</p><table><thead><tr><th>column1</th><th>column2</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>1</td><td>b</td></tr><tr><td>2</td><td>c</td></tr><tr><td>3</td><td>d</td></tr><tr><td>null</td><td>e</td></tr><tr><td>null</td><td>f</td></tr><tr><td></td><td>g</td></tr></tbody></table><h3 id="只想一个字段唯一"><a href="#只想一个字段唯一" class="headerlink" title="只想一个字段唯一"></a><strong>只想一个字段唯一</strong></h3><p><strong>1.使用group by</strong></p><p>​    select column1, column2 from table group by column1</p><p><strong>2.使用GROUP_CONCAT函数</strong></p><p>​    <strong>GROUP_CONCAT在连接查询的时候，能让查出的这字段的多个数，按字符拼接的方式存放在一起。</strong></p><p>select GROUP_CONCAT(distinct column1) as column1, column2 from table group by column1</p><table><thead><tr><th>column1</th><th>column2</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>c</td></tr><tr><td>3</td><td>d</td></tr><tr><td>null</td><td>e</td></tr><tr><td></td><td>g</td></tr></tbody></table><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2.3.1.RELEASE与javaFx整合</title>
      <link href="2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/"/>
      <url>2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><figure class="highlight xml"><figcaption><span>&lt;dependency&gt;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.roskenet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-javafx-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动类继承AbstractJavaFxApplicationSupport"><a href="#启动类继承AbstractJavaFxApplicationSupport" class="headerlink" title="启动类继承AbstractJavaFxApplicationSupport"></a>启动类继承AbstractJavaFxApplicationSupport</h2><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375394146.png" alt="启动类"></p><h2 id="采用mvc模式"><a href="#采用mvc模式" class="headerlink" title="采用mvc模式"></a>采用mvc模式</h2><ul><li><h3 id="每个fxml页面都有对应的java视图类"><a href="#每个fxml页面都有对应的java视图类" class="headerlink" title="每个fxml页面都有对应的java视图类"></a>每个fxml页面都有对应的java视图类</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375588.png" alt="视图"></p><ul><li><h3 id="视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）"><a href="#视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）" class="headerlink" title="视图类需继承AbstractFxmlView且有**@FXMLView注解**（value值为对应的fxml文件路径）"></a>视图类需继承<strong>AbstractFxmlView</strong>且有**@FXMLView注解**（value值为对应的fxml文件路径）</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375950(1).jpg" alt="视图类"></p><ul><li><h3 id="fxml文件中需指定对应controller类"><a href="#fxml文件中需指定对应controller类" class="headerlink" title="fxml文件中需指定对应controller类"></a>fxml文件中需指定对应controller类</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376230(1).jpg" alt="fxml文件"></p><ul><li><h3 id="controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息"><a href="#controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息" class="headerlink" title="controller类需实现Initializable接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)"></a>controller类需实现<strong>Initializable</strong>接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376444(1).jpg"></p><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376926(1).jpg"></p><ul><li><h3 id="fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法"><a href="#fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法" class="headerlink" title="fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法"></a>fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377406(1).jpg"></p><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377507(1).jpg"></p><h2 id="示例页面效果展示-只是简单项目，页面可能有点丑"><a href="#示例页面效果展示-只是简单项目，页面可能有点丑" class="headerlink" title="示例页面效果展示(只是简单项目，页面可能有点丑)"></a>示例页面效果展示(只是简单项目，页面可能有点丑)</h2><ul><li><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377745(1).jpg" alt="登陆"></p><ul><li><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377865(1).jpg" alt="主页"></p><ul><li><h3 id="点击住宿按钮弹出住宿页面进行信息登记"><a href="#点击住宿按钮弹出住宿页面进行信息登记" class="headerlink" title="点击住宿按钮弹出住宿页面进行信息登记"></a>点击住宿按钮弹出住宿页面进行信息登记</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377915(1).jpg"></p><ul><li><h3 id="双击对应表格中的宿舍即可查看详情"><a href="#双击对应表格中的宿舍即可查看详情" class="headerlink" title="双击对应表格中的宿舍即可查看详情"></a>双击对应表格中的宿舍即可查看详情</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378007(1).jpg"></p><ul><li><h3 id="宿舍管理页面"><a href="#宿舍管理页面" class="headerlink" title="宿舍管理页面"></a>宿舍管理页面</h3></li></ul><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378103(1).jpg"></p><h2 id="获取项目"><a href="#获取项目" class="headerlink" title="获取项目"></a>获取项目</h2><ul><li><h3 id="Git仓库地址"><a href="#Git仓库地址" class="headerlink" title="Git仓库地址"></a><a href="https://github.com/czmDeRepository/javaFx">Git仓库地址</a></h3></li><li><h3 id="注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql"><a href="#注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql" class="headerlink" title="注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql"></a><strong>注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql</strong></h3></li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间问题</title>
      <link href="2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL数据库问题"><a href="#MySQL数据库问题" class="headerlink" title="MySQL数据库问题"></a>MySQL数据库问题</h3><p><strong>查询数据库时间</strong></p><ol><li>select sysdate();</li><li>select now();</li><li>select current_date;</li></ol><p><strong>连接url需指定serverTimezone</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://&#123;host&#125;:&#123;port&#125;/&#123;database&#125;?</span></span><br><span class="line"><span class="attr">useUnicode</span>=<span class="string">true&amp; //驱动程序在处理字符串时是否应使用Unicode字符编码？默认位true，设置false可能出现乱码</span></span><br><span class="line"><span class="attr">characterEncoding</span>=<span class="string">UTF-8&amp; //指定字符编码</span></span><br><span class="line"><span class="attr">serverTimezone</span>=<span class="string">Asia/Shanghai&amp; //指定时区位亚洲上海</span></span><br><span class="line"><span class="attr">useSSL</span>=<span class="string">false&amp; // 与服务器通信时使用ssl（true/false），连接到MySQL5.5.45+、5.6.26+或5.7.6+时默认为“true”，否则默认为“false”</span></span><br><span class="line"><span class="attr">allowPublicKeyRetrieval</span>=<span class="string">true //如果用户使用了 sha256_password 认证，密码在传输过程中必须使用 TLS 协议保护，但是如果 RSA 公钥不可用，可以使用服务器提供的公钥；可以在连接中通过 ServerRSAPublicKeyFile 指定服务器的 RSA 公钥，或者AllowPublicKeyRetrieval=True参数以允许客户端从服务器获取公钥；但是需要注意的是 AllowPublicKeyRetrieval=True可能会导致恶意的代理通过中间人攻击(MITM)获取到明文密码，所以默认是关闭的，必须显式开启</span></span><br></pre></td></tr></table></figure><h3 id="服务器时间"><a href="#服务器时间" class="headerlink" title="服务器时间"></a>服务器时间</h3><ul><li>进入linux：输入date查看服务器时间</li></ul><p><img src="/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222100673.png" alt="image-20200915222100673"></p><ul><li><p>使用timedatectl命令</p><p>  timedatectl对于RHEL / CentOS 7和基于Fedora 21+的分布式系统来说，是一个新工具，它作为systemd系统和服务管理器的一部分，代替旧的传统的用在基于Linux分布式系统的sysvinit守护进程的date命令。</p><p>  <img src="/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222429047.png" alt="显示当前系统时间"></p>  <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">使用timedatectl命令</span></span><br><span class="line"><span class="comment"># timedatectl list-timezones |grep Shanghai    #查找上海的完整名称</span></span><br><span class="line"><span class="attr">Asia/Shanghai</span></span><br><span class="line"><span class="comment"># timedatectl set-timezone Asia/Shanghai    #其他时区以此类推</span></span><br><span class="line"><span class="attr">或者直接手动创建软链接</span></span><br><span class="line"><span class="comment"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="docker容器时间"><a href="#docker容器时间" class="headerlink" title="docker容器时间"></a>docker容器时间</h3><p>进入docker命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &#123;容器名或容器id&#125;  /bin/bash</span><br></pre></td></tr></table></figure><p>查看时间命令：date</p><p>复制相应的时区文件，替换系统时区文件；</p><p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p><p>有的容器基础镜像是有这个文件的，直接拷贝就可以，如果不能拷贝，则是因为创建镜像时依赖的基础镜像 运行的容器没有这两个文件，使用下面的办法</p><ol><li><p>创建文件夹</p><p> mkdir -p /usr/share/zoneinfo/Asia</p></li><li><p>回到宿主机，复制宿主机里的文件到容器中</p><p> docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或容器名:/usr/share/zoneinfo/Asia</p></li></ol><p>​    3.进入容器执行命令 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p><h3 id="tomcat容器时区问题"><a href="#tomcat容器时区问题" class="headerlink" title="tomcat容器时区问题"></a>tomcat容器时区问题</h3><p><strong>描述：</strong>java的war包部署在Linux上的tomcat容器中相差8小时</p><p>解决：在tomcat的bin目录下找到catalina.sh文件在JAVA_OPTS追加添加如下配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-Duser.timezone</span>=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915221437392.png" alt="image-20200915221437392"></p><!--注：若是在docker中的容器可先将其拷贝出来修改后再拷贝到docker中原来对应位置--><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
