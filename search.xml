<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis事务与配置</title>
    <url>/2020/09/24/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="通常情况下的事务"><a href="#通常情况下的事务" class="headerlink" title="通常情况下的事务"></a>通常情况下的事务</h3><h4 id="事务的基本要素即四大特性（ACID）"><a href="#事务的基本要素即四大特性（ACID）" class="headerlink" title="事务的基本要素即四大特性（ACID）"></a>事务的基本要素即四大特性（ACID）</h4><ul>
<li><p>原子性（Atomicity）：事务所有操作指令，要么全部完成，要么全部不做。</p>
</li>
<li><p>一致性（Consistency）：事务提交后，数据库从一个一致性状态变到另一个一致性状态。</p>
<p>  如事务（a-100，b+100）执行后a减100，b一定加100，不然a，b就都不变</p>
</li>
<li><p>隔离性（Isolation）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。</p>
</li>
<li><p>持久性（Durability）：事务一旦提交后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
</li>
</ul>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>​     本质：一组指令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li><p><strong>Redis事务没有隔离级别的概念！</strong></p>
<p> 一个事务的所有指令并没有被直接执行，而是存入队列中，只有发起执行命令（Exec）的时候才会顺序执行！</p>
</li>
<li><p><strong>Redis单条命令保证原子性，但是事务不保证原子性！</strong></p>
</li>
<li><p><strong>单独的隔离操作</strong></p>
<p> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
</ol>
<h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol>
<li>开启事务：multi</li>
<li>输入命令入队列：set key value  ……</li>
<li>提交事务：exec  或 撤销事务：discard</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><p>​        命令有问题，事务所有的命令都不会被执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2  <span class="comment">#错误命令</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">EXECABORT Transaction discarded because of previous errors.  <span class="comment">#执行事务报错</span></span><br><span class="line">&gt; get key2  </span><br><span class="line">null</span><br><span class="line">&gt; get key1 <span class="comment">#所有命令都不会被执行</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>​    如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的（Redis事务不保证原子性）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k1 abc</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k1  <span class="comment">#k1为字符串，无法加1</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range  <span class="comment"># incr k1执行报错</span></span><br><span class="line">4) <span class="string">&quot;abc&quot;</span></span><br><span class="line">5) <span class="string">&quot;3&quot;</span></span><br><span class="line">&gt; get k2  <span class="comment">#其他命令正常执行</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="监控watch"><a href="#监控watch" class="headerlink" title="监控watch"></a>监控watch</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​    很悲观，总是认为最坏情况，拿数据的时候数据都会被别人修改，无论什么时候都加锁，效率低下</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​    很乐观，总是认为最好情况，拿数据的时候数据都不会被别人修改，所以不加锁，在更新数据的时候先判断下，拿数据这期间有没有人修改过此数据（mysql中可增加一版本字段version，更新前比较此字段）</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi   </span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#事务正常结束，数据期间没有发生变动，这时候事务正常执行</span></span><br><span class="line">80</span><br><span class="line">20</span><br><span class="line">&gt; get money</span><br><span class="line">80</span><br></pre></td></tr></table></figure>

<p>使用多客户端即多线程修改值，使用watch可以当作Redis的乐观锁操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#执行之前，其他客户端执行 set money 10</span></span><br><span class="line">null  <span class="comment">#对比watch监控的money，发生变化，修改失败</span></span><br><span class="line"></span><br><span class="line">&gt; unwatch  <span class="comment">#执行失败，就先解锁</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money <span class="comment">#获取最新值，再次监控（此时money=10，usedMoney=0）</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">&gt; get money</span><br><span class="line">5</span><br><span class="line">&gt; get usedMoney</span><br><span class="line">5</span><br></pre></td></tr></table></figure>



<h2 id="配置文件Redis-conf"><a href="#配置文件Redis-conf" class="headerlink" title="配置文件Redis.conf"></a>配置文件Redis.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unit(单位)</span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line">只支持bytes，不支持bit，对大小写不敏感</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INCLUDES模块</span><br><span class="line"><span class="comment"># include .\path\to\local.conf</span></span><br><span class="line"><span class="comment"># include c:\path\to\other.conf</span></span><br><span class="line">可通过include 包含其他文件</span><br><span class="line"></span><br><span class="line">网络</span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment">#绑定ip</span></span><br><span class="line">port 6379	<span class="comment">#端口</span></span><br><span class="line">protected-mode yes <span class="comment">#保护模式，默认开启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GENERAL通用配置模块</span><br><span class="line">daemonize yes <span class="comment">#以守护进程执行（后台与运行）</span></span><br><span class="line">pidfile /var/run/redis.pid <span class="comment">#如果以守护进程方式运行，需指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice <span class="comment">#日志级别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment">#日志文件位置</span></span><br><span class="line">databases 16 <span class="comment">#数据库数量</span></span><br><span class="line"></span><br><span class="line">Tcp-keepalive <span class="comment">#连接检测，单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </span></span><br><span class="line">tcp-backlog</span><br><span class="line"><span class="comment">#设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境</span></span><br><span class="line"><span class="comment">#下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以</span></span><br><span class="line"><span class="comment">#需要确认增大somaxconntcp_max_syn_backlog两个值来达到想要的效果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SNAPSHOTTING快照模块</span><br><span class="line"><span class="comment">#达到已下条件，就进行保存</span></span><br><span class="line">save 900 1 <span class="comment">#15分钟内改了1次。</span></span><br><span class="line">save 300 10 <span class="comment">#5分钟内改了10次，</span></span><br><span class="line">save 60 10000 <span class="comment">#1分钟内改了1万次，</span></span><br><span class="line"><span class="comment">#如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#持久化操作出错，是否继续工作</span></span><br><span class="line">rdbcompression yes  <span class="comment">#对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes <span class="comment">#存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</span></span><br><span class="line">dir ./ <span class="comment">#db文件的保存路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECURITY安全模块</span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass <span class="string">&quot;&quot;</span>  <span class="comment">#配置redis密码，默认空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LIMITS限制模块</span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"><span class="comment">#设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment">#设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</span></span><br><span class="line"><span class="comment">#如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信</span></span><br><span class="line"><span class="comment">#息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从#redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，</span></span><br><span class="line"><span class="comment">#才不用考虑这个因素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction  <span class="comment">#内存达到上限后处理策略</span></span><br><span class="line"><span class="comment">#（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（2）allkeys-lru：使用LRU算法移除key</span></span><br><span class="line"><span class="comment">#（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（4）allkeys-random：移除随机的key</span></span><br><span class="line"><span class="comment">#（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</span></span><br><span class="line"><span class="comment">#（6）noeviction：不进行移除。针对写操作，只是返回错误信息</span></span><br><span class="line"></span><br><span class="line">maxmemory-samples 5 <span class="comment">#设置检查的样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，</span></span><br><span class="line"><span class="comment">#redis默认会检查这么多个key并选择其中LRU的那个，LRU和最小TTL算法不是精确算法而是近似算法，该值越大越精准，但cpu成本高，</span></span><br><span class="line"><span class="comment">#3较快，默认5，10非常接近</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APPEND ONLY MODE附加模块</span><br><span class="line">appendonly no <span class="comment">#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时</span></span><br><span class="line"><span class="comment">#导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</span></span><br><span class="line"><span class="comment">#默认为no</span></span><br><span class="line">appendfsync everysec  <span class="comment">#指定更新日志条件，共有3个可选值： </span></span><br><span class="line"><span class="comment">#  no：表示等操作系统进行数据缓存同步到磁盘（快） </span></span><br><span class="line"><span class="comment">#  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span></span><br><span class="line"><span class="comment">#  everysec：表示每秒同步一次（折衷，默认值）</span></span><br><span class="line"></span><br><span class="line">appendfilename appendonly.aof <span class="comment">#指定更新日志文件名，默认为appendonly.aof</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">No-appendfsync-on-rewrite no <span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</span></span><br><span class="line"></span><br><span class="line">Auto-aof-rewrite-min-size 64mb <span class="comment">#设置重写的基准值 大小</span></span><br><span class="line">Auto-aof-rewrite-percentage  100 <span class="comment"># 设置重写的基准值 百分比</span></span><br><span class="line"></span><br><span class="line">vm-enabled no <span class="comment">#指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷</span></span><br><span class="line"><span class="comment">#数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span><br><span class="line">   </span><br><span class="line">vm-swap-file /tmp/redis.swap <span class="comment"># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span><br><span class="line">   </span><br><span class="line">vm-max-memory 0 <span class="comment">#将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span></span><br><span class="line">   </span><br><span class="line">vm-page-size 32 <span class="comment"># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，</span></span><br><span class="line"><span class="comment">#vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很</span></span><br><span class="line"><span class="comment">#大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span></span><br><span class="line">   </span><br><span class="line">vm-pages 134217728 <span class="comment"># 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘</span></span><br><span class="line"><span class="comment">#上每8个pages将消耗1byte的内存。</span></span><br><span class="line">   </span><br><span class="line">vm-max-threads 4 <span class="comment"># 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，</span></span><br><span class="line"><span class="comment">#可能会造成比较长时间的延迟。默认值为4</span></span><br><span class="line">   </span><br><span class="line">glueoutputbuf yes <span class="comment"># 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之java简单使用</title>
    <url>/2020/09/25/Redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​    Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉 </p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h5 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="代码示例（与命令行操作基本一致）"><a href="#代码示例（与命令行操作基本一致）" class="headerlink" title="代码示例（与命令行操作基本一致）"></a>代码示例（与命令行操作基本一致）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"> <span class="comment">//验证密码，如果没有设置密码这段代码省略</span></span><br><span class="line">jedis.auth(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.print(<span class="string">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line">System.out.println(<span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());</span><br><span class="line">System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());</span><br><span class="line">System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());</span><br><span class="line">System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());</span><br><span class="line">System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span>+jedis.mset(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;key04&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="comment">//添加名称为hash（key）的hash元素</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;hash&quot;</span>,map);</span><br><span class="line"><span class="comment">//向名称为hash的hash中添加key为key5，value为value5元素</span></span><br><span class="line">jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Map&lt;String,String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span>+jedis.hkeys(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span>+jedis.hvals(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return List&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">6</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span>+jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span>+jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;key4&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//……其他类型操作类似，可参考redis命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis事务</span></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">String result = jsonObject.toJSONString();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result);</span><br><span class="line">    <span class="comment">//再存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result);</span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果出现异常，回滚</span></span><br><span class="line">    multi.discard();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>));</span><br><span class="line">    <span class="comment">//最终关闭客户端</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis与SpringBoot整合"><a href="#Redis与SpringBoot整合" class="headerlink" title="Redis与SpringBoot整合"></a>Redis与SpringBoot整合</h2><h3 id="maven依赖-1"><a href="#maven依赖-1" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#数据库索引，默认0</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">      <span class="attr">jedis:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池最大连接数 </span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment">#连接池最大阻塞连接时间，负值表示无限制</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">5</span> <span class="comment">#连接池中最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池最小空闲连接</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">shutdown-timeout:</span> <span class="string">100ms</span> <span class="comment">#关闭超时时间，默认100ms</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义Redistemplate模板"><a href="#自定义Redistemplate模板" class="headerlink" title="自定义Redistemplate模板"></a>自定义Redistemplate模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(factory);</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> 							</span><br><span class="line">          													Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">      om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">      template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//必须执行这个函数,初始化RedisTemplate</span></span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级</title>
    <url>/2020/09/27/Redis%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="为什么持久化"><a href="#为什么持久化" class="headerlink" title="为什么持久化"></a>为什么持久化</h3><p>​    Redis是内存数据库，数据都保存在内存中，因此数据读取速度快，效率高，但也容易发生丢失（如Redis宕机，突然断电等）。所以必须要有持久化的机制保存数据到硬盘，防止数据丢失。</p>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        RDB(默认的持久化方式)指在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb,它恢复时是将快照文件直接读到内存里。</p>
<h4 id="持久化过程"><a href="#持久化过程" class="headerlink" title="持久化过程"></a>持久化过程</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<h4 id="触发RDB快照条件"><a href="#触发RDB快照条件" class="headerlink" title="触发RDB快照条件"></a>触发RDB快照条件</h4><ol>
<li>配置文件save配置</li>
<li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li>
<li>执行命令save或者bgsave</li>
</ol>
<p>注：save：save时只管保存，其它不管，全部阻塞</p>
<p>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave命令获取最后一次成功执行快照的时间。</p>
<h4 id="停用"><a href="#停用" class="headerlink" title="停用"></a>停用</h4><ol>
<li>动态所有停止RDB保存规则的方法：redis-cli config set save “”</li>
<li>修改配置文件save “”</li>
</ol>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ol>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ol>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF默认存储文件名appendonly.aof</p>
<h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>修改配置appendonly no改为yes</p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>修复受损appendonly.aof文件命令： Redis-check-aof –fix  appendonly.aof</p>
<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p>
<h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ol>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol>
<li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no   从不同步，性能最好</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
</ol>
<h4 id="同时开启两种持久化方式"><a href="#同时开启两种持久化方式" class="headerlink" title="同时开启两种持久化方式"></a>同时开启两种持久化方式</h4><ol>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ol>
<h4 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h4><ol>
<li> 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li>
<li>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</li>
</ol>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​    进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。复杂情况下可使用专门的消息中间件，如RabbitMQ。</p>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>PSUBSCRIBE pattern [pattern …]     订阅一个或多个符合给定模式的频道。<br>PUBSUB subcommand [argument [argument …]]      查看订阅与发布系统状态。<br>PUBLISH channel message     将信息发送到指定的频道。<br>PUNSUBSCRIBE [pattern [pattern …]]     退订所有给定模式的频道。<br>SUBSCRIBE channel [channel …]     订阅给定的一个或多个频道的信息。<br>UNSUBSCRIBE [channel [channel …]]    指退订给定的频道。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#窗口1</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel  <span class="comment">#订阅channel频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line"><span class="comment">#当下面发布消息到此频道时，显示下面信息</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1 <span class="comment">#数量 </span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span> <span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span> <span class="comment">#消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与上面同一时刻的另一个客户端窗口2</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#窗口3</span></span><br><span class="line"><span class="comment">#将信息发送到指定的频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH channel <span class="string">&quot;hello word&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 <span class="comment">#推送给两个订阅者</span></span><br><span class="line"><span class="comment">#获取当前系统所有频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">&quot;channel2&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主，实现读写分离，Slave无法写入数据</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Info replication <span class="comment">#查看</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment">#角色</span></span><br><span class="line">connected_slaves:0 <span class="comment">#从机数</span></span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>拷贝多个redis.conf文件</li>
<li>开启daemonize yes</li>
<li>修改port，pidfile，logfile，dbfilename</li>
<li>执行指令：redis-server 配置文件路径</li>
<li>在从机上运行SLAVEOF masterip  端口</li>
</ol>
<h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><h4 id="一主多仆："><a href="#一主多仆：" class="headerlink" title="一主多仆："></a>一主多仆：</h4><p>​        一个master多个slaver</p>
<h4 id="薪火相传："><a href="#薪火相传：" class="headerlink" title="薪火相传："></a>薪火相传：</h4><ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的。</li>
<li>Slaveof 新主库IP 新主库端口</li>
</ul>
<h4 id="反客为主："><a href="#反客为主：" class="headerlink" title="反客为主："></a>反客为主：</h4><p>​        执行指令SLAVEOF no one，使当前数据库停止与其他数据库的同步，转成主数据库</p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="哨兵模式-sentinel-（实际开发中常用）"><a href="#哨兵模式-sentinel-（实际开发中常用）" class="headerlink" title="哨兵模式(sentinel)（实际开发中常用）"></a>哨兵模式(sentinel)（实际开发中常用）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ol>
<li>新建sentinel.conf文件</li>
<li>写入基本配置：sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 （最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机）</li>
<li>在Redis根目录下执行命令启动哨兵：Redis-sentinel  sentinel.conf 文件路径</li>
</ol>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2020/09/23/Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><a href="https://redis.io/">官网</a></p>
<p><a href="http://www.redis.cn/">中文文档</a></p>
<p><a href="https://github.com/redis/">git地址</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。（百度百科）</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</li>
<li>redis默认16个数据库，类似数组下表从零开始，默认数据库为0，可以使用SELECT  id 命令切换指定数据库。</li>
<li>Redis索引都是从零开始</li>
<li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li>
<li>redis6.0前是单线程的，6.0后支持多线程，默认单线程</li>
</ul>
<h4 id="redis使用单线程原因"><a href="#redis使用单线程原因" class="headerlink" title="redis使用单线程原因"></a>redis使用单线程原因</h4><ol>
<li>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
</ol>
<!--注：Redis进行持久化的时候会以子进程或者子线程的方式执行-->

<h4 id="Redis的高并发和快速原因"><a href="#Redis的高并发和快速原因" class="headerlink" title="Redis的高并发和快速原因"></a><strong>Redis的高并发和快速原因</strong></h4><ol>
<li>redis是基于内存的，内存的读写速度比硬盘快得多；（CPU高速缓存&gt;内存&gt;外存（硬盘、光盘、U盘等））</li>
<li>redis是单线程的，省去了很多CPU上下文切换线程的时间；(CPU上下文切换是很耗内存的)</li>
<li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll（Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。）和自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。“多路”指的是多个socket连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>keys * ：查看所有key（*匹配所有字符，？匹配单个字符,如 keys  ?ist可匹配 list，aist，bist……）</li>
<li>set key value：存入键值对</li>
<li>get key：获取key对应值</li>
<li>DBSIZE：查看当前基本数据库大小（当前数据库的key的数量）。</li>
<li>Flushdb：清空当前库 | Flushall：通杀全部库</li>
<li>exists key : 判断key是否存在（存在返回1，不存在返回2）</li>
<li>del key：删除key</li>
<li>rename key newname：重命名key</li>
<li>move key  db_id  ：将当前数据库的 key 移动到给定的数据库 db 当中。</li>
<li>type key ：查看当前key存储类型</li>
<li>expire key second(秒) 设置超时时间（即几秒后过期）</li>
<li>ttl key 查看key剩余时间（-1表示永久有效，-2表示当前key不存在）</li>
<li>shutdown：关闭redis</li>
</ul>
<h3 id="设置修改密码"><a href="#设置修改密码" class="headerlink" title="设置修改密码"></a>设置修改密码</h3><h4 id="1-客户端连接修改"><a href="#1-客户端连接修改" class="headerlink" title="1.客户端连接修改"></a>1.<strong>客户端连接修改</strong></h4><!--立即生效，具有临时性，重启失效-->

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##到安装目录下打开命令行</span></span><br><span class="line"><span class="comment">#wingdow下客户端连接 redis-cli.exe -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"><span class="comment">#Linux下客户端连接 ./redis-cli -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##查看密码（默认为空）</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;&quot;  //默认空</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码 config set requirepass 123456</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; config set requirepass 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass //密码设置后必须先验证通过密码，否则所有命令都不可用</span></span><br><span class="line"><span class="meta">(error)</span> <span class="string">NOAUTH Authentication required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证密码 auth &#123;密码&#125;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; auth 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.<strong>修改配置文件</strong></h4><!-- 永久生效-->

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到redis.conf配置文件中的requirepass</span></span><br><span class="line"><span class="comment">#requirepass foobared</span></span><br><span class="line"><span class="comment">#去掉注释配置自己密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">&#123;密码&#125;</span></span><br><span class="line"><span class="attr">保存后重启</span></span><br></pre></td></tr></table></figure>



<h3 id="五大基本类型"><a href="#五大基本类型" class="headerlink" title="五大基本类型"></a>五大基本类型</h3><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><p>​        String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<h5 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h5><ol>
<li><p>append key value ：往字符串后面追加字符串（若key不存在，则新建key，相当于set key value）</p>
</li>
<li><p>strlen key ：返回字符串长度</p>
</li>
<li><p>incr key： 自增1</p>
</li>
<li><p>decr key：自减1</p>
</li>
<li><p>incrby key num：自增num</p>
</li>
<li><p>decrby key num：自减num</p>
</li>
<li><p>getrange key start end ：截取字符串[start,end] [0,-1]表示全部</p>
</li>
<li><p>setrange key start str ：用str替换指定位置开始的字符串</p>
</li>
<li><p>setex  key seconds value：保存key-value并设置过期时间（set with expire）</p>
</li>
<li><p>setnx key value：不存在则设置（set if not exist），成功返回1，若已存在，则创建失败，返回-1</p>
</li>
<li><p>mset  k1 v1 k2 v2 k3 v3：同时设置多个值</p>
</li>
<li><p>mget  k1 k2 k3： 同时获取多个值</p>
</li>
<li><p>getset key value：先get后set，如果不存在则返回null，如果存在，则返回旧值，再设置新值</p>
</li>
</ol>
<h4 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h4><p>​        列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个链表。</p>
<h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li><p>LPUSH list value1  value2 value3 …… ：将一个或多个值插入列表头部（左部）</p>
</li>
<li><p>LRANGE  list start end ：[start,end]通过区间获取列表具体值,[0,-1]获取list全部</p>
</li>
<li><p>RPUSH list  value1  value2 value3 …… ：将一个或多个值插入列表尾部（右部）</p>
</li>
<li><p>LPOP list ：移除列表的第一个元素</p>
</li>
<li><p>RPOP list：移除列表的最后一个值</p>
</li>
<li><p>Lindex list  index ：通过下标获取 元素</p>
</li>
<li><p>Llen list：返回列表长度</p>
</li>
<li><p>Lrem lsit  count value：移除list中count个value</p>
</li>
<li><p>ltrim list start end：通过下标截取list，原list已经被改变</p>
</li>
<li><p>rpoplpush sourceList newList：移除sourceList列表的最后一个元素，将他移动到newList列表中</p>
</li>
<li><p>lset list index newvalue： 替换将列表指定下标值（list或index不存在则报错）</p>
</li>
<li><p>linsert list value before|after newValue：将某一个具体的newValue插入到第一个value前面|后面</p>
</li>
</ol>
<h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><p>Set是string类型的无序集合，不可重复。它是通过HashTable实现实现的。</p>
<h5 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li>sadd set value1 value2 value3 ……：往set集合添加元素</li>
<li>smembers set：查看set元素</li>
<li>sismembers set  value：是否存在指定元素（存在返回1，不存在返回0）</li>
<li>scard set：查看set集合元素数</li>
<li>srem set value ：移除set集合指定元素</li>
<li>srandmember set （count）：随机抽取num个元素（count不写默认一个）</li>
<li>spop  set （count）：随机移除count个元素</li>
<li>smove  set1 set2 value：将set1中value移动到set2中</li>
<li>sdiff set1 set2：set1与set2取差集，返回set1中存在，set2不存在的元素集合</li>
<li>sinter set1 set2 ：取交集</li>
<li>sunion set1 set2：取并集</li>
</ol>
<h4 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h4><p>hash 是一个键值对集合,是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;。</p>
<h5 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li>hset hash key value ：存入hash一个 key-value键值对</li>
<li>hget  hash key：获取hash中key的值</li>
<li>hmset hash key1 value1 key2 value2 ……：存入hash多个键值对</li>
<li>hmget hash key1 key2 ……：获取hash多个key字段的值</li>
<li>hgetall hash ：获取全部key-value内容</li>
<li>hdel hash key ：删除hash中指定key字段</li>
<li>hlen hash ：返回hash长度</li>
<li>hexists hash key：判断hash中key字段是否存在</li>
<li>hkeys hash：返回所有key字段</li>
<li>hvals  hash：放回所有value</li>
<li>hincrby hash key  num：指定key增量num</li>
<li>hsetnx hash key value：不存在则存入</li>
</ol>
<h4 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合(Zset)"></a>有序集合(Zset)</h4><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h5 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li><p>ZADD key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数.</p>
</li>
<li><p>ZCARD key 获取有序集合的成员数.</p>
</li>
<li><p>ZCOUNT key min max 计算在有序集合中指定区间分数[min,max]的成员数。</p>
</li>
<li><p>ZINCRBY key increment member:有序集合中对指定成员的分数加上增量 increment。</p>
</li>
<li><p>ZINTERSTORE newkey num key …:计算给定的一个或多(num)个有序集key的交集并将结果集存储在新的有序集合 newkey 中。</p>
</li>
<li><p>ZLEXCOUNT key min max:在有序集合中计算指定字典区间内成员数量。</p>
<p> min max: { - [a =(-∞，a]; -  (a=(-∞，a)；[a [b=[a,b];-  +=(-∞,+∞)</p>
</li>
<li><p>ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员。-inf +inf = -∞ +∞</p>
</li>
<li><p>ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员。</p>
</li>
<li><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员。</p>
</li>
<li><p>ZRANK key member 返回有序集合中指定成员的索引。</p>
</li>
<li><p>ZREM key member [member …] 移除有序集合中的一个或多个成员。</p>
</li>
<li><p>ZREMRANGEBYLEX key min max :移除有序集合中给定的字典区间的所有成员。</p>
</li>
<li><p>ZREMRANGEBYRANK key start stop:移除有序集合中给定的排名区间的所有成员。</p>
</li>
<li><p>ZREMRANGEBYSCORE key min max移除有序集合中给定的分数区间的所有成员。</p>
</li>
<li><p>ZREVRANGE key start stop [WITHSCORES]返回有序集中指定区间内的成员，通过索引，分数从高到低。</p>
</li>
<li><p>ZREVRANGEBYSCORE key max min [WITHSCORES]返回有序集中指定分数区间内的成员，分数从高到低排序。</p>
</li>
<li><p>ZREVRANK key member返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。</p>
</li>
<li><p>ZSCORE key member返回有序集中，成员的分数值。</p>
</li>
<li><p>ZUNIONSTORE destination numkeys key [key …]计算给定的一个或多个有序集的并集，并存储在新的 key 中。</p>
</li>
<li><p>ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）。</p>
</li>
</ol>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>​    集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，其实不太准确。</p>
<p>​    其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： </p>
<ul>
<li>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 </li>
<li>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) </li>
<li>其他的range操作复杂度一般为O(log(n))</li>
<li>当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</li>
</ul>
<h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="地理空间（geospatial-）"><a href="#地理空间（geospatial-）" class="headerlink" title="地理空间（geospatial ）"></a>地理空间（geospatial ）</h4><p>​    Redis的Geo，3.2版本推出，可以推算地理位置的信息，两地之间的距离</p>
<p>​    城市经纬度查询：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p>
<!--**注：有效经度为-180至180度。有效纬度为-85.05112878至85.05112878度。**-->

<h5 id="六大操作"><a href="#六大操作" class="headerlink" title="六大操作"></a>六大操作</h5><p><strong>geoadd   key  经度 维度 坐标名</strong>：添加地理位置（两级无法直接添加，可一次添加多个）， 先经度后维度（官方文档疑似写错了）</p>
<p>例：geoadd china:city   116.405285  39.904989     beijing    121.4   31.2  shanghai  ……</p>
<p>​                        key            经度     维度    地理名称</p>
<p><strong>geopos key  name1 name2……</strong>：获取key中name的地理位置</p>
<p>例：GEOPOS china:city beijing shanghai shenzhen xianggang</p>
<p><strong>georadius key  经度 维度 距离：</strong> 以给定的经纬度为中心，找出某一半径内所有的元素</p>
<p>例：GEORADIUS china:city 110 30 1000 km [withcoord] [withdist]</p>
<p><strong>GEORADIUSBYMEMBER key  坐标名（元素名） 距离</strong> ：根据给定的元素确定中心点，再进行查找</p>
<p>例：GEORADIUSBYMEMBER china:city beijing 1000 km [withcoord] [withdist]</p>
<!--注：withcoord：经纬度,withdist：距离坐标城市的距离，count num：筛选出num个结果-->

<p><strong>GEODIST  key name1  name2 [单位]</strong> ：返回指定单位中两个指定成员之间的距离。如果缺少一个或两个成员，该命令将返回NULL。</p>
<!--单位必须是以下之一，默认为米：m（米）、km（千米）、mi（英里）、ft（英尺）-->

<p>例：GEODIST china:city beijing xianggang km</p>
<p><strong>GEOHASH key name1 name2……</strong>：该命令返回11个字符的Geohash字符串，因此与Redis内部52位表示形式相比，不会损失任何精度。该命令返回一个数组，其中每个元素是与作为参数传递给命令的每个成员名称相对应的Geohash。</p>
<p>返回的Geohashhes具有以下属性：  </p>
<ol>
<li>以从右侧删除字符来缩短它们。它将失去精度，但仍将指向同一区域。</li>
<li>可以在<code>geohash.org</code>URL中使用它们，例如<code>http://geohash.org/&lt;geohash-string&gt;</code>。这是<a href="http://geohash.org/sqdtr74hyu0">此类URL</a>的<a href="http://geohash.org/sqdtr74hyu0">示例</a>。</li>
<li>前缀相似的字符串在附近，但事实并非如此，前缀不同的字符串也可能在附近。</li>
</ol>
<p>geo底层实现原理其实是zset，我们可以使用zset命令操作他</p>
<p>zrange key 0 -1：查看地图key中的所有元素</p>
<p>zrem key member：删除key中指定元素</p>
<h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p><strong>简介：Hyperloglog 可用于基数统计（基数：在数学上，是集合论中刻画任意集合集大小的一个概念。即一个集合中不重复的元素数。）</strong></p>
<p><strong>redis2.8.9后更新了hyperloglog数据结构</strong></p>
<p>示例：网页UV</p>
<p>uv（Unique Visitor）:网站的独立访客，统计1天内访问某站点的用户数(以cookie为依据);访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。</p>
<p>访问用户量大的情况下，若用传统的set集合统计将耗费大量内存。使用hyperloglog基数统计占用内存固定，2^64不同的元素，只需要废12kb内存。（官网统计hyperloglog有0.81%的错误率，但在统计UV任务上，我们可以忽略不计）</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>PFADD keyset  value1 value2 value3……往集合keyset中添加元素</p>
<p>PFCOUNT keyset：统计集合keyset的基数</p>
<p>PFMERGE  newset keyset1 ketset2：将集合keyset1和keyset2的元素合并（并集）到newset中</p>
<h4 id="Bitmap（位存储）"><a href="#Bitmap（位存储）" class="headerlink" title="Bitmap（位存储）"></a>Bitmap（位存储）</h4><p><strong>简介：</strong> Biymaps位图，该数据结构都是操作二进制位来记录数据的，就只有0和1两个状态。（适用于只有两个状态的数据）</p>
<h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p>setbit  sign index  value：往sign的index（从0开始）位置上存value（0或1）</p>
<p>getbit sign index ：获取sign中index位上的值（默认0）</p>
<p>bitcount sign：统计sgin中为1的数量</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.3.1.RELEASE与javaFx整合</title>
    <url>/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><figure class="highlight xml"><figcaption><span>&lt;dependency&gt;</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.roskenet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-javafx-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动类继承AbstractJavaFxApplicationSupport"><a href="#启动类继承AbstractJavaFxApplicationSupport" class="headerlink" title="启动类继承AbstractJavaFxApplicationSupport"></a>启动类继承AbstractJavaFxApplicationSupport</h2><p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375394146.png" alt="启动类"></p>
<h2 id="采用mvc模式"><a href="#采用mvc模式" class="headerlink" title="采用mvc模式"></a>采用mvc模式</h2><ul>
<li><h3 id="每个fxml页面都有对应的java视图类"><a href="#每个fxml页面都有对应的java视图类" class="headerlink" title="每个fxml页面都有对应的java视图类"></a>每个fxml页面都有对应的java视图类</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375588.png" alt="视图"></p>
<ul>
<li><h3 id="视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）"><a href="#视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）" class="headerlink" title="视图类需继承AbstractFxmlView且有**@FXMLView注解**（value值为对应的fxml文件路径）"></a>视图类需继承<strong>AbstractFxmlView</strong>且有**@FXMLView注解**（value值为对应的fxml文件路径）</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375950(1).jpg" alt="视图类"></p>
<ul>
<li><h3 id="fxml文件中需指定对应controller类"><a href="#fxml文件中需指定对应controller类" class="headerlink" title="fxml文件中需指定对应controller类"></a>fxml文件中需指定对应controller类</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376230(1).jpg" alt="fxml文件"></p>
<ul>
<li><h3 id="controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息"><a href="#controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息" class="headerlink" title="controller类需实现Initializable接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)"></a>controller类需实现<strong>Initializable</strong>接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376444(1).jpg"></p>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376926(1).jpg"></p>
<ul>
<li><h3 id="fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法"><a href="#fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法" class="headerlink" title="fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法"></a>fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377406(1).jpg"></p>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377507(1).jpg"></p>
<h2 id="示例页面效果展示-只是简单项目，页面可能有点丑"><a href="#示例页面效果展示-只是简单项目，页面可能有点丑" class="headerlink" title="示例页面效果展示(只是简单项目，页面可能有点丑)"></a>示例页面效果展示(只是简单项目，页面可能有点丑)</h2><ul>
<li><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377745(1).jpg" alt="登陆"></p>
<ul>
<li><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377865(1).jpg" alt="主页"></p>
<ul>
<li><h3 id="点击住宿按钮弹出住宿页面进行信息登记"><a href="#点击住宿按钮弹出住宿页面进行信息登记" class="headerlink" title="点击住宿按钮弹出住宿页面进行信息登记"></a>点击住宿按钮弹出住宿页面进行信息登记</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377915(1).jpg"></p>
<ul>
<li><h3 id="双击对应表格中的宿舍即可查看详情"><a href="#双击对应表格中的宿舍即可查看详情" class="headerlink" title="双击对应表格中的宿舍即可查看详情"></a>双击对应表格中的宿舍即可查看详情</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378007(1).jpg"></p>
<ul>
<li><h3 id="宿舍管理页面"><a href="#宿舍管理页面" class="headerlink" title="宿舍管理页面"></a>宿舍管理页面</h3></li>
</ul>
<p><img src="/2020/09/17/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378103(1).jpg"></p>
<h2 id="获取项目"><a href="#获取项目" class="headerlink" title="获取项目"></a>获取项目</h2><ul>
<li><h3 id="Git仓库地址"><a href="#Git仓库地址" class="headerlink" title="Git仓库地址"></a><a href="https://github.com/czmDeRepository/javaFx">Git仓库地址</a></h3></li>
<li><h3 id="注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql"><a href="#注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql" class="headerlink" title="注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql"></a><strong>注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql</strong></h3></li>
</ul>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>sql中distinct简单使用</title>
    <url>/2020/09/22/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"><a href="#简介：distinct常用于sql语句中查出重复数据时需要去重的时候" class="headerlink" title="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"></a><strong>简介：distinct常用于sql语句中查出重复数据时需要去重的时候</strong></h3><!--distinct不会过滤掉null值，返回结果包含null值-->

<p>示例：table</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td>null</td>
<td>f</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="只有一字段："><a href="#只有一字段：" class="headerlink" title="只有一字段："></a><strong>只有一字段</strong>：</h3><p>​        <strong>直接在字段前加distinct</strong></p>
<p>​        select distinct column1 from table</p>
<p>结果：</p>
<table>
<thead>
<tr>
<th>column1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
</tr>
<tr>
<td>2</td>
</tr>
<tr>
<td>3</td>
</tr>
<tr>
<td>null</td>
</tr>
<tr>
<td></td>
</tr>
</tbody></table>
<h3 id="需要查出多个字段："><a href="#需要查出多个字段：" class="headerlink" title="需要查出多个字段："></a><strong>需要查出多个字段</strong>：</h3><p>​    distinct 需要放在第一个字段前面，否者报错</p>
<p>select distinct colum1 , colum2 from table;</p>
<p>结果：多个字段其实是多个字段查出后拼接再去重</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td>null</td>
<td>f</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="只想一个字段唯一"><a href="#只想一个字段唯一" class="headerlink" title="只想一个字段唯一"></a><strong>只想一个字段唯一</strong></h3><p><strong>1.使用group by</strong></p>
<p>​    select column1, column2 from table group by column1</p>
<p><strong>2.使用GROUP_CONCAT函数</strong></p>
<p>​    <strong>GROUP_CONCAT在连接查询的时候，能让查出的这字段的多个数，按字符拼接的方式存放在一起。</strong></p>
<p>select GROUP_CONCAT(distinct column1) as column1, column2 from table group by column1</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>时间问题</title>
    <url>/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="MySQL数据库问题"><a href="#MySQL数据库问题" class="headerlink" title="MySQL数据库问题"></a>MySQL数据库问题</h3><p><strong>查询数据库时间</strong></p>
<ol>
<li>select sysdate();</li>
<li>select now();</li>
<li>select current_date;</li>
</ol>
<p><strong>连接url需指定serverTimezone</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://&#123;host&#125;:&#123;port&#125;/&#123;database&#125;?</span></span><br><span class="line"><span class="attr">useUnicode</span>=<span class="string">true&amp; //驱动程序在处理字符串时是否应使用Unicode字符编码？默认位true，设置false可能出现乱码</span></span><br><span class="line"><span class="attr">characterEncoding</span>=<span class="string">UTF-8&amp; //指定字符编码</span></span><br><span class="line"><span class="attr">serverTimezone</span>=<span class="string">Asia/Shanghai&amp; //指定时区位亚洲上海</span></span><br><span class="line"><span class="attr">useSSL</span>=<span class="string">false&amp; // 与服务器通信时使用ssl（true/false），连接到MySQL5.5.45+、5.6.26+或5.7.6+时默认为“true”，否则默认为“false”</span></span><br><span class="line"><span class="attr">allowPublicKeyRetrieval</span>=<span class="string">true //如果用户使用了 sha256_password 认证，密码在传输过程中必须使用 TLS 协议保护，但是如果 RSA 公钥不可用，可以使用服务器提供的公钥；可以在连接中通过 ServerRSAPublicKeyFile 指定服务器的 RSA 公钥，或者AllowPublicKeyRetrieval=True参数以允许客户端从服务器获取公钥；但是需要注意的是 AllowPublicKeyRetrieval=True可能会导致恶意的代理通过中间人攻击(MITM)获取到明文密码，所以默认是关闭的，必须显式开启</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器时间"><a href="#服务器时间" class="headerlink" title="服务器时间"></a>服务器时间</h3><ul>
<li>进入linux：输入date查看服务器时间</li>
</ul>
<p><img src="/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222100673.png" alt="image-20200915222100673"></p>
<ul>
<li><p>使用timedatectl命令</p>
<p>  timedatectl对于RHEL / CentOS 7和基于Fedora 21+的分布式系统来说，是一个新工具，它作为systemd系统和服务管理器的一部分，代替旧的传统的用在基于Linux分布式系统的sysvinit守护进程的date命令。</p>
<p>  <img src="/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222429047.png" alt="显示当前系统时间"></p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">使用timedatectl命令</span></span><br><span class="line"><span class="comment"># timedatectl list-timezones |grep Shanghai    #查找上海的完整名称</span></span><br><span class="line"><span class="attr">Asia/Shanghai</span></span><br><span class="line"><span class="comment"># timedatectl set-timezone Asia/Shanghai    #其他时区以此类推</span></span><br><span class="line"><span class="attr">或者直接手动创建软链接</span></span><br><span class="line"><span class="comment"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="docker容器时间"><a href="#docker容器时间" class="headerlink" title="docker容器时间"></a>docker容器时间</h3><p>进入docker命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker exec -it &#123;容器名或容器id&#125;  /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看时间命令：date</p>
<p>复制相应的时区文件，替换系统时区文件；</p>
<p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<p>有的容器基础镜像是有这个文件的，直接拷贝就可以，如果不能拷贝，则是因为创建镜像时依赖的基础镜像 运行的容器没有这两个文件，使用下面的办法</p>
<ol>
<li><p>创建文件夹</p>
<p> mkdir -p /usr/share/zoneinfo/Asia</p>
</li>
<li><p>回到宿主机，复制宿主机里的文件到容器中</p>
<p> docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或容器名:/usr/share/zoneinfo/Asia</p>
</li>
</ol>
<p>​    3.进入容器执行命令 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<h3 id="tomcat容器时区问题"><a href="#tomcat容器时区问题" class="headerlink" title="tomcat容器时区问题"></a>tomcat容器时区问题</h3><p><strong>描述：</strong>java的war包部署在Linux上的tomcat容器中相差8小时</p>
<p>解决：在tomcat的bin目录下找到catalina.sh文件在JAVA_OPTS追加添加如下配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Duser.timezone</span>=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/16/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915221437392.png" alt="image-20200915221437392"></p>
<!--注：若是在docker中的容器可先将其拷贝出来修改后再拷贝到docker中原来对应位置-->

<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ入门</title>
    <url>/2020/09/25/rabbitMq/</url>
    <content><![CDATA[<h2 id="消息中间件（MQ）"><a href="#消息中间件（MQ）" class="headerlink" title="消息中间件（MQ）"></a>消息中间件（MQ）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。——百度百科</p>
<p>​    MQ全称为Message Queue，消息队列是程序和程序之间的通信方法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>实现项目通讯与解耦   </li>
</ul>
<p>MQ相当于一个中介，消息生产方将消息发给MQ，消息消费方接收消息并进行相应逻辑处理，它将两应用程序进行解耦合。</p>
<ul>
<li>处理异步任务</li>
</ul>
<p>​        在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<ul>
<li>   削峰填谷</li>
</ul>
<p>  如订单抢票系统，开始抢票瞬间高请求，高并发，若此时都操作数据库，需要大量IO操作，消耗系统性能，系统很可能崩溃，我们可以先将订单存消息队列里，然后系统就可以避开高峰期再按照自己的消费能力消费消息队列里的消息。</p>
<h2 id="主流实现方式"><a href="#主流实现方式" class="headerlink" title="主流实现方式"></a>主流实现方式</h2><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>​    AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF/1619218">消息</a>队列协议，是<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788">应用层</a>协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240">中间件</a>不同产品，不同的开发语言等条件的限制。<a href="https://baike.baidu.com/item/Erlang">Erlang</a>中的实现有<a href="https://baike.baidu.com/item/RabbitMQ">RabbitMQ</a>等。                                                                                                                               ——百度百科</p>
<p>AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>​    JMS即Java消息服务（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/5899771">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中发送消息，进行<a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/2273903">异步通信</a>。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。                                                                                                                                                                                                    ——百度百科</p>
<h3 id="AMQP-与-JMS-区别"><a href="#AMQP-与-JMS-区别" class="headerlink" title="AMQP 与 JMS 区别"></a>AMQP 与 JMS 区别</h3><ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li>
</ul>
<h3 id="常见的消息队列"><a href="#常见的消息队列" class="headerlink" title="常见的消息队列"></a>常见的消息队列</h3><ul>
<li>ActiveMQ：基于JMS</li>
<li>ZeroMQ：基于C语言开发</li>
<li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li>
<li>RocketMQ：基于JMS，阿里巴巴产品</li>
<li>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a href="http://www.rabbitmq.com/">官网</a></p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/%E5%BA%93">库</a>。        ——百度百科</p>
<h3 id="6种模式"><a href="#6种模式" class="headerlink" title="6种模式"></a>6种模式</h3><ul>
<li><p>简单模式：一个生产者发送消息到队列,一个消费者接收，不需要设置交换机（使用默认的交换机）</p>
</li>
<li><p>work工作队列模式，一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者竞争同一个队列的消息</p>
</li>
<li><p>Publish/Subscribe发布与订阅模式：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者</p>
</li>
<li><p>Routing路由模式（direct模式）：生产者发送消息到交换机并且要指定路由key，消费者将队列绑定到交换机时需要指定路由key</p>
</li>
<li><p>Topics通配符模式:  生产者发送消息到交换机，交换机类型设置topic，交换机根据绑定队列的routing key的值进行通配符匹配，</p>
<p>  “#”：匹配零个或者多个词topic.# 可以匹配topic，topic.text，topic.test.queue</p>
<p>  “<em>“：匹配l零个或一个词，topic.</em> 可以匹配topic，topic.text或topic.queue</p>
</li>
<li><p>RPC远程调用模式：功能如名，调用远程项目的功能并等待结果。</p>
</li>
</ul>
<h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><h4 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a><strong>maven坐标</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="java代码示例"><a href="#java代码示例" class="headerlink" title="java代码示例"></a>java代码示例</h4><p>注：这里以direct模式示例，其他模式类似</p>
<h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置Rabbitmq主机地址,默认localhost</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//设置端口,默认5672</span></span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line"><span class="comment">//设置虚拟主机，默认 /</span></span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line"><span class="comment">//连接密码；默认为guest</span></span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//通过连接工厂创建连接</span></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">// 通过connection创建一个Channel通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的信息</span></span><br><span class="line">String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">				.deliveryMode(<span class="number">2</span>)<span class="comment">//2消息持久化；1重启消息丢失</span></span><br><span class="line">				.contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">				.expiration(<span class="string">&quot;10000&quot;</span>)<span class="comment">//十秒失效</span></span><br><span class="line">				.headers(headers)</span><br><span class="line">				.build();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span></span><br><span class="line"><span class="comment">* 参数2：路由key,简单模式可以传递队列名称</span></span><br><span class="line"><span class="comment">* 参数3：消息其它属性</span></span><br><span class="line"><span class="comment">* 参数4：消息内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;test_direct_exchange&quot;</span>, <span class="string">&quot;test.direct&quot;</span>, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory() ;  </span><br><span class="line"></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//自动恢复连接</span></span><br><span class="line">connectionFactory.setAutomaticRecoveryEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//自动恢复在尝试重新连接之前要等待多长时间，默认5000ms</span></span><br><span class="line">connectionFactory.setNetworkRecoveryInterval(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">Channel channel = connection.createChannel();  </span><br><span class="line"><span class="comment">//4 声明</span></span><br><span class="line">String exchangeName = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line">String exchangeType = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">String queueName = <span class="string">&quot;test_direct_queue&quot;</span>;</span><br><span class="line">String routingKey = <span class="string">&quot;test.direct&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示声明了一个交换机</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, exchangeType, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 声明（创建）队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：队列名称</span></span><br><span class="line"><span class="comment">* 参数2：是否持久化队列</span></span><br><span class="line"><span class="comment">* 参数3：是否独占连接</span></span><br><span class="line"><span class="comment">* 参数4：是否在不使用的时候自动删除队列</span></span><br><span class="line"><span class="comment">* 参数5：队列其它参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//建立一个绑定关系:</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//durable 是否持久化消息</span></span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//参数：队列名称、是否自动ACK、Consumer</span></span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"><span class="comment">//循环获取消息  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">    <span class="comment">//获取消息，如果没有消息，这一步将会一直阻塞  </span></span><br><span class="line">    Delivery delivery = consumer.nextDelivery();  </span><br><span class="line">    String msg = <span class="keyword">new</span> String(delivery.getBody());    </span><br><span class="line">    System.out.println(<span class="string">&quot;收到消息：&quot;</span> + msg);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="用xml配置方式与spring整合"><a href="#用xml配置方式与spring整合" class="headerlink" title="用xml配置方式与spring整合"></a>用xml配置方式与spring整合</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><h5 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h5><p>注：以下配置rabbitMQ可靠性投递用到，消息的延迟投递，做二次确认，回调检查</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入spring配置文件 ，便于下方配置变量引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:application.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 创建连接类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;rabbitmqConnectionFactory&quot;  class=&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg value=&quot;localhost&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的账户,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;username&quot; value=&quot;$&#123;rmq.manager.user&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的密码,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;password&quot; value=&quot;$&#123;rmq.manager.password&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- host,RabbitMQ服务器地址，默认值&quot;localhost&quot; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;host&quot; value=&quot;$&#123;rmq.ip&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- port，RabbitMQ服务端口，默认值为5672 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;port&quot; value=&quot;$&#123;rmq.port&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- channel-cache-size，channel的缓存数量，默认值为25 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;channel-cache-size&quot; value=&quot;50&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--cache-mode，缓存连接模式，默认值为CHANNEL(单个connection连接，连接之后关闭，自动销毁) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;cache-mode&quot; value=&quot;CHANNEL&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--或者这样配置，connection-factory元素实际就是注册一个org.springframework.amqp.rabbit.connection.CachingConnectionFactory实例--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;$&#123;rmq.ip&#125;&quot;</span> <span class="attr">port</span>=<span class="string">&quot;$&#123;rmq.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    							<span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;rmq.manager.virtual&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;$&#123;rmq.manager.user&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;$&#123;rmq.manager.password&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span> <span class="attr">publisher-returns</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--注：publisher-confirms=&quot;true&quot; publisher-returns=&quot;true&quot;用于开启消息投递的回调监听，若想使用必须配置--&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产者部分 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发送消息的producer类，也就是生产者 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;RabbitmqProduct&quot;</span> <span class="attr">class</span>=<span class="string">&quot;生产者类路径&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--routingKey的 value中的值就是producer中的的routingKey，它与上面的rabbit:bindings标签中的key必须相同 -&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;exchange&quot; value=&quot;$&#123;rmq.manager.exchange&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;routingKey&quot; value=&quot;$&#123;rmq.manager.routingKey&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;delayKey&quot; value=&quot;$&#123;rmq.manager.key_delay&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;rabbitTemplate&quot; ref=&quot;rabbitTemplate&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;!-- spring amqp默认的是jackson 的一个插件,目的将生产者生产的数据转换为json存入消息队列，由于fastjson的速度快于jackson,这里替换为fastjson的一个实现 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;jsonMessageConverter&quot; class=&quot;com.jy.utils.FastJsonMessageConverter&quot;&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或者配置jackson --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--消息成功投递后回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--消息找不到对应交换机或routingkey，投递失败回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--exchange=&quot;Anyview_exchange&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span>  <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">confirm-callback</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">return-callback</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">mandatory</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费者部分 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义消息队列,durable:是否持久化，</span></span><br><span class="line"><span class="comment">    如果想在RabbitMQ退出或崩溃的时候，不会失去所有的queue和消息，需要同时标志队列(queue)和交换机(exchange)是持久化的，	即rabbit:queue标签和rabbit:direct-exchange中的durable=true,而消息(message)默认是持久化的可以看类			org.springframework.amqp.core.MessageProperties中的属性</span></span><br><span class="line"><span class="comment">	public static final MessageDeliveryMode DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span></span><br><span class="line"><span class="comment">    exclusive: 仅创建者可以使用的私有队列，断开后自动删除；</span></span><br><span class="line"><span class="comment">    auto_delete: 当所有消费客户端连接断开后，是否自动删除队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--延时队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_delay&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  队列过期时间 10秒--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;java.lang.Long&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过期后消息将通过以下交换机和routingkey发送到死信队列--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-routing-key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--绑定队列,</span></span><br><span class="line"><span class="comment">rabbitmq的exchangeType常用的三种模式：direct，fanout，topic三种,</span></span><br><span class="line"><span class="comment">我们用direct模式，即rabbit:direct-exchange标签，Direct交换器很简单，</span></span><br><span class="line"><span class="comment">如果是Direct类型，就会将消息中的RoutingKey与该Exchange关联的所有Binding中的BindingKey进行比较，</span></span><br><span class="line"><span class="comment">如果相等，则发送到该Binding对应的Queue中。有一个需要注意的地方：如果找不到指定的exchange，就会报错。</span></span><br><span class="line"><span class="comment">但routing key找不到的话，不会报错，这条消息会直接丢失，所以此处要小心,</span></span><br><span class="line"><span class="comment">auto-delete:自动删除，如果为Yes，则该交换机所有队列queue删除后，自动删除交换机，默认为false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.routingKey&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_delay&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--死信队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange_dead&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于消息的监听的代理类MessageListenerAdapter --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;testQueueListenerAdapter&quot; class=&quot;org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter&quot; &gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg ref=&quot;Handler&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;defaultListenerMethod&quot; value=&quot;handlerTest&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;messageConverter&quot; ref=&quot;jsonMessageConverter&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;rabbit:direct-exchange id=&quot;$&#123;rmq.manager.exchange&#125;&quot; name=&quot;$&#123;rmq.manager.exchange&#125;&quot;  durable=&quot;false&quot; auto-delete=&quot;false&quot; &gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;/rabbit:direct-exchange&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义接口类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Handler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;消息类路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置监听acknowledeg=&quot;manual&quot;设置手动应答，它能够保证即使在一个worker处理消息的时候用CTRL+C来杀掉这个		worker，或者一个consumer挂了(channel关闭了、connection关闭了或者TCP连接断了)，也不会丢失消息。</span></span><br><span class="line"><span class="comment">    因为RabbitMQ知道没发送ack确认消息导致这个消息没有被完全处理，将会对这条消息做re-queue处理。</span></span><br><span class="line"><span class="comment">    如果此时有另一个consumer连接，消息会被重新发送至另一个consumer会一直重发,直到消息处理成功,</span></span><br><span class="line"><span class="comment">    监听容器acknowledge=&quot;auto&quot; concurrency=&quot;30&quot;设置发送次数,最多发送30次 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--concurrency=&quot;20&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Handler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="keyword">private</span> String routingKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String delayKey;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*此服务用于将消息持久化</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"> 	<span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rabbitmq发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketMsg 消息实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isFirst 是否第一次发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(SocketMsg socketMsg, <span class="keyword">boolean</span> isFirst)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次发送前先持久化</span></span><br><span class="line">        <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">            socketMsgService.insert(socketMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CorrelationData消息唯一ID</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object jsonSocketMsg = JSON.toJSON(socketMsg);</span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,routingKey, jsonSocketMsg, </span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()));</span><br><span class="line">            <span class="comment">//发送到延时队列</span></span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,delayKey, jsonSocketMsg,</span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()+<span class="string">&quot;delay&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExchange</span><span class="params">(String exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoutingKey</span><span class="params">(String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayKey</span><span class="params">(String delayKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayKey = delayKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="延时队列消费者代码"><a href="#延时队列消费者代码" class="headerlink" title="延时队列消费者代码"></a>延时队列消费者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitmqProduct rabbitmqProduct;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        Object parse = JSONObject.parse(message.getBody());</span><br><span class="line">        log.info(parse.toString());</span><br><span class="line">        SocketMsg socketMsg = JSONObject.parseObject(message.getBody(), SocketMsg.class);</span><br><span class="line">        log.info(socketMsg.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息未成功投递</span></span><br><span class="line">        <span class="keyword">if</span>(socketMsgService.findById(socketMsg.getId()).getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//未超过重试次数</span></span><br><span class="line">            <span class="keyword">if</span> (socketMsgService.getTryCountById(socketMsg.getId()) &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//添加重试次数</span></span><br><span class="line">                socketMsgService.addTryCountById(socketMsg.getId());</span><br><span class="line">                rabbitmqProduct.sendMessage(socketMsg, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="投递成功回调类"><a href="#投递成功回调类" class="headerlink" title="投递成功回调类"></a>投递成功回调类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;confirmCallBackListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallBackListener</span> <span class="keyword">implements</span> <span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;################发送到exchange成功:&quot;</span>+correlationData);</span><br><span class="line">            <span class="comment">//非延时队列的消息确认</span></span><br><span class="line">            <span class="keyword">if</span> (!correlationData.getId().endsWith(<span class="string">&quot;delay&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//将数据库消息标志置为成功发送</span></span><br><span class="line">                socketMsgService.succeedSendById(Long.parseLong(correlationData.getId()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;#########发送失败:&quot;</span>+correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="投递失败回调类"><a href="#投递失败回调类" class="headerlink" title="投递失败回调类"></a>投递失败回调类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallBackListener</span> <span class="keyword">implements</span> <span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, </span></span></span><br><span class="line"><span class="function"><span class="params">                                String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;无对应key队列，发送失败了&quot;</span>+message);</span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><h5 id="配置与上面延时队列的消息接收方类似，此处不再累赘"><a href="#配置与上面延时队列的消息接收方类似，此处不再累赘" class="headerlink" title="配置与上面延时队列的消息接收方类似，此处不再累赘"></a>配置与上面延时队列的消息接收方类似，此处不再累赘</h5><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
</search>
