<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Redis事务与配置</title>
    <url>/2020/09/24/Redis/Redis%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="通常情况下的事务"><a href="#通常情况下的事务" class="headerlink" title="通常情况下的事务"></a>通常情况下的事务</h3><h4 id="事务的基本要素即四大特性（ACID）"><a href="#事务的基本要素即四大特性（ACID）" class="headerlink" title="事务的基本要素即四大特性（ACID）"></a>事务的基本要素即四大特性（ACID）</h4><ul>
<li><p>原子性（Atomicity）：事务所有操作指令，要么全部完成，要么全部不做。</p>
</li>
<li><p>一致性（Consistency）：事务提交后，数据库从一个一致性状态变到另一个一致性状态。</p>
<p>  如事务（a-100，b+100）执行后a减100，b一定加100，不然a，b就都不变</p>
</li>
<li><p>隔离性（Isolation）：同一时间，只允许一个事务操作同一数据，不同的事务之间彼此没有任何干扰。</p>
</li>
<li><p>持久性（Durability）：事务一旦提交后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
</li>
</ul>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>​     本质：一组指令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行！</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li><p><strong>Redis事务没有隔离级别的概念！</strong></p>
<p> 一个事务的所有指令并没有被直接执行，而是存入队列中，只有发起执行命令（Exec）的时候才会顺序执行！</p>
</li>
<li><p><strong>Redis单条命令保证原子性，但是事务不保证原子性！</strong></p>
</li>
<li><p><strong>单独的隔离操作</strong></p>
<p> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
</ol>
<h4 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h4><ol>
<li>开启事务：multi</li>
<li>输入命令入队列：set key value  ……</li>
<li>提交事务：exec  或 撤销事务：discard</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get key2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">OK</span><br><span class="line">OK</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h5><p>​        命令有问题，事务所有的命令都不会被执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> key1 1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> key2  <span class="comment">#错误命令</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">EXECABORT Transaction discarded because of previous errors.  <span class="comment">#执行事务报错</span></span><br><span class="line">&gt; get key2  </span><br><span class="line">null</span><br><span class="line">&gt; get key1 <span class="comment">#所有命令都不会被执行</span></span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h5 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h5><p>​    如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的（Redis事务不保证原子性）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k1 abc</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> k2 2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr k1  <span class="comment">#k1为字符串，无法加1</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) (<span class="built_in">integer</span>) 3</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range  <span class="comment"># incr k1执行报错</span></span><br><span class="line">4) <span class="string">&quot;abc&quot;</span></span><br><span class="line">5) <span class="string">&quot;3&quot;</span></span><br><span class="line">&gt; get k2  <span class="comment">#其他命令正常执行</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="监控watch"><a href="#监控watch" class="headerlink" title="监控watch"></a>监控watch</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​    很悲观，总是认为最坏情况，拿数据的时候数据都会被别人修改，无论什么时候都加锁，效率低下</p>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​    很乐观，总是认为最好情况，拿数据的时候数据都不会被别人修改，所以不加锁，在更新数据的时候先判断下，拿数据这期间有没有人修改过此数据（mysql中可增加一版本字段version，更新前比较此字段）</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="正常测试"><a href="#正常测试" class="headerlink" title="正常测试"></a>正常测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money对象</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi   </span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#事务正常结束，数据期间没有发生变动，这时候事务正常执行</span></span><br><span class="line">80</span><br><span class="line">20</span><br><span class="line">&gt; get money</span><br><span class="line">80</span><br></pre></td></tr></table></figure>

<p>使用多客户端即多线程修改值，使用watch可以当作Redis的乐观锁操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> usedMoney 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money  <span class="comment">#监视money</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span>  <span class="comment">#执行之前，其他客户端执行 set money 10</span></span><br><span class="line">null  <span class="comment">#对比watch监控的money，发生变化，修改失败</span></span><br><span class="line"></span><br><span class="line">&gt; unwatch  <span class="comment">#执行失败，就先解锁</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money <span class="comment">#获取最新值，再次监控（此时money=10，usedMoney=0）</span></span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; decrby money 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incrby usedMoney 5</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">&gt; get money</span><br><span class="line">5</span><br><span class="line">&gt; get usedMoney</span><br><span class="line">5</span><br></pre></td></tr></table></figure>



<h2 id="配置文件Redis-conf"><a href="#配置文件Redis-conf" class="headerlink" title="配置文件Redis.conf"></a>配置文件Redis.conf</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unit(单位)</span><br><span class="line"><span class="comment"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span></span><br><span class="line">只支持bytes，不支持bit，对大小写不敏感</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INCLUDES模块</span><br><span class="line"><span class="comment"># include .\path\to\local.conf</span></span><br><span class="line"><span class="comment"># include c:\path\to\other.conf</span></span><br><span class="line">可通过include 包含其他文件</span><br><span class="line"></span><br><span class="line">网络</span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment">#绑定ip</span></span><br><span class="line">port 6379	<span class="comment">#端口</span></span><br><span class="line">protected-mode yes <span class="comment">#保护模式，默认开启</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GENERAL通用配置模块</span><br><span class="line">daemonize yes <span class="comment">#以守护进程执行（后台与运行）</span></span><br><span class="line">pidfile /var/run/redis.pid <span class="comment">#如果以守护进程方式运行，需指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice <span class="comment">#日志级别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment">#日志文件位置</span></span><br><span class="line">databases 16 <span class="comment">#数据库数量</span></span><br><span class="line"></span><br><span class="line">Tcp-keepalive <span class="comment">#连接检测，单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60 </span></span><br><span class="line">tcp-backlog</span><br><span class="line"><span class="comment">#设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。在高并发环境</span></span><br><span class="line"><span class="comment">#下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以</span></span><br><span class="line"><span class="comment">#需要确认增大somaxconntcp_max_syn_backlog两个值来达到想要的效果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SNAPSHOTTING快照模块</span><br><span class="line"><span class="comment">#达到已下条件，就进行保存</span></span><br><span class="line">save 900 1 <span class="comment">#15分钟内改了1次。</span></span><br><span class="line">save 300 10 <span class="comment">#5分钟内改了10次，</span></span><br><span class="line">save 60 10000 <span class="comment">#1分钟内改了1万次，</span></span><br><span class="line"><span class="comment">#如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以</span></span><br><span class="line">save <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#持久化操作出错，是否继续工作</span></span><br><span class="line">rdbcompression yes  <span class="comment">#对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能</span></span><br><span class="line"></span><br><span class="line">rdbchecksum yes <span class="comment">#存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能</span></span><br><span class="line">dir ./ <span class="comment">#db文件的保存路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECURITY安全模块</span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass <span class="string">&quot;&quot;</span>  <span class="comment">#配置redis密码，默认空</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LIMITS限制模块</span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"><span class="comment">#设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"><span class="comment">#设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</span></span><br><span class="line"><span class="comment">#如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信</span></span><br><span class="line"><span class="comment">#息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从#redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，</span></span><br><span class="line"><span class="comment">#才不用考虑这个因素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">maxmemory-policy noeviction  <span class="comment">#内存达到上限后处理策略</span></span><br><span class="line"><span class="comment">#（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（2）allkeys-lru：使用LRU算法移除key</span></span><br><span class="line"><span class="comment">#（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键</span></span><br><span class="line"><span class="comment">#（4）allkeys-random：移除随机的key</span></span><br><span class="line"><span class="comment">#（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</span></span><br><span class="line"><span class="comment">#（6）noeviction：不进行移除。针对写操作，只是返回错误信息</span></span><br><span class="line"></span><br><span class="line">maxmemory-samples 5 <span class="comment">#设置检查的样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，</span></span><br><span class="line"><span class="comment">#redis默认会检查这么多个key并选择其中LRU的那个，LRU和最小TTL算法不是精确算法而是近似算法，该值越大越精准，但cpu成本高，</span></span><br><span class="line"><span class="comment">#3较快，默认5，10非常接近</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">APPEND ONLY MODE附加模块</span><br><span class="line">appendonly no <span class="comment">#指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时</span></span><br><span class="line"><span class="comment">#导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</span></span><br><span class="line"><span class="comment">#默认为no</span></span><br><span class="line">appendfsync everysec  <span class="comment">#指定更新日志条件，共有3个可选值： </span></span><br><span class="line"><span class="comment">#  no：表示等操作系统进行数据缓存同步到磁盘（快） </span></span><br><span class="line"><span class="comment">#  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） </span></span><br><span class="line"><span class="comment">#  everysec：表示每秒同步一次（折衷，默认值）</span></span><br><span class="line"></span><br><span class="line">appendfilename appendonly.aof <span class="comment">#指定更新日志文件名，默认为appendonly.aof</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">No-appendfsync-on-rewrite no <span class="comment">#重写时是否可以运用Appendfsync，用默认no即可，保证数据安全性。</span></span><br><span class="line"></span><br><span class="line">Auto-aof-rewrite-min-size 64mb <span class="comment">#设置重写的基准值 大小</span></span><br><span class="line">Auto-aof-rewrite-percentage  100 <span class="comment"># 设置重写的基准值 百分比</span></span><br><span class="line"></span><br><span class="line">vm-enabled no <span class="comment">#指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷</span></span><br><span class="line"><span class="comment">#数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</span></span><br><span class="line">   </span><br><span class="line">vm-swap-file /tmp/redis.swap <span class="comment"># 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span></span><br><span class="line">   </span><br><span class="line">vm-max-memory 0 <span class="comment">#将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span></span><br><span class="line">   </span><br><span class="line">vm-page-size 32 <span class="comment"># Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，</span></span><br><span class="line"><span class="comment">#vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很</span></span><br><span class="line"><span class="comment">#大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span></span><br><span class="line">   </span><br><span class="line">vm-pages 134217728 <span class="comment"># 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘</span></span><br><span class="line"><span class="comment">#上每8个pages将消耗1byte的内存。</span></span><br><span class="line">   </span><br><span class="line">vm-max-threads 4 <span class="comment"># 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，</span></span><br><span class="line"><span class="comment">#可能会造成比较长时间的延迟。默认值为4</span></span><br><span class="line">   </span><br><span class="line">glueoutputbuf yes <span class="comment"># 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis之java简单使用</title>
    <url>/2020/09/25/Redis/Redis%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="jedis"><a href="#jedis" class="headerlink" title="jedis"></a>jedis</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​    Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉 </p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h5 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="代码示例（与命令行操作基本一致）"><a href="#代码示例（与命令行操作基本一致）" class="headerlink" title="代码示例（与命令行操作基本一致）"></a>代码示例（与命令行操作基本一致）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"> <span class="comment">//验证密码，如果没有设置密码这段代码省略</span></span><br><span class="line">jedis.auth(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;清空数据：&quot;</span>+jedis.flushDB());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;判断某个键是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;username&#x27;,&#x27;kuangshen&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;kuangshen&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;新增&lt;&#x27;password&#x27;,&#x27;password&#x27;&gt;的键值对：&quot;</span>+jedis.set(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.print(<span class="string">&quot;系统中所有的键如下：&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys);</span><br><span class="line">System.out.println(<span class="string">&quot;删除键password:&quot;</span>+jedis.del(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断键password是否存在：&quot;</span>+jedis.exists(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;查看键username所存储的值的类型：&quot;</span>+jedis.type(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;随机返回key空间的一个：&quot;</span>+jedis.randomKey());</span><br><span class="line">System.out.println(<span class="string">&quot;重命名key：&quot;</span>+jedis.rename(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;取出改后的name：&quot;</span>+jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;按索引查询：&quot;</span>+jedis.select(<span class="number">0</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除当前选择数据库中的所有key：&quot;</span>+jedis.flushDB());</span><br><span class="line">System.out.println(<span class="string">&quot;返回当前数据库中key的数目：&quot;</span>+jedis.dbSize());</span><br><span class="line">System.out.println(<span class="string">&quot;删除所有数据库中的所有key：&quot;</span>+jedis.flushAll());</span><br><span class="line">System.out.println(<span class="string">&quot;增加多个键值对：&quot;</span>+jedis.mset(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;value01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;value02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;value03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>,<span class="string">&quot;key04&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除多个键值对：&quot;</span>+jedis.del(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取多个键值对：&quot;</span>+jedis.mget(<span class="string">&quot;key01&quot;</span>,<span class="string">&quot;key02&quot;</span>,<span class="string">&quot;key03&quot;</span>));</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;value3&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;key4&quot;</span>,<span class="string">&quot;value4&quot;</span>);</span><br><span class="line"><span class="comment">//添加名称为hash（key）的hash元素</span></span><br><span class="line">jedis.hmset(<span class="string">&quot;hash&quot;</span>,map);</span><br><span class="line"><span class="comment">//向名称为hash的hash中添加key为key5，value为value5元素</span></span><br><span class="line">jedis.hset(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key5&quot;</span>, <span class="string">&quot;value5&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Map&lt;String,String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键为：&quot;</span>+jedis.hkeys(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return Set&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有值为：&quot;</span>+jedis.hvals(<span class="string">&quot;hash&quot;</span>));<span class="comment">//return List&lt;String&gt;</span></span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">6</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;将key6保存的值加上一个整数，如果key6不存在则添加key6：&quot;</span>+jedis.hincrBy(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key6&quot;</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;删除一个或者多个键值对：&quot;</span>+jedis.hdel(<span class="string">&quot;hash&quot;</span>, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash的所有键值对为：&quot;</span>+jedis.hgetAll(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;散列hash中键值对的个数：&quot;</span>+jedis.hlen(<span class="string">&quot;hash&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key2：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;判断hash中是否存在key3：&quot;</span>+jedis.hexists(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;获取hash中的值：&quot;</span>+jedis.hmget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;key3&quot;</span>,<span class="string">&quot;key4&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//……其他类型操作类似，可参考redis命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//redis事务</span></span><br><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">jsonObject.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">jsonObject.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction multi = jedis.multi();</span><br><span class="line">String result = jsonObject.toJSONString();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//向redis存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json&quot;</span>, result);</span><br><span class="line">    <span class="comment">//再存入一条数据</span></span><br><span class="line">    multi.set(<span class="string">&quot;json2&quot;</span>, result);</span><br><span class="line">    <span class="comment">//这里引发了异常，用0作为被除数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果没有引发异常，执行进入队列的命令</span></span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//如果出现异常，回滚</span></span><br><span class="line">    multi.discard();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json&quot;</span>));</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;json2&quot;</span>));</span><br><span class="line">    <span class="comment">//最终关闭客户端</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Redis与SpringBoot整合"><a href="#Redis与SpringBoot整合" class="headerlink" title="Redis与SpringBoot整合"></a>Redis与SpringBoot整合</h2><h3 id="maven依赖-1"><a href="#maven依赖-1" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#数据库索引，默认0</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> </span><br><span class="line">      <span class="attr">jedis:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池最大连接数 </span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment">#连接池最大阻塞连接时间，负值表示无限制</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">5</span> <span class="comment">#连接池中最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment">#连接池最小空闲连接</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">shutdown-timeout:</span> <span class="string">100ms</span> <span class="comment">#关闭超时时间，默认100ms</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义Redistemplate模板"><a href="#自定义Redistemplate模板" class="headerlink" title="自定义Redistemplate模板"></a>自定义Redistemplate模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">      template.setConnectionFactory(factory);</span><br><span class="line">      Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> 							</span><br><span class="line">          													Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">      <span class="comment">//解决缓存转换异常的问题</span></span><br><span class="line">      ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//设置所有访问权限以及所有的实际类型都可序列化和反序列化</span></span><br><span class="line">      om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">       <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的 </span></span><br><span class="line">      om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">      </span><br><span class="line">      jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">      StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">      template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">      template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">      <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">      template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">      template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//必须执行这个函数,初始化RedisTemplate</span></span><br><span class="line">      template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>时间问题</title>
    <url>/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="MySQL数据库问题"><a href="#MySQL数据库问题" class="headerlink" title="MySQL数据库问题"></a>MySQL数据库问题</h3><p><strong>查询数据库时间</strong></p>
<ol>
<li>select sysdate();</li>
<li>select now();</li>
<li>select current_date;</li>
</ol>
<p><strong>连接url需指定serverTimezone</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://&#123;host&#125;:&#123;port&#125;/&#123;database&#125;?</span></span><br><span class="line"><span class="attr">useUnicode</span>=<span class="string">true&amp; //驱动程序在处理字符串时是否应使用Unicode字符编码？默认位true，设置false可能出现乱码</span></span><br><span class="line"><span class="attr">characterEncoding</span>=<span class="string">UTF-8&amp; //指定字符编码</span></span><br><span class="line"><span class="attr">serverTimezone</span>=<span class="string">Asia/Shanghai&amp; //指定时区位亚洲上海</span></span><br><span class="line"><span class="attr">useSSL</span>=<span class="string">false&amp; // 与服务器通信时使用ssl（true/false），连接到MySQL5.5.45+、5.6.26+或5.7.6+时默认为“true”，否则默认为“false”</span></span><br><span class="line"><span class="attr">allowPublicKeyRetrieval</span>=<span class="string">true //如果用户使用了 sha256_password 认证，密码在传输过程中必须使用 TLS 协议保护，但是如果 RSA 公钥不可用，可以使用服务器提供的公钥；可以在连接中通过 ServerRSAPublicKeyFile 指定服务器的 RSA 公钥，或者AllowPublicKeyRetrieval=True参数以允许客户端从服务器获取公钥；但是需要注意的是 AllowPublicKeyRetrieval=True可能会导致恶意的代理通过中间人攻击(MITM)获取到明文密码，所以默认是关闭的，必须显式开启</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器时间"><a href="#服务器时间" class="headerlink" title="服务器时间"></a>服务器时间</h3><ul>
<li>进入linux：输入date查看服务器时间</li>
</ul>
<p><img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222100673.png" alt="image-20200915222100673"></p>
<ul>
<li><p>使用timedatectl命令</p>
<p>  timedatectl对于RHEL / CentOS 7和基于Fedora 21+的分布式系统来说，是一个新工具，它作为systemd系统和服务管理器的一部分，代替旧的传统的用在基于Linux分布式系统的sysvinit守护进程的date命令。</p>
<p>  <img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915222429047.png" alt="显示当前系统时间"></p>
  <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">使用timedatectl命令</span></span><br><span class="line"><span class="comment"># timedatectl list-timezones |grep Shanghai    #查找上海的完整名称</span></span><br><span class="line"><span class="attr">Asia/Shanghai</span></span><br><span class="line"><span class="comment"># timedatectl set-timezone Asia/Shanghai    #其他时区以此类推</span></span><br><span class="line"><span class="attr">或者直接手动创建软链接</span></span><br><span class="line"><span class="comment"># ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="docker容器时间"><a href="#docker容器时间" class="headerlink" title="docker容器时间"></a>docker容器时间</h3><p>进入docker命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker exec -it &#123;容器名或容器id&#125;  /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看时间命令：date</p>
<p>复制相应的时区文件，替换系统时区文件；</p>
<p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<p>有的容器基础镜像是有这个文件的，直接拷贝就可以，如果不能拷贝，则是因为创建镜像时依赖的基础镜像 运行的容器没有这两个文件，使用下面的办法</p>
<ol>
<li><p>创建文件夹</p>
<p> mkdir -p /usr/share/zoneinfo/Asia</p>
</li>
<li><p>回到宿主机，复制宿主机里的文件到容器中</p>
<p> docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或容器名:/usr/share/zoneinfo/Asia</p>
</li>
</ol>
<p>​    3.进入容器执行命令 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>
<h3 id="tomcat容器时区问题"><a href="#tomcat容器时区问题" class="headerlink" title="tomcat容器时区问题"></a>tomcat容器时区问题</h3><p><strong>描述：</strong>java的war包部署在Linux上的tomcat容器中相差8小时</p>
<p>解决：在tomcat的bin目录下找到catalina.sh文件在JAVA_OPTS追加添加如下配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">-Duser.timezone</span>=<span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/09/16/Bug/%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/image-20200915221437392.png" alt="image-20200915221437392"></p>
<!--注：若是在docker中的容器可先将其拷贝出来修改后再拷贝到docker中原来对应位置-->

<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级</title>
    <url>/2020/09/27/Redis/Redis%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h3 id="为什么持久化"><a href="#为什么持久化" class="headerlink" title="为什么持久化"></a>为什么持久化</h3><p>​    Redis是内存数据库，数据都保存在内存中，因此数据读取速度快，效率高，但也容易发生丢失（如Redis宕机，突然断电等）。所以必须要有持久化的机制保存数据到硬盘，防止数据丢失。</p>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​        RDB(默认的持久化方式)指在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb,它恢复时是将快照文件直接读到内存里。</p>
<h4 id="持久化过程"><a href="#持久化过程" class="headerlink" title="持久化过程"></a>持久化过程</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。</p>
<h4 id="触发RDB快照条件"><a href="#触发RDB快照条件" class="headerlink" title="触发RDB快照条件"></a>触发RDB快照条件</h4><ol>
<li>配置文件save配置</li>
<li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li>
<li>执行命令save或者bgsave</li>
</ol>
<p>注：save：save时只管保存，其它不管，全部阻塞</p>
<p>bgsave：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave命令获取最后一次成功执行快照的时间。</p>
<h4 id="停用"><a href="#停用" class="headerlink" title="停用"></a>停用</h4><ol>
<li>动态所有停止RDB保存规则的方法：redis-cli config set save “”</li>
<li>修改配置文件save “”</li>
</ol>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高</li>
</ol>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改</li>
<li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li>
</ol>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。AOF默认存储文件名appendonly.aof</p>
<h4 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h4><p>修改配置appendonly no改为yes</p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>修复受损appendonly.aof文件命令： Redis-check-aof –fix  appendonly.aof</p>
<h4 id="Rewrite"><a href="#Rewrite" class="headerlink" title="Rewrite"></a>Rewrite</h4><h5 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似</p>
<h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</p>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同</li>
</ol>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol>
<li>每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no   从不同步，性能最好</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大。</li>
<li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li>
</ol>
<h4 id="同时开启两种持久化方式"><a href="#同时开启两种持久化方式" class="headerlink" title="同时开启两种持久化方式"></a>同时开启两种持久化方式</h4><ol>
<li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li>
<li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li>
</ol>
<h4 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h4><ol>
<li> 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</li>
<li>如果Enalbe AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。</li>
<li>如果不Enable AOF ，仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个。新浪微博就选用了这种架构</li>
</ol>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>​    进程间的一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。复杂情况下可使用专门的消息中间件，如RabbitMQ。</p>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>PSUBSCRIBE pattern [pattern …]     订阅一个或多个符合给定模式的频道。<br>PUBSUB subcommand [argument [argument …]]      查看订阅与发布系统状态。<br>PUBLISH channel message     将信息发送到指定的频道。<br>PUNSUBSCRIBE [pattern [pattern …]]     退订所有给定模式的频道。<br>SUBSCRIBE channel [channel …]     订阅给定的一个或多个频道的信息。<br>UNSUBSCRIBE [channel [channel …]]    指退订给定的频道。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#窗口1</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel  <span class="comment">#订阅channel频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line"><span class="comment">#当下面发布消息到此频道时，显示下面信息</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1 <span class="comment">#数量 </span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment">#消息</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span> <span class="comment">#频道</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span> <span class="comment">#消息内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#与上面同一时刻的另一个客户端窗口2</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello word&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#窗口3</span></span><br><span class="line"><span class="comment">#将信息发送到指定的频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH channel <span class="string">&quot;hello word&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2 <span class="comment">#推送给两个订阅者</span></span><br><span class="line"><span class="comment">#获取当前系统所有频道</span></span><br><span class="line">127.0.0.1:6379&gt; PUBSUB CHANNELS</span><br><span class="line">1) <span class="string">&quot;channel2&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主，实现读写分离，Slave无法写入数据</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Info replication <span class="comment">#查看</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment">#角色</span></span><br><span class="line">connected_slaves:0 <span class="comment">#从机数</span></span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>拷贝多个redis.conf文件</li>
<li>开启daemonize yes</li>
<li>修改port，pidfile，logfile，dbfilename</li>
<li>执行指令：redis-server 配置文件路径</li>
<li>在从机上运行SLAVEOF masterip  端口</li>
</ol>
<h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><h4 id="一主多仆："><a href="#一主多仆：" class="headerlink" title="一主多仆："></a>一主多仆：</h4><p>​        一个master多个slaver</p>
<h4 id="薪火相传："><a href="#薪火相传：" class="headerlink" title="薪火相传："></a>薪火相传：</h4><ul>
<li>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。</li>
<li>中途变更转向:会清除之前的数据，重新建立拷贝最新的。</li>
<li>Slaveof 新主库IP 新主库端口</li>
</ul>
<h4 id="反客为主："><a href="#反客为主：" class="headerlink" title="反客为主："></a>反客为主：</h4><p>​        执行指令SLAVEOF no one，使当前数据库停止与其他数据库的同步，转成主数据库</p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul>
<li>Slave启动成功连接到master后会发送一个sync命令</li>
<li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li>
<li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li>
<li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li>
</ul>
<h3 id="哨兵模式-sentinel-（实际开发中常用）"><a href="#哨兵模式-sentinel-（实际开发中常用）" class="headerlink" title="哨兵模式(sentinel)（实际开发中常用）"></a>哨兵模式(sentinel)（实际开发中常用）</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><ol>
<li>新建sentinel.conf文件</li>
<li>写入基本配置：sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1 （最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机）</li>
<li>在Redis根目录下执行命令启动哨兵：Redis-sentinel  sentinel.conf 文件路径</li>
</ol>
<h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p>
<p><a href="https://www.cnblogs.com/renpingsheng/p/9862485.html">Redis Cluter</a></p>
<h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>在设置键的过期时间的同时，创建一个定时器， 让定时器在键的过期时间来临时，立即执行对键的删除操作。对内存友好，但会占用CPU资源，影响响应时间和吞吐量。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>被动删除，每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。对CPU友好，但会占用内存。</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>前两个的折中方案。每隔一段时间（默认10s，可在redis.conf中配置hz）程序就对数据库的expires字典进行一次扫描，删除里面的过期键。至于要扫描、删除多少过期键，以及要检查多少个数据库，则由算法决定。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br><strong>注：</strong></p>
<ol>
<li>expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。</li>
<li>为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</li>
<li></li>
</ol>
<h2 id="aof-rdb和复制功能对过期键的处理"><a href="#aof-rdb和复制功能对过期键的处理" class="headerlink" title="aof/rdb和复制功能对过期键的处理"></a>aof/rdb和复制功能对过期键的处理</h2><h3 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h3><ul>
<li>生成rdb文件：程序会对键进行检查，过期键不放入rdb文件。</li>
<li>载入rdb文件：如果以主服务器模式运行，程序会对文件中保存的键进行检查，过期键会被忽略；如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。</li>
</ul>
<h3 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h3><ul>
<li>当服务器以aof持久化模式运行时，当过期键被删除后，程序会向aof文件追加一条del命令来显式记录该键已被删除。</li>
<li>aof重写过程中，程序会对数据库中的键进行检查，过期键则会被忽略。</li>
</ul>
<h3 id="集群复制"><a href="#集群复制" class="headerlink" title="集群复制"></a>集群复制</h3><p>Redis集群运行在复制模式下时，从服务器的过期删除动作由主服务器控制。</p>
<ul>
<li><p>主服务器在删除一个过期键后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键。</p>
</li>
<li><p>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键，保持数据一致性。</p>
</li>
</ul>
<h2 id="其他重要知识链接"><a href="#其他重要知识链接" class="headerlink" title="其他重要知识链接"></a>其他重要知识链接</h2><p><a href="https://blog.csdn.net/miss1181248983/article/details/90056960">Redis三种集群详解</a></p>
<p><a href="https://blog.csdn.net/houjixin/article/details/27680183">Redis同步机制</a></p>
<p><a href="https://blog.csdn.net/qq_41453285/article/details/103224875">Redis对象与编码</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/8654978.html">Redis内存模型</a></p>
<p><a href="https://blog.csdn.net/Design407/article/details/103242874?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160726406319724827617155%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160726406319724827617155&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_click~default-1-103242874.pc_v1_rank_blog_v1&utm_term=redis&spm=1018.2118.3001.4450">Redis常问问题</a></p>
<p><a href="https://blog.csdn.net/shuningzhang/article/details/89445417">Redis通讯协议</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat搭建MySQL集群实现高可用，读写分离</title>
    <url>/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h2 id="搭建MySQL集群一主一从"><a href="#搭建MySQL集群一主一从" class="headerlink" title="搭建MySQL集群一主一从"></a>搭建MySQL集群一主一从</h2><h3 id="1-修改master的配置文件-etc-my-cnf"><a href="#1-修改master的配置文件-etc-my-cnf" class="headerlink" title="1.修改master的配置文件/etc/my.cnf"></a>1.修改master的配置文件/etc/my.cnf</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个), 入系统库等</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库，如果有多个数据库，可重复此参数，每个数据库一行</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure>

<h3 id="2-重启服务"><a href="#2-重启服务" class="headerlink" title="2.重启服务"></a>2.重启服务</h3><h3 id="3-在主服务上授权slave"><a href="#3-在主服务上授权slave" class="headerlink" title="3.在主服务上授权slave"></a>3.在主服务上授权slave</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;授权密码，下面用到&#x27;</span>;</span><br><span class="line"><span class="comment">#可授权给具体ip &#x27;slave&#x27;@&#x27;ip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql8用下面</span></span><br><span class="line">CREATE USER <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;授权密码，下面用到&#x27;</span>;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-查询master状态（记下File与Position值，主机不再操作）"><a href="#4-查询master状态（记下File与Position值，主机不再操作）" class="headerlink" title="4.查询master状态（记下File与Position值，主机不再操作）"></a>4.查询master状态（记下File与Position值，主机不再操作）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207162725895.png" alt="image-20210207162725895"></p>
<h3 id="5-修改slave的配置文件"><a href="#5-修改slave的配置文件" class="headerlink" title="5.修改slave的配置文件"></a>5.修改slave的配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="6-重启从机mysql"><a href="#6-重启从机mysql" class="headerlink" title="6.重启从机mysql"></a>6.重启从机mysql</h3><h3 id="7-从机执行复制主机命令"><a href="#7-从机执行复制主机命令" class="headerlink" title="7.从机执行复制主机命令"></a>7.从机执行复制主机命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=<span class="string">&#x27;主机的IP地址&#x27;</span>,</span><br><span class="line">MASTER_USER=<span class="string">&#x27;slave&#x27;</span>, <span class="comment"># 用户名，与上面一致</span></span><br><span class="line">MASTER_PASSWORD=<span class="string">&#x27;密码&#x27;</span>, <span class="comment">#与上面一致</span></span><br><span class="line">MASTER_PORT=3306, <span class="comment">#主机端口</span></span><br><span class="line">MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=653;(pisition的值)</span><br></pre></td></tr></table></figure>

<h3 id="8-启动从服务器复制功能"><a href="#8-启动从服务器复制功能" class="headerlink" title="8.启动从服务器复制功能"></a>8.启动从服务器复制功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#之前有开启的话要先停止</span></span><br><span class="line">stop slave;</span><br><span class="line"></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<h3 id="9-查看从服务器状态"><a href="#9-查看从服务器状态" class="headerlink" title="9.查看从服务器状态"></a>9.查看从服务器状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show slave status\G; <span class="comment"># \G:将查询到的横向表格纵向输出，方便阅读</span></span><br><span class="line"><span class="comment">#Slave_IO_Running: Yes</span></span><br><span class="line"><span class="comment">#Slave_SQL_Running: Yes</span></span><br><span class="line"><span class="comment">#说明配置成功</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207164123829.png" alt="image-20210207164123829"></p>
<h3 id="10-测试是否同步"><a href="#10-测试是否同步" class="headerlink" title="10.测试是否同步"></a>10.测试是否同步</h3><p>注：数据库必须是主配置文件中binlog-do-db配置的数据库才会同步</p>
<p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207170933867.png" alt="image-20210207170933867"></p>
<h2 id="搭建双主双从"><a href="#搭建双主双从" class="headerlink" title="搭建双主双从"></a>搭建双主双从</h2><h3 id="主机master1配置"><a href="#主机master1配置" class="headerlink" title="主机master1配置"></a>主机master1配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates </span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2 </span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure>

<h3 id="主机master2配置"><a href="#主机master2配置" class="headerlink" title="主机master2配置"></a>主机master2配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主服务器唯一ID</span></span><br><span class="line">server-id=3 <span class="comment">#启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="comment"># 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="comment">#设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment">#设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="comment"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates </span><br><span class="line"></span><br><span class="line"><span class="comment">#防止插入时自增主键与master1冲突</span></span><br><span class="line"><span class="comment">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2 </span><br><span class="line"><span class="comment"># 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=2</span><br></pre></td></tr></table></figure>

<h3 id="slave1配置"><a href="#slave1配置" class="headerlink" title="slave1配置"></a>slave1配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="slave2配置"><a href="#slave2配置" class="headerlink" title="slave2配置"></a>slave2配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从服务器唯一ID</span></span><br><span class="line">server-id=4 </span><br><span class="line"><span class="comment">#启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h3 id="接下来操作与上面一主一从差不多，就是两个master也要互相复制对方"><a href="#接下来操作与上面一主一从差不多，就是两个master也要互相复制对方" class="headerlink" title="接下来操作与上面一主一从差不多，就是两个master也要互相复制对方"></a>接下来操作与上面一主一从差不多，就是两个master也要互相复制对方</h3><h2 id="Mycat配置"><a href="#Mycat配置" class="headerlink" title="Mycat配置"></a>Mycat配置</h2><p>！注：Mycat1.6连接mysql8时需修改mysql的加密策略</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 修改密码为用不过期</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span> PASSWORD EXPIRE NEVER; </span><br><span class="line">-- 修改密码并指定加密规则为mysql_native_password</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">-- 刷新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>



<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>schema.xml：定义逻辑库，表、分片节点等内容。</p>
<p>rule.xml：定义分片相关规则。</p>
<p>server.xml：定义用户以及系统相关变量，如端口等。</p>
<h3 id="schema-xml写MySQL连接信息"><a href="#schema-xml写MySQL连接信息" class="headerlink" title="schema.xml写MySQL连接信息"></a>schema.xml写MySQL连接信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM <span class="string">&quot;schema.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;schema name=<span class="string">&quot;TESTDB&quot;</span> checkSQLschema=<span class="string">&quot;false&quot;</span> sqlMaxLimit=<span class="string">&quot;100&quot;</span> dataNode=<span class="string">&quot;dn1&quot;</span>&gt;</span><br><span class="line">	&lt;/schema&gt;</span><br><span class="line">	&lt;!--database为mysql的数据库名 --&gt;</span><br><span class="line">	&lt;dataNode name=<span class="string">&quot;dn1&quot;</span> dataHost=<span class="string">&quot;host1&quot;</span> database=<span class="string">&quot;testMycat&quot;</span> /&gt;</span><br><span class="line">	&lt;dataHost name=<span class="string">&quot;host1&quot;</span> maxCon=<span class="string">&quot;1000&quot;</span> minCon=<span class="string">&quot;10&quot;</span> balance=<span class="string">&quot;1&quot;</span></span><br><span class="line">			  writeType=<span class="string">&quot;0&quot;</span> dbType=<span class="string">&quot;mysql&quot;</span> dbDriver=<span class="string">&quot;native&quot;</span> switchType=<span class="string">&quot;1&quot;</span>  slaveThreshold=<span class="string">&quot;100&quot;</span>&gt;</span><br><span class="line">		&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">		&lt;!-- can have multi write hosts --&gt;</span><br><span class="line">		&lt;writeHost host=<span class="string">&quot;hostM1&quot;</span> url=<span class="string">&quot;主机1IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span></span><br><span class="line">				   password=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">			&lt;!-- can have multi <span class="built_in">read</span> hosts --&gt;</span><br><span class="line">			&lt;readHost host=<span class="string">&quot;hostS2&quot;</span> url=<span class="string">&quot;从机1IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span> password=<span class="string">&quot;密码&quot;</span> /&gt;</span><br><span class="line">		&lt;/writeHost&gt;</span><br><span class="line">		&lt;writeHost host=<span class="string">&quot;hostS1&quot;</span> url=<span class="string">&quot;主机2IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span></span><br><span class="line">				   password=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">			&lt;readHost host=<span class="string">&quot;hostS3&quot;</span> url=<span class="string">&quot;从机2IP:端口&quot;</span> user=<span class="string">&quot;账号&quot;</span> password=<span class="string">&quot;密码&quot;</span> /&gt;</span><br><span class="line">		&lt;/writeHost&gt;</span><br><span class="line">	&lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#balance=&quot;1&quot;: 全部的readHost与stand by writeHost参与select语句的负载均衡。</span></span><br><span class="line"><span class="comment">#balance配置负载均衡类型：</span></span><br><span class="line"><span class="comment">#&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。</span></span><br><span class="line"><span class="comment">#&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均#衡。</span></span><br><span class="line"><span class="comment">#balance=&quot;2&quot;，所有读操作都随机的在 writeHost、readhost 上分发。</span></span><br><span class="line"><span class="comment">#balance=&quot;3&quot;，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#writeType=&quot;0&quot;: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个</span></span><br><span class="line"><span class="comment">#writeType=&quot;1&quot;，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐</span></span><br><span class="line"><span class="comment">#writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties 。 #switchType=&quot;1&quot;: 1 默认值，自动切换。</span></span><br><span class="line"><span class="comment"># -1 表示不自动切换</span></span><br><span class="line"><span class="comment"># 2 基于 MySQL 主从同步的状态决定是否切换。</span></span><br></pre></td></tr></table></figure>

<h3 id="server-xml里添加Mycat登陆用户信息"><a href="#server-xml里添加Mycat登陆用户信息" class="headerlink" title="server.xml里添加Mycat登陆用户信息"></a>server.xml里添加Mycat登陆用户信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;user name=<span class="string">&quot;my用户名&quot;</span>&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;mycat密码&quot;</span>&gt;密码&lt;/property&gt;</span><br><span class="line">		&lt;property name=<span class="string">&quot;schemas&quot;</span>&gt;TESTDB&lt;/property&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在bin，目录下启动Mycat"><a href="#在bin，目录下启动Mycat" class="headerlink" title="在bin，目录下启动Mycat"></a>在bin，目录下启动Mycat</h3><p>./mycat console ： 控制台运行</p>
<p>./mycat start ： 后台运行</p>
<p>（图中可知，Mycat是用Java写的）</p>
<p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207200845130.png" alt="image-20210207200845130"></p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#与mysql连接一样</span></span><br><span class="line"><span class="comment">#8066是数据连接端口，即应用程序连此端口</span></span><br><span class="line"><span class="comment">#9066是Mycat管理端口</span></span><br><span class="line">mysql -u[上面server配置的用户名] -p[密码] -P [端口] -h[ip]</span><br></pre></td></tr></table></figure>

<h3 id="创建表并测试"><a href="#创建表并测试" class="headerlink" title="创建表并测试"></a>创建表并测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create table user(id int, name varchar(11),address varchar(11));</span><br><span class="line">insert into user values(1,<span class="string">&#x27;张三&#x27;</span>,@@hostname);</span><br><span class="line"><span class="comment">#不同mysql的主机名不同@@hostname</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/06/SQL/MySQL%E9%9B%86%E7%BE%A4/image-20210207211246172.png" alt="image-20210207211246172"></p>
<h2 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h2><h3 id="垂直拆分（分库分表）"><a href="#垂直拆分（分库分表）" class="headerlink" title="垂直拆分（分库分表）"></a>垂直拆分（分库分表）</h3><p>指按照业务将表进行分类，分布到不同的数据库上面，有紧密关联关系的表应该在一个库里，相互没有关联关系的表可以分到不同的库里。将数据或者说压力分担到不同的库上面。（不同库中表不同）</p>
<h3 id="水平拆分（分表）"><a href="#水平拆分（分表）" class="headerlink" title="水平拆分（分表）"></a>水平拆分（分表）</h3><p>按照某个字段的某种规则来分散到多个库之中，不同库的表中包含一部分数据。（不同库拥有相同表）</p>
<h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><p><a href="https://blog.csdn.net/qq_41772936/article/details/80380950">学习链接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/96212530">学习链接2</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>mySQL&#39;1055&#39;错误</title>
    <url>/2020/11/06/SQL/mySQL%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>执行复杂sql（我是多表连接查询和group by分组一起使用）语句时，报以下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">translate SQLException with Error code <span class="string">&#x27;1055&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>mysql5.7后，sql_mode中默认存在ONLY_FULL_GROUP_BY(不要让GROUP BY部分中的查询指向未选择的列)，对 group by 用法的规定，select 的字段只能是group by的字段。或者需要加聚合函数的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在数据库中执行以下语句</span></span><br><span class="line">SELECT @@global.sql_mode <span class="comment">#查询sql_mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span></span><br><span class="line"><span class="comment">#ONLY_FULL_GROUP_BY　　        不要让GROUP BY部分中的查询指向未选择的列　　</span></span><br><span class="line"><span class="comment">#STRICT_TRANS_TABLES           为事务存储引擎启用严格模式，也可能为非事务存储引擎启用严格模式</span></span><br><span class="line"><span class="comment">#NO_ZERO_IN_DATE               在严格模式，不接受月或日部分为0的日期</span></span><br><span class="line"><span class="comment">#NO_ZERO_DATE                 在严格模式，不将 &#x27;0000-00-00&#x27;做为合法日期</span></span><br><span class="line"><span class="comment">#ERROR_FOR_DIVISION_BY_ZERO   在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误　　</span></span><br><span class="line"><span class="comment">#NO_AUTO_CREATE_USER          防止GRANT自动创建新用户，除非还指定了密码</span></span><br><span class="line"><span class="comment">#NO_ENGINE_SUBSTITUTION       如果需要的存储引擎被禁用或未编译，可以防止自动替换存储引擎</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#去掉ONLY_FULL_GROUP_BY 执行以下语句</span></span><br><span class="line"><span class="built_in">set</span> global sql_mode = <span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启项目问题解决</span></span><br></pre></td></tr></table></figure>



<h2 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h2><p>能不修改尽量不修改，一般这个是你使用group by分组后，在查出的数据中被分到同一组的数据的有其它字段不相同，可将这字段加入分组条件解决</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常见问题</title>
    <url>/2020/12/02/SQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="数据库索引失效情况"><a href="#数据库索引失效情况" class="headerlink" title="数据库索引失效情况"></a>数据库索引失效情况</h2><h3 id="查询不同条件中使用or（若只查询相同字段不同情况用or还是会走索引）"><a href="#查询不同条件中使用or（若只查询相同字段不同情况用or还是会走索引）" class="headerlink" title="查询不同条件中使用or（若只查询相同字段不同情况用or还是会走索引）"></a>查询不同条件中使用or（若只查询相同字段不同情况用or还是会走索引）</h3><p>​    注：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p>
<h3 id="查询使用is-not-null判断"><a href="#查询使用is-not-null判断" class="headerlink" title="查询使用is not null判断"></a>查询使用is not null判断</h3><ul>
<li>单列索引无法存储null，复合索引无法储存全为null的值。</li>
<li>索引是有序的，插入数据时需要对其进行比较，null无法比较，无法确定其位置。</li>
</ul>
<p>（解决，可自定义特定值替代null值，或使用复合索引）</p>
<h3 id="模糊查询使用-开头-如-like-‘-this’"><a href="#模糊查询使用-开头-如-like-‘-this’" class="headerlink" title="模糊查询使用%开头 如 like ‘%this’"></a>模糊查询使用%开头 如 like ‘%this’</h3><p>​    注：若不是%开头的模糊查询，如’XX%’，可用XX去匹配索引列，当碰到其他开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。以%开头的就难以定位，执行引擎可能更倾向于全表扫描。</p>
<p><a href="https://mp.weixin.qq.com/s/ygvuP35B_sJAlBHuuEJhfg">模糊匹配优化</a></p>
<h3 id="若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引"><a href="#若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引" class="headerlink" title="若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引"></a>若索引列是字符串型时，查询条件要用’’引起来，否则不使用索引</h3><h3 id="存在类型转换"><a href="#存在类型转换" class="headerlink" title="存在类型转换"></a>存在类型转换</h3><p>如：整型字段条件却用字符(where num =  ‘123’)</p>
<h3 id="如果mysql估计使用全表扫描要比使用索引快-则不使用索引"><a href="#如果mysql估计使用全表扫描要比使用索引快-则不使用索引" class="headerlink" title="如果mysql估计使用全表扫描要比使用索引快,则不使用索引"></a>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</h3><p>如：表中列与列间的对比，在同一表中的两个列都建了索引，条件是where column1 = column2时，会被认为不如走全表扫描</p>
<h2 id="索引列的数据都一样时"><a href="#索引列的数据都一样时" class="headerlink" title="索引列的数据都一样时"></a>索引列的数据都一样时</h2><p>注：索引不应被建在数据几乎一样的列上</p>
<h2 id="MySQL索引类型"><a href="#MySQL索引类型" class="headerlink" title="MySQL索引类型"></a>MySQL索引类型</h2><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>B树索引底层使用多路平衡查找树，具有范围查找和前缀查找的能力，对于有N节点的B树，检索一条记录的复杂度为O(LogN)。相当于二分查找。InnoDB存储引擎的默认索引实现为:B+树索引。</p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>MyISAM支持索引，哈希索引底层是Hash表只能做等于查找，但是无论多大的Hash表，查找复杂度都是O(1)。InnoDB 引擎中叫作<strong>自适应哈希索引</strong>，在自适应hash特性里有使用。</p>
<h3 id="空间数据索引-R-tree"><a href="#空间数据索引-R-tree" class="headerlink" title="空间数据索引(R-tree)"></a>空间数据索引(R-tree)</h3><p>myisam支持空间索引，可以用作地理数据存储，R-tree无须前缀索引。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。（MyISAM和InnoDB引擎【mysql5.7.4】支持）</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>通过查找文本中的关键词，类似于搜索引擎，而不是简单的where条件匹配。（MyISAM和InnoDB引擎【mysql5.6】支持）</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果值的差异性大，并且以等值查找（=、 &lt;、&gt;、in）为主，Hash索引是更高效的选择，它有O(1)的查找复杂度。如果值的差异性相对较差，并且以范围查找为主，B树是更好的选择，它支持范围查找。</p>
<h2 id="MySQL8-0无法对表一个字段同时添加外键和check"><a href="#MySQL8-0无法对表一个字段同时添加外键和check" class="headerlink" title="MySQL8.0无法对表一个字段同时添加外键和check"></a>MySQL8.0无法对表一个字段同时添加外键和check</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 开课表</span><br><span class="line">(</span><br><span class="line">  开课号 <span class="built_in">CHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  课号 <span class="built_in">CHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  工号 <span class="built_in">CHAR</span>(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  开课地点 <span class="built_in">CHAR</span>(<span class="number">6</span>),</span><br><span class="line">  开课学年 <span class="built_in">CHAR</span>(<span class="number">9</span>),</span><br><span class="line">  开课学期 <span class="built_in">INT</span> ,</span><br><span class="line">  开课周数 <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">17</span>,</span><br><span class="line">  开课时间 <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  限选人数 <span class="built_in">INT</span>,</span><br><span class="line">  已选人数 <span class="built_in">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_开课表_开课号 PRIMARY <span class="keyword">KEY</span>(开课号),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_开课表_工号 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(工号) <span class="keyword">REFERENCES</span> 教师表(工号) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_开课表_课号 <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(课号) <span class="keyword">REFERENCES</span> 课程表(课号) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> CK_开课表_开课号 <span class="keyword">CHECK</span>(开课号 regexp <span class="string">&#x27;[0-9][0-9][0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line">    <span class="comment">--以下来的字段约束无法添加，报错</span></span><br><span class="line">   <span class="comment">-- &gt; 3823 - Column &#x27;工号&#x27; cannot be used in a check constraint &#x27;CK_开课表_工号&#x27;: needed in a foreign key constraint &#x27;FK_开课表_工号&#x27; referential action.</span></span><br><span class="line"><span class="comment">--   CONSTRAINT CK_开课表_工号 CHECK(工号 regexp &#x27;T[0-9][0-9][0-9][0-9][0-9]&#x27;),</span></span><br><span class="line"><span class="comment">--   CONSTRAINT CK_开课表_课号 CHECK(课号 regexp &#x27;C[0-9][0-9][0-9][0-9][0-9]&#x27;)</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>

<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p><strong>使用触发器替代check</strong></p>
<p>注：在MYSQL8.0前，CHECK只是一段可调用但无意义的子句，MySQL会直接忽略。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $ <span class="comment">--更改结束符</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> CK_开课表_工号 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> 开课表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(new.工号 <span class="keyword">not</span> regexp <span class="string">&#x27;T[0-9][0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		signal <span class="keyword">sqlstate</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">set</span> message_text = <span class="string">&#x27;工号格式不对&#x27;</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> CK_开课表_课号 <span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> 开课表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(new.课号 <span class="keyword">not</span> regexp <span class="string">&#x27;C[0-9][0-9][0-9][0-9][0-9]&#x27;</span>)</span><br><span class="line">	<span class="keyword">then</span></span><br><span class="line">		signal <span class="keyword">sqlstate</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">set</span> message_text = <span class="string">&#x27;课号格式不对&#x27;</span>;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<h2 id="Mysql用触发器实现修改同一字段"><a href="#Mysql用触发器实现修改同一字段" class="headerlink" title="Mysql用触发器实现修改同一字段"></a>Mysql用触发器实现修改同一字段</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--需求修改工号同时修改负责人</span></span><br><span class="line"><span class="comment">--错误写法--》会造成循环的调用.</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> jobNumber <span class="keyword">after</span> <span class="keyword">update</span> <span class="keyword">on</span> 教师表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">update</span> 教师表 <span class="keyword">set</span> 负责人 = new.工号 <span class="keyword">where</span> 教师表.工号 = new.工号;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="comment">--正确写法</span></span><br><span class="line">delimiter $</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> jobNumber <span class="keyword">before</span> <span class="keyword">update</span> <span class="keyword">on</span> 教师表 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">set</span> new.负责人 = new.工号;</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<h2 id="在存储过程中使用游标操作多个数据"><a href="#在存储过程中使用游标操作多个数据" class="headerlink" title="在存储过程中使用游标操作多个数据"></a>在存储过程中使用游标操作多个数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$  <span class="comment">--将sql分割符声明为$$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--创建名为insert_student_course的存储过程</span></span><br><span class="line"><span class="comment">--参数([in/out/inout] 参数名   参数类型)</span></span><br><span class="line"><span class="comment">--IN :   该参数可以作为输入，也就是需要调用方传入值 , 默认</span></span><br><span class="line"><span class="comment">--OUT:   该参数作为输出，也就是该参数可以作为返回值</span></span><br><span class="line"><span class="comment">--INOUT: 既可以作为输入参数，也可以作为输出参数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> insert_student_course(<span class="keyword">IN</span> classNo <span class="built_in">varchar</span>(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- 需要定义接收游标数据的变量 DECLARE var_name[,...] type [DEFAULT value]</span></span><br><span class="line">	<span class="keyword">DECLARE</span> s_no <span class="built_in">varchar</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">DECLARE</span> tcid <span class="built_in">varchar</span>(<span class="number">6</span>);</span><br><span class="line">	<span class="keyword">DECLARE</span> has_data <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line"> <span class="comment">-- 声明游标DECLARE cursor_name CURSOR FOR select_statement ;</span></span><br><span class="line">	<span class="keyword">DECLARE</span> cur1 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">select</span> st.s_no, tc.tcid <span class="keyword">from</span> student_4954 st</span><br><span class="line">	<span class="keyword">inner</span> <span class="keyword">join</span> teacher_course_4954 tc <span class="keyword">on</span> tc.class_no = st.class_no</span><br><span class="line">	<span class="keyword">inner</span> <span class="keyword">join</span> course_4954 c <span class="keyword">on</span> c.cno = tc.cno</span><br><span class="line">	<span class="keyword">where</span> st.class_no = classNo;</span><br><span class="line">	<span class="comment">--钩子，在取不到数据时触发！！！下面循环结束条件需要！</span></span><br><span class="line">	<span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">set</span> has_data = <span class="number">0</span>;</span><br><span class="line"> <span class="comment">-- 打开游标</span></span><br><span class="line">	OPEN cur1;</span><br><span class="line"> <span class="comment">-- 开始循环</span></span><br><span class="line">	REPEAT</span><br><span class="line">		<span class="comment">--逐行取出crul的数据存入 s_no和tcid</span></span><br><span class="line">		FETCH cur1 INTO s_no,tcid;</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> student_course_4954 (s_no, tcid) <span class="keyword">values</span> (s_no, tcid);</span><br><span class="line">		until has_data = 0</span><br><span class="line">  <span class="comment">--退出循环</span></span><br><span class="line">	<span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br><span class="line"><span class="comment">--关闭游标</span></span><br><span class="line">	CLOSE cur1;</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;<span class="comment">--将sql分割符声明回;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用存储过程</span></span><br><span class="line"><span class="keyword">call</span> insert_student_course(<span class="string">&#x27;1001&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="查询数据库表数量"><a href="#查询数据库表数量" class="headerlink" title="查询数据库表数量"></a>查询数据库表数量</h2><h3 id="所有表数量"><a href="#所有表数量" class="headerlink" title="所有表数量"></a>所有表数量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) table_num, table_schema <span class="keyword">FROM</span> information_schema.TABLES </span><br></pre></td></tr></table></figure>

<h3 id="各数据库表数量"><a href="#各数据库表数量" class="headerlink" title="各数据库表数量"></a>各数据库表数量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) table_num, table_schema <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">GROUP</span> <span class="keyword">BY</span> table_schema;</span><br></pre></td></tr></table></figure>

<h3 id="查询指定库的表数量"><a href="#查询指定库的表数量" class="headerlink" title="查询指定库的表数量"></a>查询指定库的表数量</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) table_num, table_schema <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">where</span> table_schema = <span class="string">&#x27;库名&#x27;</span></span><br></pre></td></tr></table></figure>







<h2 id="inndb关键特性"><a href="#inndb关键特性" class="headerlink" title="inndb关键特性"></a>inndb关键特性</h2><ol>
<li><p>二次写（double write）</p>
<p> <img src="/2020/12/02/SQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98/image-20210406012718310.png" alt="image-20210406012718310"></p>
<p> <a href="http://blog.itpub.net/22664653/viewspace-1140915/">double write</a></p>
</li>
<li><p>异步IO(Async IO)</p>
<ul>
<li><p>可以同时发送多个IO请求，然后等待所有IO操作完成。</p>
</li>
<li><p>IO Merge：将多个合成为一个IO，例如访问的页(space, page_no)为(8,6)(8,7)(8,8),则合成为一个IO请求从(8,6)开始。连续读48K页面。</p>
</li>
</ul>
</li>
<li><p>邻接表刷新</p>
<ul>
<li>磁盘预读原理。当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页则一起刷新。</li>
</ul>
</li>
<li><p>插入缓存</p>
<ul>
<li>主要是插入性能提升。解决频繁数据更新带来的b+tree频繁自平衡工作。</li>
<li>对于<strong>非聚集索引</strong>的插入/更新操作先判断非聚集索引的页是否在缓冲池中，若在则直接插入。</li>
<li>若不在则先放入到一个<strong>InsertBuffer</strong>中，然后按一定频率对InsertBuffer和辅助索引页进行merge操作。</li>
<li>这是一种插入合并，减少b+tree重排。</li>
<li>索引不能是主键索引，主键索引为聚集索引，大多为自增。如果为UUID类型，则可以使用InsertBuffer</li>
<li>索引非唯一，因为数据库并不会去查找索引页来判断插入的唯一性。</li>
<li>1.2以后进行了升级，<strong>Change Buffer</strong>，将DML操作细分为InsertBuffer， DeleteBuffer， PurgeBuffer</li>
<li><strong>update</strong>时，DeleteBuffer是第一个过程，标记为删除。PurgeBuffer为第二个过程，真正移除。</li>
<li>InsertBuffer的内部实现是一颗B+tree，负责对所有表的的辅助索引进行InsertBuffer。</li>
<li>它存放在共享表空间中，也就是ibdata1中，所以通过ibd进行文件恢复时，需要进行<strong>RepairTable</strong>重建表上辅助索引。</li>
</ul>
</li>
<li><p>自适应hash</p>
<ul>
<li><p>Hash查找的时间复杂度为O(1), 而B+tree的查找次数一般约等于3～4层。innodb会根据访问频率和模式来自动为某些热点页建立hash。</p>
</li>
<li><p>要求访问模式也就是查询条件<strong>固定且为=搜索，而不是范围检索</strong>。</p>
</li>
<li><p>当以该模式访问了100次，且页通过该模式访问了N次，其中N=页中记录数*1/16。</p>
</li>
</ul>
</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000021846648">参考链接</a></p>
<p>注：详细在《MySQL技术内幕  InnoDB存储引擎  第2版》58页。</p>
<h2 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h2><p><a href="https://www.jianshu.com/p/5a9c1e487ddd">学习链接</a></p>
<h2 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h2><ul>
<li>表级（MyISAM、MEMORY和InnoDB）</li>
<li>页级（BDB）</li>
<li>行级（InnoDB）</li>
</ul>
<p><a href="https://blog.csdn.net/cy973071263/article/details/105188519">学习链接1</a></p>
<p><a href="https://blog.csdn.net/u012422440/article/details/105257665">学习链接2</a></p>
<h2 id="MySQL多表连接细节"><a href="#MySQL多表连接细节" class="headerlink" title="MySQL多表连接细节"></a>MySQL多表连接细节</h2><p>mysql表与表之间的关联查询使用Nested-Loop join算法，顾名思义就是嵌套循环连接，但是根据场景不同可能有不同的变种：比如Index Nested-Loop join，Simple Nested-Loop join,Block Nested-Loop join, Betched Key Access join等。</p>
<p>在使用索引关联的情况下，有Index Nested-Loop join和Batched Key Access join两种算法。</p>
<p>在未使用索引关联的情况下，有Simple Nested-Loop join和Block Nested-Loop join两种算法。</p>
<p><a href="https://blog.csdn.net/qq_27529917/article/details/87904179?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162662690016780271544005%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162662690016780271544005&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-87904179.first_rank_v2_pc_rank_v29&utm_term=Mysql%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%86%E8%8A%82%EF%BC%88%E4%B8%80%EF%BC%89&spm=1018.2226.3001.4187">参考链接</a></p>
<h2 id="索引类型type"><a href="#索引类型type" class="headerlink" title="索引类型type"></a>索引类型type</h2><p>type索引类型：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。优化级别从左往右递减，没有索引的一般为all。</p>
<p><a href="https://blog.csdn.net/dennis211/article/details/78170079">参考链接</a></p>
<p><a href="https://blog.csdn.net/weixin_42502016/article/details/113302689">参考链接</a></p>
<h2 id="其他学习链接"><a href="#其他学习链接" class="headerlink" title="其他学习链接"></a>其他学习链接</h2><p><a href="https://blog.csdn.net/weixin_46062001/article/details/108044086">索引为NULL的处理</a></p>
<p><a href="https://blog.csdn.net/SkySuperWL/article/details/52583579">最左前缀匹配原则</a></p>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/104778621?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161184289216780299027777%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161184289216780299027777&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-104778621.pc_search_result_before_js&utm_term=mysql%E4%BC%98%E5%8C%96&spm=1018.2226.3001.4187">mysql学习链接</a></p>
<p><a href="https://blog.csdn.net/lzhcoder/article/details/88814364">binlog</a></p>
<p><a href="https://www.cnblogs.com/lixigang/articles/5057113.html">binlog使用mixed格式可能导致主从不一致</a></p>
<p><a href="https://blog.csdn.net/u010002184/article/details/88526708?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161675714216780357281036%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161675714216780357281036&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-88526708.first_rank_v2_pc_rank_v29&utm_term=undolog+redolog">redo log/undo log/bin log区别</a> </p>
<p><a href="https://blog.csdn.net/huangjw_806/article/details/100927097">binlog与redolog一致性问题</a></p>
<p><a href="https://www.cnblogs.com/xibuhaohao/p/10907903.html">组提交group commit</a></p>
<p><a href="https://blog.csdn.net/qq_35246620/article/details/61200815?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161501483016780255275945%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161501483016780255275945&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-11-61200815.first_rank_v2_pc_rank_v29&utm_term=mysql+%E5%88%B7%E8%84%8F">深入理解MySQL事务</a></p>
<p><a href="https://www.nowcoder.com/discuss/639644?type=0&order=1&pos=6&page=1&channel=1009&source_id=discuss_center_0_nctrack">索引18连问</a></p>
<p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">分布式ID</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>class字节码文件结构</title>
    <url>/2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="class字节码文件结构"><a href="#class字节码文件结构" class="headerlink" title="class字节码文件结构"></a>class字节码文件结构</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u4</td>
<td>magic</td>
<td>魔数,识别Class文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<h2 id="Class文件版本号和平台的对应"><a href="#Class文件版本号和平台的对应" class="headerlink" title="Class文件版本号和平台的对应"></a>Class文件版本号和平台的对应</h2><table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td>52</td>
<td>0</td>
<td>1.8</td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
<h2 id="class文件数据类型"><a href="#class文件数据类型" class="headerlink" title="class文件数据类型"></a>class文件数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>无符号数</td>
<td>无符号数可以用来描述数字、索引引用、数量值或按照utf-8编码构成的字符串值。</td>
<td>其中无符号数属于基本的数据类型。 以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节</td>
</tr>
<tr>
<td>表</td>
<td>表是由多个无符号数或其他表构成的复合数据结构。</td>
<td>所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td>
</tr>
</tbody></table>
<h2 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a>类型描述符</h2><table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>基本数据类型byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody></table>
<h2 id="常量类型和结构"><a href="#常量类型和结构" class="headerlink" title="常量类型和结构"></a>常量类型和结构</h2><table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody></table>
<h2 id="常量类型和结构细节"><a href="#常量类型和结构细节" class="headerlink" title="常量类型和结构细节"></a>常量类型和结构细节</h2><p><img src="/2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1598773300484.png" alt="1598773300484"></p>
<p><img src="/2020/12/09/JVM/Class%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1598773308492.png" alt="1598773308492"></p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为public类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody></table>
<h2 id="字段表访问标志"><a href="#字段表访问标志" class="headerlink" title="字段表访问标志"></a>字段表访问标志</h2><table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为enum</td>
</tr>
</tbody></table>
<h2 id="类索引、父类索引、接口索引"><a href="#类索引、父类索引、接口索引" class="headerlink" title="类索引、父类索引、接口索引"></a>类索引、父类索引、接口索引</h2><table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<h2 id="属性的通用格式"><a href="#属性的通用格式" class="headerlink" title="属性的通用格式"></a>属性的通用格式</h2><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attribute_length</td>
<td>属性表</td>
</tr>
</tbody></table>
<h2 id="数据类型和默认初始值对应"><a href="#数据类型和默认初始值对应" class="headerlink" title="数据类型和默认初始值对应"></a>数据类型和默认初始值对应</h2><table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>sql中distinct简单使用</title>
    <url>/2020/09/22/SQL/sql%E4%B8%ADdistinct%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"><a href="#简介：distinct常用于sql语句中查出重复数据时需要去重的时候" class="headerlink" title="简介：distinct常用于sql语句中查出重复数据时需要去重的时候"></a><strong>简介：distinct常用于sql语句中查出重复数据时需要去重的时候</strong></h3><!--distinct不会过滤掉null值，返回结果包含null值-->

<p>示例：table</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td>null</td>
<td>f</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="只有一字段："><a href="#只有一字段：" class="headerlink" title="只有一字段："></a><strong>只有一字段</strong>：</h3><p>​        <strong>直接在字段前加distinct</strong></p>
<p>​        select distinct column1 from table</p>
<p>结果：</p>
<table>
<thead>
<tr>
<th>column1</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
</tr>
<tr>
<td>2</td>
</tr>
<tr>
<td>3</td>
</tr>
<tr>
<td>null</td>
</tr>
<tr>
<td></td>
</tr>
</tbody></table>
<h3 id="需要查出多个字段："><a href="#需要查出多个字段：" class="headerlink" title="需要查出多个字段："></a><strong>需要查出多个字段</strong>：</h3><p>​    distinct 需要放在第一个字段前面，否者报错</p>
<p>select distinct colum1 , colum2 from table;</p>
<p>结果：多个字段其实是多个字段查出后拼接再去重</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td>null</td>
<td>f</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="只想一个字段唯一"><a href="#只想一个字段唯一" class="headerlink" title="只想一个字段唯一"></a><strong>只想一个字段唯一</strong></h3><p><strong>1.使用group by</strong></p>
<p>​    select column1, column2 from table group by column1</p>
<p><strong>2.使用GROUP_CONCAT函数</strong></p>
<p>​    <strong>GROUP_CONCAT在连接查询的时候，能让查出的这字段的多个数，按字符拼接的方式存放在一起。</strong></p>
<p>select GROUP_CONCAT(distinct column1) as column1, column2 from table group by column1</p>
<table>
<thead>
<tr>
<th>column1</th>
<th>column2</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>c</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>null</td>
<td>e</td>
</tr>
<tr>
<td></td>
<td>g</td>
</tr>
</tbody></table>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm对象分析与执行引擎</title>
    <url>/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ol>
<li>使用new关键字</li>
<li>Class的newInstance();</li>
<li>Constructor的newInstance();</li>
<li>使用clone();方法</li>
<li>对象反序列化</li>
</ol>
<p>注：前三个会调用构造函数，后两个不会。</p>
<h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><ol>
<li><p>判断对象对应的类是否加载、链接、初始化。</p>
</li>
<li><p>为对象分配内存（内存规划与并发问题）</p>
</li>
<li><p>初始化（所有属性设置默认值，保证对象的实例属性不赋值可直接使用）</p>
</li>
<li><p>设置对象头</p>
</li>
<li><p>执行init方法初始化</p>
</li>
</ol>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205538656.png" alt="image-20201116205538656"></p>
<p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205552066.png" alt="image-20201116205552066"></p>
<h2 id="对象的访问与定位"><a href="#对象的访问与定位" class="headerlink" title="对象的访问与定位"></a>对象的访问与定位</h2><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205753071.png" alt="image-20201116205753071"></p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116205802784.png" alt="image-20201116205802784"></p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212053763.png" alt="image-20201116212053763"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>执行引擎是Java虚拟机核心的组成部分之一，“虚拟机”是一个相对于”物理机“的概念，这两钟机器都有代码执行能力，物理机执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，能够执行硬件不支持的指令集格式。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>将字节码指令解释/编译成对应平台上的本地机器指令，即将字节码指令翻译为机器指令。输入是字节码二进制流，输出的是执行结果。</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a><strong>工作过程</strong></h4><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212237168.png" alt="image-20201116212237168"></p>
<h4 id="字节码执行过程"><a href="#字节码执行过程" class="headerlink" title="字节码执行过程"></a>字节码执行过程</h4><p><img src="/2020/11/16/JVM/jvm%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20201116212749868.png" alt="image-20201116212749868"></p>
<h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><p>​    当java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行,将每条字节码文件中的内容”翻译”为对应平台的本地机器码执行。</p>
<h4 id="JIT（Just-In-Time-Compiler）"><a href="#JIT（Just-In-Time-Compiler）" class="headerlink" title="JIT（Just In Time Compiler）"></a>JIT（Just In Time Compiler）</h4><p>​    即时编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<p><a href="https://www.cnblogs.com/yanl55555/p/13334713.html?utm_source=tuicool">执行引擎参考</a></p>
<p><a href="https://www.cnblogs.com/guanghe/p/11880577.html">解释器与JIT参考</a></p>
<h2 id="源代码到机器码过程的三种编译器"><a href="#源代码到机器码过程的三种编译器" class="headerlink" title="源代码到机器码过程的三种编译器"></a>源代码到机器码过程的三种编译器</h2><p><a href="https://blog.csdn.net/fuxiaoxiaoyue/article/details/93497558">参考链接</a></p>
<h3 id="前端编译器"><a href="#前端编译器" class="headerlink" title="前端编译器"></a>前端编译器</h3><p>java代码-》字节码</p>
<h3 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h3><p>字节码-》机器码</p>
<h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>java代码-》机器码</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM常用知识</title>
    <url>/2020/11/14/JVM/jvm%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">官网链接</a></p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="打开JDK自带可视化工具jvisualvm"><a href="#打开JDK自带可视化工具jvisualvm" class="headerlink" title="打开JDK自带可视化工具jvisualvm"></a>打开JDK自带可视化工具jvisualvm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1，到jdk的bin目录找到jvisualvm.exe，双击运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2，或配置了jdk环境变量后可直接命令行执行以下命令打开</span></span><br><span class="line">C:\Users\CZM&gt;jvisualvm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="打开可视化监控jconsole"><a href="#打开可视化监控jconsole" class="headerlink" title="打开可视化监控jconsole"></a>打开可视化监控jconsole</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\CZM&gt;jconsole</span><br></pre></td></tr></table></figure>

<ol>
<li>可以远程可视化监控服务器的java进程。</li>
<li>可以观测堆的不同区块的占用空间量。</li>
<li>不能heapdump</li>
</ol>
<p><a href="https://blog.csdn.net/moneyshi/article/details/81511687">参考链接</a></p>
<h3 id="查看当前所有进程id"><a href="#查看当前所有进程id" class="headerlink" title="查看当前所有进程id"></a>查看当前所有进程id</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;jps</span><br><span class="line">12984</span><br><span class="line">10684 Jps</span><br><span class="line">48476 Launcher</span><br></pre></td></tr></table></figure>



<h3 id="查看指定参数信息"><a href="#查看指定参数信息" class="headerlink" title="查看指定参数信息"></a>查看指定参数信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jinfo -flag jvm参数 进程ip</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器（Garbage Collector）</title>
    <url>/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="查看默认的垃圾收集器"><a href="#查看默认的垃圾收集器" class="headerlink" title="查看默认的垃圾收集器"></a>查看默认的垃圾收集器</h2><ol>
<li>运行时带上JVM参数-XX: +PrintCommandLineFlags:查看命令行相关参数(包含使用的垃圾收集器) 。</li>
<li>使用命令行指令: jinfo -flag  相关垃圾回收器参数  进程ID。</li>
</ol>
<h2 id="GC的性能指标"><a href="#GC的性能指标" class="headerlink" title="GC的性能指标"></a>GC的性能指标</h2><ul>
<li><strong>吞吐量</strong>: 运行用户代码的时间占总运行时间的比例(总运行时间:程序的运行时间+内存回收的时间)。</li>
<li><strong>垃圾收集开销</strong>: 吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>: 执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li><strong>收集频率</strong>: 相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用</strong>:  Java堆区所占的内存大小。</li>
<li><strong>快速</strong>: 一个对象从诞生到被回收所经历的时间。</li>
</ul>
<h2 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h2><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201202233303029.png" alt="image-20201202233303029"></p>
<ul>
<li>红色虚线：在JDK 8时将Serial+CMS、ParNew+Serial Oldd这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了<br>  这些组合的支持(JEP214)。</li>
<li>绿色虚线：在jdk14中弃用Paral1el Scavenge 和Serial0ld GC组合(JEP366)</li>
<li>青色虚线：在jdk14中:删除CMS垃圾回收器(JEP 363)</li>
</ul>
<h2 id="串行回收器"><a href="#串行回收器" class="headerlink" title="串行回收器"></a>串行回收器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>第一款GC，1999年随jdk1.3发布，<strong>负责回收年轻代</strong>。HotSpot中Client模式下的默认新生代垃圾收集器。<strong>采用复制算法</strong>、在HotSpot虚拟机中，使用-XX:+UseSerialGC 指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC， 且老年代用Serial Old GC。</p>
<h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p><strong>负责回收老年代</strong>，内存回收算法使用的是<strong>标记-压缩算法</strong>。是运行在Client模式下默认的老年代的垃圾回收器。在Server模式下主要有两个用途: 与新生代的Parallel Scavenge配合使用或作为老年代CMS收集器的后备垃圾收集方案。</p>
<h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>串行回收器意味着使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束(Stop The World)。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203155200633.png" alt="image-20201203155200633"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>简单而高效</strong>(与其他收集器的单线程比)，<strong>单CPU</strong>的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。一般用于用户的桌面应用等资源有限环境。</p>
<h2 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h2><h2 id="ParNew（Parallel-New）"><a href="#ParNew（Parallel-New）" class="headerlink" title="ParNew（Parallel New）"></a>ParNew（Parallel New）</h2><p><strong>负责回收年轻代</strong>，相当于Serial的多线程版，在多CPU的环境下，充分利用多CPU、多核心等物理硬件资源优势。采用<strong>复制算法</strong>。ParNew是很多JVM运行在<strong>Server模式下新生代的默认垃圾收集器。</strong></p>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203155249152.png" alt="image-20201203155249152"></p>
<h3 id="注-1"><a href="#注-1" class="headerlink" title="注"></a>注</h3><p>在单个CPU的环境下，ParNew收集 器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的-一些额外开销。除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</p>
<p>-XX: +UseParNewGC 指定ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p>-XX:ParallelGCThreads 指定线程数量，默认开启和CPU数据相同的线程数。</p>
<h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>jdk1.6后默认使用，<strong>负责回收年轻代</strong>。采用了复制算法、并行回收。和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，它也被称为<strong>吞吐量优先</strong>（高吞吐量可以充分利用CPU）的垃圾收集器。自适应调节策略也是Parallel Scavenge 与ParNew一个重要区别。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置:"></a>参数配置:</h3><p>-XX: +UseParallelGC  指定年轻代使用Parallel。</p>
<p>-XX:+UseParallel0ldGC 指定老年代都是使用并行回收收集器。</p>
<p>分别适用于新生代和老年代。默认jdk8是开启的。上面两个参数，默认开启一个，另一个也会被开启。(互相激活)。</p>
<p>-XX: ParallelGCThreads设置年轻代并行收集器的线程数。一般地与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p>在默认情况下，当CPU数量小于8个， ParallelGCThreads 的值等于CPU数量。当CPU数量大于8个， ParallelGCThreads的值等于3+ [5*CPU_ Count]/8]。</p>
<p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STW的时间)。单位是毫秒。</p>
<p>-XX: GCTimeRatio 垃圾收集时间占总时间的比例( 1 / (N+ 1))。用于衡量吞吐量的大小。取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。与前一个-XX:MaxGCPauseMillis参数有一 定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</p>
<p>-XX: +UseAdaptiveSizePolicy ,设置Parallel Scavenge收集器具有自适应调节策略<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、 晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿<br>时间之间的平衡点。</p>
<h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p><strong>负责回收老年代</strong>，用来代替老年代的Serial 0ld收集器。采用了标记-压缩算法，基于并行回收和”Stop- the-World”机制。</p>
<h3 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203155328057.png" alt="image-20201203155328057"></p>
<h3 id="注-2"><a href="#注-2" class="headerlink" title="注"></a>注</h3><p>在程序吞吐量优先的应用场景中，Parallel 收集器和Parallel 0ld 收集器的组合，在Server模式下的内存回收性能很不错。在jdk8中，默认是此垃圾收集器。</p>
<h2 id="并发回收器"><a href="#并发回收器" class="headerlink" title="并发回收器"></a>并发回收器</h2><h3 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h3><p><strong>负责回收老年代</strong>，jdk1.5推出，采用<strong>标记-清除算法</strong>，并且也会”Stop- the-world”。是HotSpot虚拟机中<strong>第一 款</strong>真正意义上的<strong>并发收集器</strong>，它第一次实现了让<strong>垃圾收集线程与用户线程同时工作</strong>（<strong>低延迟</strong>）。缩短垃圾收集时间、用户线程的停顿时。</p>
<h3 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201203152900355.png" alt="image-20201203152900355"></p>
<h4 id="初始标记阶段-Initial-Mark"><a href="#初始标记阶段-Initial-Mark" class="headerlink" title="初始标记阶段(Initial-Mark)"></a>初始标记阶段(Initial-Mark)</h4><p>会出现“Stop- the-World”，只标记出GCRoots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
<h4 id="并发标记阶段-Concurrent-Mark"><a href="#并发标记阶段-Concurrent-Mark" class="headerlink" title="并发标记阶段(Concurrent-Mark)"></a>并发标记阶段(Concurrent-Mark)</h4><p>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
<h4 id="重新标记阶段-Remark"><a href="#重新标记阶段-Remark" class="headerlink" title="重新标记阶段(Remark)"></a>重新标记阶段(Remark)</h4><p>在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
<h4 id="并发清除阶段-Concurrent-Sweep"><a href="#并发清除阶段-Concurrent-Sweep" class="headerlink" title="并发清除阶段(Concurrent -Sweep)"></a>并发清除阶段(Concurrent -Sweep)</h4><p>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。</p>
<h3 id="注-3"><a href="#注-3" class="headerlink" title="注"></a>注</h3><ol>
<li><p>CMS无法与JDK 1.4 中已经存在的新生代收集器Paral1el Scavenge配合工作，所以在jdk1. 5中使用时，新生代只能选择ParNew或者Serial收集器中的一个。</p>
</li>
<li><p>在CMS回收过程中，为确保应用程序用户线程有足够的内存可用。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收。若CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure“失败，这时虚拟机将启动后备预案Serial 0ld收集器来重新进行老年代的垃圾收集，停顿时间变长了。</p>
</li>
<li><p>jdk9将CMS标记Deprecate（弃用），jdk14将其移除</p>
</li>
</ol>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>-XX: +UseConcMarkSweepGC手动指定使用CMS收集器。开启该参数后会自动将-XX: +UseParNewGC打开。 即: ParNew (Young区<br>用) +CMS (Old区用) +Serial Old的组合。</p>
<p>-XX: CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值，jdk1.5及其以前默认68%，1.6以上默认92%。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Serial GC：最小化地使用内存和并行开销。</p>
<p>Parallel GC：最大化应用程序的吞吐量。</p>
<p>CMS GC：最小化Gc的中断或停顿时间。</p>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>jdk9默认使用，在延迟可控的情况下获得尽可能高的吞吐量。<strong>主要针对多核CPU以及大量内存的机器</strong>，兼顾<strong>年轻代和老年代</strong>的回收。将堆内存（Eden、survivor1、survivor2、老年代等）分割成很多不相关的区域（Region，物理上可不连续）。后台维护一个以回收时间和回收价值排序的优先列表，region作为基本回收单位，每次回收只需要回收部分Region区。</p>
<p>JVM使用Remembered Set解决一个对象被不同Region区引用问题，避免全局扫描，每个Region都有一个对应的Rememberd Set（用来判断对象是否存活），若写入的数据有引用其他Region区的数据时，会去更新被引用数据的Region的Rememberd  Set。</p>
<h3 id="Region分区图"><a href="#Region分区图" class="headerlink" title="Region分区图"></a>Region分区图</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205151643878.png" alt="image-20201205151643878"></p>
<p>注：空白为未使用区，humongous主要是为了存储大对象若对象超过0.5个Region时，就放到humongous区。</p>
<h3 id="工作流程-4"><a href="#工作流程-4" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205151949513.png" alt="image-20201205151949513"></p>
<h4 id="年轻代并行GC"><a href="#年轻代并行GC" class="headerlink" title="年轻代并行GC"></a>年轻代并行GC</h4><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205153301399.png" alt="image-20201205153301399"><br>1.扫描根。<br>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>2.更新RSet.<br>处理dirty card queue中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<p>注：对于应用程序的引用赋值语句bject.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队-个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</p>
<p>3.处理RSet。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<p>4.复制对象。<br>此阶段，对象树被遍历，Eden区 内存段中存活的对象会被复制到Survivor区中空的内存分段,Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p>处理引用。<br>处理Soft，Weak，Phantom， Final， JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h4 id="并发标记过程"><a href="#并发标记过程" class="headerlink" title="并发标记过程"></a>并发标记过程</h4><p>1.初始标记阶段:标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。</p>
<p>2.根区域扫描(Root Region Scanning) : 扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。</p>
<p>3.并发标记(Concurrent Marking): 在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被youngGC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾,那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例，默认超过65%在回收阶段才会被回收)。</p>
<p>4.再次标记(Remark): 由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法: snapshot-at-the-beginning (SATB)。</p>
<p>5.独占清理(cleanup,STW): 计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集。</p>
<p>6.并发清理阶段:识别并清理完全空闲的区域。</p>
<h4 id="导致Full-GC的原因"><a href="#导致Full-GC的原因" class="headerlink" title="导致Full GC的原因"></a>导致Full GC的原因</h4><ul>
<li>Evacuation的时候没有足够的to-space来存放晋升的对象。</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><h5 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h5><p>Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact )算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p>
<h5 id="可预测的停顿时间模型-即-软实时soft-real-time"><a href="#可预测的停顿时间模型-即-软实时soft-real-time" class="headerlink" title="可预测的停顿时间模型(即:软实时soft real-time)"></a>可预测的停顿时间模型(即:软实时soft real-time)</h5><p>能明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。<br>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</p>
<p>G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>需要维护优先列表，需要更多的而外内存占用。</p>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>-XX:+UseG1GC 指定使用G1回收器。</p>
<p>-XX: G1HeapRegionSize: 设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p>
<p>-XX : MaxGCPauseMillis：设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms。</p>
<p>-XX: ParallelGCThread设 置STW工作线程数的值。最多设置为8 。</p>
<p>-XX: ConcGCThreads：设置并发标记的线程数。</p>
<p>-XX: InitiatingHeapOccupancyPercent设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p>
<h2 id="七种垃圾回收器对比"><a href="#七种垃圾回收器对比" class="headerlink" title="七种垃圾回收器对比"></a>七种垃圾回收器对比</h2><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/image-20201205153827039.png" alt="image-20201205153827039"></p>
<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>使用-XX:+PrintGCDetails 打印GC日志</p>
<p>-Xloggc: path/gc_log. log 将日志输出到文件</p>
<h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/1607148456(1).jpg" alt="1607148456(1)"></p>
<h3 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h3><p><img src="/2020/12/02/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/1607148484(1).jpg" alt="1607148484(1)"></p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收相关概念及算法</title>
    <url>/2020/11/30/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="判断对象存活方式"><a href="#判断对象存活方式" class="headerlink" title="判断对象存活方式"></a>判断对象存活方式</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>引用计数算法(Reference Counting) ，对每个对象保存<strong>一个整型的引用计数器属性</strong>。用于记录对象被引用的情况。对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1;当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><p>实现简单，垃圾对象便于辨识;判定效率高，回收没有延迟性。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul>
<li>它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。</li>
<li>引用计数器有一个严重的问题，即无法处理循环引用的情况。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制,以提高吞吐量的尝试。</p>
<p>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p>
<p>引用计数算法，是很多语言的资源回收选择，如Python，同时支持引用计数和垃圾收集机制。</p>
<p>​    <strong>Python如何解决循环引用?</strong></p>
<p>​    手动解除: 就是在合适的时机，解除引用关系。使用弱引用weakref，weakref是Python提供的标准库， 旨在解决循环引用。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>可达性分析算法是以根对象集合(GC Roots[<strong>所谓”GC Roots”根集 合就是一组必须活跃的引用</strong>])为起始点，按照从上至下的方式搜索被根对象集合所<strong>连接的目标对象是否可达</strong>。使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链(Reference Chain)**，如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
<h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>Java的GC Roots包括以几类元素:</p>
<ol>
<li>虚拟机栈中引用的对象。如:各个线程被调用的方法中使用到的参数、局部变量等。</li>
<li>本地方法栈内JNI (通常说的本地方法)引用的对象</li>
<li>方法区中类静态属性引用的对象。如: Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象。如:字符串常量池(String Table) 里的引用</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虛拟机内部的引用。</li>
<li>基本数据类型对应的Class对象，一些常驻的异常对象(如:NullPointerException、OutOfMemoryError)，系统类加载器。</li>
<li>反映java虛拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
<li>在分代收集和局部回收时，GC Roots集临时性的加入其他对象，比如针对新生代回收，老年代的对象也要纳入GC Roots集中。</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须“StopTheWorld”的一个重要原因。即使是号称(几乎)不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><ul>
<li><p>Java语言提供了对象终止(finalization) 机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即:垃圾回收此对象之前，总会先调用这个对象的finalize()方法。.</p>
</li>
<li><p>finalize ()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
</ul>
<h3 id="不重写finalize-方法的原因"><a href="#不重写finalize-方法的原因" class="headerlink" title="不重写finalize()方法的原因"></a>不重写finalize()方法的原因</h3><ol>
<li>在finalize()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定。</li>
<li>若不发生GC，则finalize ()方法将没有执行机会。</li>
<li>一个糟糕的finalize()会严重影响GC的性能。</li>
</ol>
<h3 id="虚拟机中Java对象的三种状态"><a href="#虚拟机中Java对象的三种状态" class="headerlink" title="虚拟机中Java对象的三种状态"></a>虚拟机中Java对象的三种状态</h3><ol>
<li>可触及的:从根节点开始，可以到达这个对象。</li>
<li>可复活的:对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li>不可触及的:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及 的对象不可能被复活，因为finalize()只会被调用一次。</li>
</ol>
<h3 id="判定一个对象是否可回收，至少要经历两次标记过程"><a href="#判定一个对象是否可回收，至少要经历两次标记过程" class="headerlink" title="判定一个对象是否可回收，至少要经历两次标记过程:"></a>判定一个对象是否可回收，至少要经历两次标记过程:</h3><ol>
<li><h4 id="如果对象到GC-Roots没有-引用链，则进行第一次标记。"><a href="#如果对象到GC-Roots没有-引用链，则进行第一次标记。" class="headerlink" title="如果对象到GC Roots没有 引用链，则进行第一次标记。"></a>如果对象到GC Roots没有 引用链，则进行第一次标记。</h4></li>
<li><h4 id="进行筛选，判断此对象是否有必要执行finalize-方法"><a href="#进行筛选，判断此对象是否有必要执行finalize-方法" class="headerlink" title="进行筛选，判断此对象是否有必要执行finalize()方法"></a>进行筛选，判断此对象是否有必要执行finalize()方法</h4><p> ① 如果对象没有 重写finalize()方法，或者finalize ()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，被判定为不可触及的。</p>
<p> ② 如果对象重写 了finalize()方法，且还未执行过，那么该对象会被插入到E-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize ()方法执行。</p>
<p> ③ finalize()方法是对象逃脱死亡的最后机会，稍后GC会对E-Queue队列中的对象进行第二次标记。如果对象在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，对象会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</p>
</li>
</ol>
<h1 id="垃圾清除"><a href="#垃圾清除" class="headerlink" title="垃圾清除"></a>垃圾清除</h1><h2 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记 - 清除算法( Mark-Sweep)"></a>标记 - 清除算法( Mark-Sweep)</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序(也被称为stop the world) ，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<p>标记: Collector从引用 根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p>
<p>清除:Collector对堆 内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>效率不算高。</li>
<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差。</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表。</li>
</ol>
<h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h2><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ol>
<li>没有标记和清除过程，实现简单，运行高效。</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ol>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点:"></a>缺点:</h3><ol>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ol>
<h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的:"></a>特别的:</h3><ol>
<li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</li>
<li>即特别适合垃圾对象很多,存活对象很少的场景;例如:Young区的Survivor0和Survivor1区</li>
</ol>
<h2 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记 - 压缩算法(Mark-Compact )"></a>标记 - 压缩算法(Mark-Compact )</h2><p>第一阶段和标记清除算法- -样，从根节点开始标记所有被引用对象,第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。<br>之后，清理边界外所有的空间。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点:"></a>优点:</h3><ol>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只 需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ol>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点:"></a>缺点:</h3><ol>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>
<li>移动过程中，需要全程暂停用户应用程序。即: STW。</li>
</ol>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。目前几乎所有的GC都是采用分代收集(Generational Collecting) 算法执行垃圾回收的。</p>
<h3 id="年轻代-Young-Gen"><a href="#年轻代-Young-Gen" class="headerlink" title="年轻代(Young Gen)"></a>年轻代(Young Gen)</h3><p>算法：复制算法。</p>
<p>特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>速度最快。效率只和当前存活对象大小有关，而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<h3 id="老年代-Tenured-Gen"><a href="#老年代-Tenured-Gen" class="headerlink" title="老年代(Tenured Gen)"></a>老年代(Tenured Gen)</h3><p>算法：一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<p>特点:区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</p>
<h4 id="各阶段开销"><a href="#各阶段开销" class="headerlink" title="各阶段开销"></a>各阶段开销</h4><p>Mark（标记）阶段的开销与存活对象的数量成正比。</p>
<p>Sweep（清除）阶段的开销与所管理区域的大小成正相关。</p>
<p>Compact（压缩/整理）阶段的开销与存活对象的数据成正比。</p>
<h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。降低系统停顿时间，但线程切换和上下文转换消耗，导致垃圾回收成本增加。总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>为了更好地控制GC产生的停顿时间，将一块大的内存区 域分割成多个小块，根据目标的停顿时间，每次合理地回收若千个小区间，而不是整个堆空间，从而减少一 次GC所产生的停顿。分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成<br>连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载过程</title>
    <url>/2020/12/12/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2020/12/12/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/image-20201212194346694.png" alt="image-20201212194346694"></p>
<h2 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h2><h3 id="在加载类时，Java-虚拟机必须完成以下3件事情"><a href="#在加载类时，Java-虚拟机必须完成以下3件事情" class="headerlink" title="在加载类时，Java 虚拟机必须完成以下3件事情"></a>在加载类时，Java 虚拟机必须完成以下3件事情</h3><ol>
<li>通过类的全名，获取类的二进制数据流。</li>
<li>解析类的二进制数据流，在<strong>方法区</strong>中构建Java<strong>类模板对象</strong>。</li>
<li>在<strong>堆</strong>中创建java. lang. Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>注：</p>
<ul>
<li><strong>类模板对象</strong>，是Java类在JVM内存中的一个快照，JVM将 从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成 员变量进行遍历，也能进行Java方法的调用。反射的机制即基于这一基础。 如果JVM没 有将Java类的声明信息存储起来，则JVM在 运行期也无法反射。</li>
<li><strong>数组类</strong>本身不是由类加载器负责创建的，JVM在加载数组的时候加载的仅仅是数组的类型类（如String[] 加载String这个类型类），而数组的创建则由JVM在运行时根据需要直接创建的。如果是N维数组，类加载器会从最外层开始一层一层的递归加载，直到加载到非数组类型为止。</li>
</ul>
<h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><ul>
<li><p>通过文件系统读入一个class后缀的文件(最常见) 。</p>
</li>
<li><p>读入jar、zip等归档数据包，提取类文件。</p>
</li>
<li><p>事先存放在数据库中的类的二进制数据。</p>
</li>
<li><p>使用类似于HTTP之类的协议通过网络进行加载。</p>
</li>
<li><p>在运行时生成一段Class的二进制信息。</p>
</li>
<li><p>……</p>
</li>
</ul>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><h3 id="Verification-验证"><a href="#Verification-验证" class="headerlink" title="Verification(验证)"></a>Verification(验证)</h3><p><strong>目的是保证加载的字节码是合法、合理并符合规范的。</strong></p>
<ol>
<li><p><strong>格式检查</strong></p>
<p> 魔数检查（class文件前四个字节的16进制是不是0xCAFEBABE）。</p>
<p> 版本检查（高版本Java编译器编译出来的class文件无法在低版本运行）。</p>
<p> 长度检查（数据项的码，每一项长度是否正确）。</p>
</li>
<li><p><strong>语义检查</strong></p>
<p> 是否有类继承final（被定义为final的方法或者类无法被重写或继承）。</p>
<p> 是否有父类（在Java里，除了object外，其他类都应该有父类）。</p>
<p> 抽象方法是否有实现 （非抽象类是否实现了所有抽象方法或者接口方法）。</p>
<p> 是否存在不兼容的方法(比如方法的签名除了返回值不同，其他都一样， 这种方法会让虚拟机无从下手调度; abstract情况下的方法，就不能是final的了)。</p>
</li>
<li><p><strong>字节码验证</strong></p>
<p> 跳转指令是否指向正确位置（在字节码的执行过程中，是否会跳转到一条不存在的指令）。</p>
<p> 变量的赋值是不是给了正确的数据类型。</p>
<p> 函数的调用是否传递了正确类型的参数。</p>
</li>
<li><p><strong>符号引用验证</strong></p>
<p> 符号引用的直接引用是否存在（Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。虚拟机会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError ,如果一个 方法无法被找到，则会抛出NoSuchMethodError）。</p>
</li>
</ol>
<h3 id="Preparation-准备"><a href="#Preparation-准备" class="headerlink" title="Preparation(准备)"></a>Preparation(准备)</h3><p>虚拟机会为该类分配内存空间并为静态字段设置默认值</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li>这里不包含基本数据类型的字段用static final修饰的情况， 因为final在编译的时候就会分配了，准备阶段会显式赋值。</li>
<li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </li>
</ol>
<h3 id="Resolution-解析"><a href="#Resolution-解析" class="headerlink" title="Resolution(解析)"></a>Resolution(解析)</h3><p>将类、接口、字段和方法符号引用转为直接引用。</p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。在Class类文件中，通过常量池进行了大量的符号引用。解析操作会把符号引用转为对应目标的直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>执行类的初始化方法：&lt; clinit&gt;();，该方法由Java编译器生成并由JVM调用，开发者无法自定义它，它是由类静态成员到的赋值语句及static代码块语句合并而产生的。即初始化阶段为类的静态变量赋予正确的初始值。</p>
<p>注：在加载一个类前，会先加载其父类，因此父类的clinit方法总在子类前被调用。</p>
<p><strong>没有类初始化方法的情况</strong></p>
<ul>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时。</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。</li>
<li>一个类中只包含static final修饰的<strong>基本数据类型</strong>的字段，这些类字段初始化语句采用编译时<strong>常量表达式</strong>。</li>
</ul>
<p>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行。对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld0&quot;</span>;<span class="comment">//在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld1&quot;</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s2 = <span class="string">&quot;helloworld2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">//在初始化阶段&lt; clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="lt-clinit-gt-的调用"><a href="#lt-clinit-gt-的调用" class="headerlink" title="&lt; clinit&gt;()的调用"></a>&lt; clinit&gt;()的调用</h3><h4 id="类的主动使用：意味着会调用类的-lt-clinit-gt"><a href="#类的主动使用：意味着会调用类的-lt-clinit-gt" class="headerlink" title="类的主动使用：意味着会调用类的&lt; clinit&gt;()"></a>类的主动使用：意味着会调用类的&lt; clinit&gt;()</h4><ol>
<li>当创建一个类的实例时，比如使用new关键字，或者通过反射（如Class.forName(“com.atguigu.java.Test”)）、克隆、反序列化。</li>
<li>当调用类的静态方法时，即当使用了字节码invokestatic指令。</li>
<li>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</li>
<li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化（<strong>并不会先初始化它所实现的接口**</strong>，在初始化一个接口时，并不会先初始化它的父接口，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。）。</li>
<li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）</li>
</ol>
<h4 id="类的被动使用：即不会进行类的初始化操作，即不会调用-lt-clinit-gt"><a href="#类的被动使用：即不会进行类的初始化操作，即不会调用-lt-clinit-gt" class="headerlink" title="类的被动使用：即不会进行类的初始化操作，即不会调用&lt; clinit&gt;()"></a>类的被动使用：即不会进行类的初始化操作，即不会调用&lt; clinit&gt;()</h4><ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。（当通过子类引用父类的静态变量，不会导致子类初始化）</li>
<li>通过数组定义类引用，不会触发此类的初始化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] objectList = <span class="keyword">new</span> Object[<span class="number">10</span>];<span class="comment">//执行此句并不会使Object类的&lt; clinit&gt;()被调用</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
</li>
<li><p>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
</li>
</ol>
<p><strong>注：没有初始化的类，不意味着没有加载！</strong></p>
<h2 id="使用阶段"><a href="#使用阶段" class="headerlink" title="使用阶段"></a>使用阶段</h2><p>即可直接使用，调用它的静态字段、方法。使用new关键字创建实例对象。</p>
<h2 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h2><p><strong>条件</strong></p>
<ul>
<li>该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收。</li>
<li>该类对应的java. lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
<li>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一一样，没有引用了就必然会回收。</li>
</ul>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot全局异常处理</title>
    <url>/2020/10/27/Springboot/springboot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>​    @ControllerAdvice注解是Spring3.2中新增的注解，只能用于类上，与下面三个方法注解结合可进行一些全局操作。</p>
<h3 id="方法注解"><a href="#方法注解" class="headerlink" title="方法注解"></a>方法注解</h3><h3 id="InitBinder"><a href="#InitBinder" class="headerlink" title="@InitBinder"></a>@InitBinder</h3><p>用于request中自定义参数解析方式进行注册，从而达到自定义指定格式参数的目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Date类型参数转换器的实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> binder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalInitBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>表示其注解的方法将会在目标Controller方法执行之前执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ModelAttribute(value = &quot;key&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">globalModelAttribute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加了全局属性。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;key_value&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">list</span><span class="params">(<span class="meta">@ModelAttribute(&quot;key&quot;)</span> String key)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台打印：</p>
<p>​    添加了全局属性。</p>
<p>​    key: key_value</p>
<h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>用于捕获Controller中抛出的指定类型的异常</p>
<p>​    返回自定义实体 统一格式，特别是前后端分离自定义消息格式（记得加@ResponseBody）。</p>
<p>​    返回 ModelAndView 跳转到指定页面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.czm.constants.ResultCodeEnum;</span><br><span class="line"><span class="keyword">import</span> com.czm.dto.ResultDto;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MissingServletRequestParameterException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.NoHandlerFoundException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">//返回ResultDto消息实体的json对象</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">exceptionHandler</span><span class="params">(Exception exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;未知错误：&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName() ,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.ERROR.getCode(), 		</span><br><span class="line">                                           ResultCodeEnum.ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(MissingServletRequestParameterException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">ParameterExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        								MissingServletRequestParameterException exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误请求：&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName() ,exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.BAG_REQUEST.getCode(), </span><br><span class="line">                                           ResultCodeEnum.BAG_REQUEST.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultDto&lt;String&gt; <span class="title">NotFountHandler</span><span class="params">(NoHandlerFoundException exception)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;404错误:&#123;&#125;,&#123;&#125;&quot;</span>,exception.getClass().getName(), exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResultDto.buildErrorMeesage(ResultCodeEnum.NOT_FOUND.getCode(), </span><br><span class="line">                                           ResultCodeEnum.NOT_FOUND.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置-否则拦截不到"><a href="#注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置-否则拦截不到" class="headerlink" title="注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置,否则拦截不到"></a>注：要想拦截404，400等错误请求，需要在springboot配置文件上加上一下配置,否则拦截不到</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#出现错误时, 直接抛出异常</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">   <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#不要为我们工程中的资源文件建立映射</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">   <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bug</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.3.1.RELEASE与javaFx整合</title>
    <url>/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><figure class="highlight xml"><figcaption><span>&lt;dependency&gt;</span></figcaption><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.roskenet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-javafx-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="启动类继承AbstractJavaFxApplicationSupport"><a href="#启动类继承AbstractJavaFxApplicationSupport" class="headerlink" title="启动类继承AbstractJavaFxApplicationSupport"></a>启动类继承AbstractJavaFxApplicationSupport</h2><p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375394146.png" alt="启动类"></p>
<h2 id="采用mvc模式"><a href="#采用mvc模式" class="headerlink" title="采用mvc模式"></a>采用mvc模式</h2><ul>
<li><h3 id="每个fxml页面都有对应的java视图类"><a href="#每个fxml页面都有对应的java视图类" class="headerlink" title="每个fxml页面都有对应的java视图类"></a>每个fxml页面都有对应的java视图类</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375588.png" alt="视图"></p>
<ul>
<li><h3 id="视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）"><a href="#视图类需继承AbstractFxmlView且有-FXMLView注解-（value值为对应的fxml文件路径）" class="headerlink" title="视图类需继承AbstractFxmlView且有**@FXMLView注解**（value值为对应的fxml文件路径）"></a>视图类需继承<strong>AbstractFxmlView</strong>且有**@FXMLView注解**（value值为对应的fxml文件路径）</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597375950(1).jpg" alt="视图类"></p>
<ul>
<li><h3 id="fxml文件中需指定对应controller类"><a href="#fxml文件中需指定对应controller类" class="headerlink" title="fxml文件中需指定对应controller类"></a>fxml文件中需指定对应controller类</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376230(1).jpg" alt="fxml文件"></p>
<ul>
<li><h3 id="controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息"><a href="#controller类需实现Initializable接口并加上-FXMLController-注解-属性上有FXML注解的会根据属性名与fxml中的fx-id值对应的组件绑定，方便获取值等信息" class="headerlink" title="controller类需实现Initializable接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)"></a>controller类需实现<strong>Initializable</strong>接口并加上**@FXMLController**注解(属性上有FXML注解的会根据属性名与fxml中的fx:id值对应的组件绑定，方便获取值等信息)</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376444(1).jpg"></p>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597376926(1).jpg"></p>
<ul>
<li><h3 id="fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法"><a href="#fxml中的绑定事件名前面需加个-，即可绑定对应controller的同名方法" class="headerlink" title="fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法"></a>fxml中的绑定事件名前面需加个#，即可绑定对应controller的同名方法</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377406(1).jpg"></p>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377507(1).jpg"></p>
<h2 id="示例页面效果展示-只是简单项目，页面可能有点丑"><a href="#示例页面效果展示-只是简单项目，页面可能有点丑" class="headerlink" title="示例页面效果展示(只是简单项目，页面可能有点丑)"></a>示例页面效果展示(只是简单项目，页面可能有点丑)</h2><ul>
<li><h3 id="登陆页面"><a href="#登陆页面" class="headerlink" title="登陆页面"></a>登陆页面</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377745(1).jpg" alt="登陆"></p>
<ul>
<li><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377865(1).jpg" alt="主页"></p>
<ul>
<li><h3 id="点击住宿按钮弹出住宿页面进行信息登记"><a href="#点击住宿按钮弹出住宿页面进行信息登记" class="headerlink" title="点击住宿按钮弹出住宿页面进行信息登记"></a>点击住宿按钮弹出住宿页面进行信息登记</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597377915(1).jpg"></p>
<ul>
<li><h3 id="双击对应表格中的宿舍即可查看详情"><a href="#双击对应表格中的宿舍即可查看详情" class="headerlink" title="双击对应表格中的宿舍即可查看详情"></a>双击对应表格中的宿舍即可查看详情</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378007(1).jpg"></p>
<ul>
<li><h3 id="宿舍管理页面"><a href="#宿舍管理页面" class="headerlink" title="宿舍管理页面"></a>宿舍管理页面</h3></li>
</ul>
<p><img src="/2020/09/17/Springboot/SpringBoot2.3.1.RELEASE%E4%B8%8EjavaFx%E6%95%B4%E5%90%88/1597378103(1).jpg"></p>
<h2 id="获取项目"><a href="#获取项目" class="headerlink" title="获取项目"></a>获取项目</h2><ul>
<li><h3 id="Git仓库地址"><a href="#Git仓库地址" class="headerlink" title="Git仓库地址"></a><a href="https://github.com/czmDeRepository/javaFx">Git仓库地址</a></h3></li>
<li><h3 id="注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql"><a href="#注：运行项目前先在数据库建表-可直接执行sql文件：management-system-sql" class="headerlink" title="注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql"></a><strong>注：运行项目前先在数据库建表,可直接执行sql文件：management_system.sql</strong></h3></li>
</ul>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot实用技能</title>
    <url>/2020/10/17/Springboot/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="参数校验Validation注解"><a href="#参数校验Validation注解" class="headerlink" title="参数校验Validation注解"></a>参数校验Validation注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>@AssertFalse</td>
<td>可以为null,如果不为null的话必须为false</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>可以为null,如果不为null的话必须为true</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>设置不能超过最大值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>设置不能超过最小值</td>
</tr>
<tr>
<td>@Digits</td>
<td>设置必须是数字且数字整数的位数和小数的位数必须在指定范围内</td>
</tr>
<tr>
<td>@Future</td>
<td>日期必须在当前日期的未来</td>
</tr>
<tr>
<td>@Past</td>
<td>日期必须在当前日期的过去</td>
</tr>
<tr>
<td>@Max</td>
<td>最大不得超过此最大值</td>
</tr>
<tr>
<td>@Min</td>
<td>最大不得小于此最小值</td>
</tr>
<tr>
<td>@NotNull</td>
<td>不能为null，可以是空</td>
</tr>
<tr>
<td>@Null</td>
<td>必须为null</td>
</tr>
<tr>
<td>@Pattern</td>
<td>必须满足指定的正则表达式</td>
</tr>
<tr>
<td>@Size</td>
<td>集合、数组、map等的size()值必须在指定范围内</td>
</tr>
<tr>
<td>@Email</td>
<td>必须是email格式</td>
</tr>
<tr>
<td>@Length</td>
<td>长度必须在指定范围内</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>字符串不能为null,字符串trim()后也不能等于“”</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“”</td>
</tr>
<tr>
<td>@Range</td>
<td>值必须在指定范围内</td>
</tr>
<tr>
<td>@URL</td>
<td>必须是一个URL</td>
</tr>
</tbody></table>
<p><a href="https://blog.csdn.net/justry_deng/article/details/86571671">参考链接</a></p>
<h2 id="ResponseBodyAdvice"><a href="#ResponseBodyAdvice" class="headerlink" title="ResponseBodyAdvice"></a>ResponseBodyAdvice</h2><p>实现ResponseBodyAdvice接口再配合@ControllerAdvice注解可拦截并自定义response返回的结果。</p>
<h2 id="SpringMVC返回json报错（坑！！！）"><a href="#SpringMVC返回json报错（坑！！！）" class="headerlink" title="SpringMVC返回json报错（坑！！！）"></a>SpringMVC返回json报错（坑！！！）</h2><p>为让springmvc返回json(spring版本5.3.8),在pom中引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义转换器（非必须）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/7/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">MappingJackson2HttpMessageConverter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span> <span class="params">(Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            HttpMessageNotWritableException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 Jackson 的 ObjectMapper 将 Java 对象转换成 Json String</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String json = mapper.writeValueAsString (object);</span><br><span class="line">        outputMessage.getBody().write (json.getBytes ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改springmvc配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.czm.converter.MyHttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">&#x27;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&#x27;</span>: Cannot create inner bean <span class="string">&#x27;com.czm.converter.MyHttpMessageConverter#0&#x27;</span> of <span class="built_in">type</span> [com.czm.converter.MyHttpMessageConverter] <span class="keyword">while</span> setting bean property <span class="string">&#x27;messageConverters&#x27;</span> with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">&#x27;com.czm.converter.MyHttpMessageConverter#0&#x27;</span>: Lookup method resolution failed; nested exception is java.lang.IllegalStateException: Failed to introspect Class [com.czm.converter.MyHttpMessageConverter] from ClassLoader [ParallelWebappClassLoader</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>百度好久。最终发现json包没引入lib目录下（原因不知）！！！手动添加即可。</p>
<p><img src="/2020/10/17/Springboot/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/image-20210703135316350.png" alt="image-20210703135316350"></p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Groovy基础语法</title>
    <url>/2021/05/30/java/Groovy%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.groovy</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author CZM</span></span><br><span class="line"><span class="comment"> * @create 2021/5/29</span></span><br><span class="line"><span class="comment"> * 参考链接</span></span><br><span class="line"><span class="comment"> * @link https://blog.csdn.net/kmyhy/article/details/4200563</span></span><br><span class="line"><span class="comment"> * @link https://blog.csdn.net/yanbober/article/details/49047515</span></span><br><span class="line"><span class="comment"> * @link https://blog.csdn.net/zhaoyanjun6/article/details/70313790</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">test = <span class="keyword">new</span> LearnGroovy([<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;sno&quot;</span>:<span class="number">1111</span>])</span><br><span class="line"><span class="comment">//test = new LearnGroovy(&quot;name&quot;:&quot;小明&quot;, &quot;sno&quot;:1111)</span></span><br><span class="line">test.method()</span><br><span class="line">println test.name</span><br><span class="line">println test.<span class="meta">@name</span> <span class="comment">//忽略getter方法，直接获取字段值</span></span><br><span class="line">println test.sno</span><br><span class="line">println test.getSno()</span><br><span class="line"></span><br><span class="line">test?.method()</span><br><span class="line"><span class="comment">//与下面等价</span></span><br><span class="line">if( test!= null) &#123;</span><br><span class="line">    test.method()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object test3 = test ? test : <span class="string">&quot;空对象&quot;</span></span><br><span class="line"><span class="comment">//基于不重复原则与下面等价</span></span><br><span class="line">Object test2 = test ?: <span class="string">&quot;空对象&quot;</span></span><br><span class="line"></span><br><span class="line">println test2.class</span><br><span class="line"></span><br><span class="line">println <span class="string">&quot;$&#123;test&#125;&quot;</span>.class</span><br><span class="line">def tt()&#123;</span><br><span class="line">    println <span class="string">&quot;Tt&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">for (def i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    println test.class</span><br><span class="line">tt()</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持两种集合 collection（List(默认ArrayList)） 和map(默认LinkedHashMap)</span></span><br><span class="line">def collection = [<span class="number">1</span>,<span class="string">&quot;str&quot;</span>,test]</span><br><span class="line"><span class="comment">//往集合添加元素方法</span></span><br><span class="line">collection[collection.size()] = <span class="string">&quot;new1&quot;</span></span><br><span class="line">collection &lt;&lt; <span class="string">&quot;new2&quot;</span></span><br><span class="line">collection.add(<span class="string">&quot;new3&quot;</span>)</span><br><span class="line"></span><br><span class="line">println collection</span><br><span class="line">println collection[<span class="number">2</span>]</span><br><span class="line">collection.remove test</span><br><span class="line">println collection[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">println collection[<span class="number">-2</span>] <span class="comment">//倒数第二个</span></span><br><span class="line">println collection.class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def map = [<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">key2 :</span> <span class="number">2</span>]</span><br><span class="line">map.put(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">map += [<span class="string">&quot;new1&quot;</span>:<span class="number">1</span>, <span class="string">&quot;new2&quot;</span> : <span class="number">2</span>]</span><br><span class="line">println map</span><br><span class="line">println map[<span class="string">&quot;key2&quot;</span>]</span><br><span class="line">println map.key2</span><br><span class="line">println map.getClass()</span><br><span class="line">println <span class="string">&quot;遍历&quot;</span></span><br><span class="line">map.each &#123;key,val -&gt; println <span class="string">&quot;$key:$val&quot;</span>&#125;</span><br><span class="line"><span class="comment">//it是一个关键字，代表每一个遍历元素</span></span><br><span class="line">map.each &#123;println it&#125;</span><br><span class="line">map.each &#123;println it.getKey() +<span class="string">&quot;:&quot;</span>+ it.getValue()&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;()</span><br><span class="line">println map2.getClass()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> set = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">as</span> HashSet</span><br><span class="line">println set.<span class="keyword">class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">def</span> closure = &#123; param1,param2 -&gt; &#123;</span><br><span class="line">    println <span class="string">&quot;参数1：$param1, 参数2：$&#123;param2&#125;&quot;</span></span><br><span class="line">    println <span class="string">&quot;参数2类型：&quot;</span> +param2.getClass()</span><br><span class="line">&#125;&#125;</span><br><span class="line">closure(<span class="string">&quot;你好&quot;</span>,<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">closure.call(<span class="string">&quot;你好2&quot;</span>, <span class="keyword">new</span> HashSet&lt;Integer&gt;())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum(<span class="keyword">int</span>... var) &#123;</span><br><span class="line">    <span class="keyword">def</span> total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> var)</span><br><span class="line"></span><br><span class="line">        total += i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println sum(<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">println sum(<span class="number">1</span>,<span class="number">7</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//int total =0</span></span><br><span class="line"><span class="comment">//add = &#123; ... list -&gt; &#123;</span></span><br><span class="line"><span class="comment">//    list.each&#123;total += it&#125;</span></span><br><span class="line"><span class="comment">//    return add</span></span><br><span class="line"><span class="comment">//&#125;&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//add.call(1,2).call(2,3,4)</span></span><br><span class="line"><span class="comment">//println total</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span>&#123;</span></span><br><span class="line">    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> today = Day.SATURDAY</span><br><span class="line"><span class="keyword">switch</span> (today) &#123;</span><br><span class="line">    <span class="comment">//Saturday or Sunday</span></span><br><span class="line">    <span class="keyword">case</span> [Day.SATURDAY, Day.SUNDAY]:</span><br><span class="line">        println <span class="string">&quot;Weekends&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment">//a day between Monday and Friday</span></span><br><span class="line">    <span class="keyword">case</span> Day.MONDAY..Day.<span class="attr">FRIDAY:</span></span><br><span class="line">        println <span class="string">&quot;work day&quot;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="symbol">default:</span></span><br><span class="line">        println <span class="string">&quot;Are you sure this is a valid day?&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Groovy所有的对象都有一个元类metaClass，我们可以通过metaClass属性访问该元类。通过元类，可以为这个对象增加方法</span></span><br><span class="line">String msg = <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">msg.metaClass.up = &#123;delegate.toUpperCase()&#125;</span><br><span class="line">println msg.up()</span><br><span class="line"><span class="comment">//打印所有属性以及方法</span></span><br><span class="line">msg.metaClass.properties.each &#123; println it.name&#125;</span><br><span class="line"><span class="comment">//msg.metaClass.methods.each &#123; println it.name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//assert msg == 1</span></span><br><span class="line">println <span class="string">&quot;###&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用闭包实现加法</span></span><br><span class="line"><span class="keyword">def</span> sum() &#123;</span><br><span class="line">    <span class="keyword">int</span> total =<span class="number">0</span></span><br><span class="line">    add = &#123; ... list -&gt; &#123;</span><br><span class="line">        list.each&#123; total += it&#125;</span><br><span class="line">        <span class="keyword">return</span> add</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    val = &#123;total&#125;</span><br><span class="line">&#125;</span><br><span class="line">tt = sum()</span><br><span class="line">tt.add(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">10</span>)</span><br><span class="line">println tt.val()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//.&amp;方法指针操作符，将方法当作闭包作为参数传递</span></span><br><span class="line"><span class="keyword">def</span> list = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="comment">//常规写法</span></span><br><span class="line">list.each&#123;println it&#125;</span><br><span class="line">String printName(it)&#123; println <span class="string">&quot;自定义显示：$it&quot;</span> &#125;</span><br><span class="line"><span class="comment">//方法指针操作符写法</span></span><br><span class="line">list.each(<span class="built_in">this</span>.&amp;printName)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数闭包</span></span><br><span class="line"><span class="keyword">def</span> sParameterLessClosure = <span class="string">&quot;1 + 2 == $&#123;-&gt; 3&#125;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> sParameterLessClosure == <span class="string">&#x27;1 + 2 == 3&#x27;</span></span><br><span class="line"><span class="comment">//一个参数闭包</span></span><br><span class="line"><span class="keyword">def</span> sOneParamClosure = <span class="string">&quot;1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> sOneParamClosure == <span class="string">&#x27;1 + 2 == 3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//GString使用闭包有延时特性</span></span><br><span class="line"><span class="keyword">def</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> eagerGString = <span class="string">&quot;value == $&#123;number&#125;&quot;</span>  <span class="comment">//number在GString创建后就被替换</span></span><br><span class="line"><span class="keyword">def</span> lazyGString = <span class="string">&quot;value == $&#123; -&gt; number &#125;&quot;</span></span><br><span class="line"><span class="keyword">assert</span> eagerGString == <span class="string">&quot;value == 1&quot;</span></span><br><span class="line"><span class="keyword">assert</span> lazyGString ==  <span class="string">&quot;value == 1&quot;</span></span><br><span class="line">number = <span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> eagerGString == <span class="string">&quot;value == 1&quot;</span> <span class="comment">//eagerGString值不变</span></span><br><span class="line"><span class="keyword">assert</span> lazyGString ==  <span class="string">&quot;value == 2&quot;</span> <span class="comment">//lazyGString已经改为&quot;value == 2&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//GString的与String值相同，hashcode也不同，尽量避免使用GString作map的key</span></span><br><span class="line">key = <span class="string">&quot;key&quot;</span></span><br><span class="line">println <span class="string">&quot;$&#123;key&#125;&quot;</span> == <span class="string">&quot;key&quot;</span> <span class="comment">//true</span></span><br><span class="line">println <span class="string">&quot;$&#123;key&#125;&quot;</span>.hashCode() == <span class="string">&quot;key&quot;</span>.hashCode() <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// *.展开运算符，一个集合使用展开运算符可以得到一个元素为原集合各个元素执行后面指定方法所得值的集合</span></span><br><span class="line">groovylist = [</span><br><span class="line">        <span class="keyword">new</span> LearnGroovy(<span class="attr">name:</span><span class="string">&quot;小明&quot;</span>),</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> LearnGroovy(<span class="attr">name:</span><span class="string">&quot;小红&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> LearnGroovy(<span class="attr">name:</span><span class="string">&quot;小丽&quot;</span>)</span><br><span class="line">]</span><br><span class="line">println groovylist*.name <span class="comment">//[小明, null, 小红, 小丽]</span></span><br><span class="line"><span class="keyword">assert</span> <span class="literal">null</span>*.name == <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/kmyhy/article/details/4200563">参考链接</a></p>
<p><a href="https://blog.csdn.net/yanbober/article/details/49047515">参考链接</a></p>
<p><a href="https://blog.csdn.net/zhaoyanjun6/article/details/70313790">参考链接</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>groovy</tag>
      </tags>
  </entry>
  <entry>
    <title>String理解</title>
    <url>/2020/11/17/java/String/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>jdk8及以前底层用char[]数组实现，jdk9以后改为byte[]。</p>
<p>jdk6及以前，字符串常量池存放在永久代。jdk7及其以后保存在Java堆中。</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>对String字符串重新赋值，拼接，replace指定字符，都不能使用原有value进行赋值。</p>
<h2 id="字符串拼接结果保存"><a href="#字符串拼接结果保存" class="headerlink" title="字符串拼接结果保存"></a>字符串拼接结果保存</h2><ol>
<li>两个常量拼接结果在常量池，原理是编译器优化。</li>
<li>要是拼接表达式存在变量，结果就保存在堆中。底层使用String Builder拼接。</li>
<li>如果拼接结果调用intern()方法，则主动将常量池中还没有的字符串对象存入常量池中，并返回此对象地址。</li>
</ol>
<h2 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h2><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2020/11/17/java/String/image-20201130200723360.png" alt="image-20201130200723360"></p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	创建两对象</span></span><br><span class="line"><span class="comment">	1，堆空间的new 出来的对象</span></span><br><span class="line"><span class="comment">	2，字符串常量池的&quot;a&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//由于常量池已经有&quot;a&quot;,直接返回常量池&quot;a&quot;地址</span></span><br><span class="line">String ss = s.intern();</span><br><span class="line">String s2 =<span class="string">&quot;a&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//jdk6/7/8 : false</span></span><br><span class="line">System.out.println(ss == s2); <span class="comment">//jdk6/7/8 : true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	创建&quot;aa&quot;对象，但常量池中只有字符串&quot;a&quot;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	jdk6</span></span><br><span class="line"><span class="comment">	由于此时常量池中无&quot;aa&quot;，常量池中存入&quot;aa&quot;字符串（相当于复制一份），返回常量池中字符串的引用地址</span></span><br><span class="line"><span class="comment">	所以s3和s4地址不相同</span></span><br><span class="line"><span class="comment">	jdk7/8</span></span><br><span class="line"><span class="comment">	由于此时常量池中无&quot;aa&quot;，所以把s3的对象地址存入常量池(复制的是对象的地址)，返回常量池中对象的地址</span></span><br><span class="line"><span class="comment">	所以s3和s4的地址是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>String 的String Pool 不存在相同的内容变量，是固定大小的HashTable，默认长度1009，当里面String过多时，Hash冲突严重，导致链表会很长，String.itern(用于将字符串放入常量池)性能严重下降。</p>
<h2 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h2><p> -XX: StringTableSize 可设置JVM的StringTable长度。</p>
<ul>
<li>jdk6：StringTable固定大小，长度就是1009。</li>
<li>jdk7：长度默认60013。</li>
<li>jdk8：长度默认60013。1009是设置String Table的最小值。</li>
</ul>
<h2 id="问题！！！"><a href="#问题！！！" class="headerlink" title="问题！！！"></a>问题！！！</h2><h3 id="new-String-“ab”-；new-String-“a”-new-String-“b”-分别创建多少个对象？"><a href="#new-String-“ab”-；new-String-“a”-new-String-“b”-分别创建多少个对象？" class="headerlink" title="new String(“ab”)；new String(“a”) + new String(“b”); 分别创建多少个对象？"></a>new String(“ab”)；new String(“a”) + new String(“b”); 分别创建多少个对象？</h3><h2 id="new-String-“ab”-；"><a href="#new-String-“ab”-；" class="headerlink" title="new String(“ab”)；"></a>new String(“ab”)；</h2><p>两个：</p>
<p>一个是堆中new出来的对象，一个是常量池中的”ab”字符串。</p>
<h2 id="new-String-“a”-new-String-“b”"><a href="#new-String-“a”-new-String-“b”" class="headerlink" title="new String(“a”) + new String(“b”);"></a>new String(“a”) + new String(“b”);</h2><p>六个：</p>
<ol>
<li>StringBulider对象</li>
<li>new String(“a”)堆中new对象</li>
<li>常量池中的”a”字符串</li>
<li>new String(“b”)堆中new对象</li>
<li>常量池中的”b”字符串</li>
<li>StringBuilder的toString()方法返回new String(“ab”).注：调用toString()方法常量池不会生成字符串”ab”</li>
</ol>
<h2 id="扩展String、StringBuilder、StringBuffer区别"><a href="#扩展String、StringBuilder、StringBuffer区别" class="headerlink" title="扩展String、StringBuilder、StringBuffer区别"></a>扩展String、StringBuilder、StringBuffer区别</h2><p><strong>String</strong>底层是用final修饰的char数组，不可改变，（String的大部分情况都是字母，一个字节即可满足，为降低内存占用，<strong>jdk9后改成byte数组</strong>,StringBuilder和StringBuffer也是，并用coder字段修饰编码类型）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//coder字段可选值</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LATIN1 = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UTF16  = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<p><strong>StringBuilder</strong>底层是一个可变的char数组，默认初始化长度为16，构造器有字符串传参时默认长度为字符串长度+16，append操作超过原有长度限制时以下规则扩展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//char数组长度 * 2 + 2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">//扩展后长度还是不满足则直接等于minCapacity（minCapacity = 已使用长度 + append参数的长度）</span></span><br><span class="line">        newCapacity = minCapacity; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(); <span class="comment">//超出最大长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//minCapacity在(Integer.MAX_VALUE - 8, Integer.MAX_VALUE]之间</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">       ? minCapacity : MAX_ARRAY_SIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>StringBuffer使用synchronized修饰方法，线程安全，内部维护一个char[] toStringCache数组缓存最近一次toString()的值，每次修改前都置为null。扩展规则和StringBuilder一致，都是使用AbstractStringBuilder抽象类的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>easypoi导出动态列头excel文件（非注解）</title>
    <url>/2020/11/30/java/easypoi/</url>
    <content><![CDATA[<h2 id="easypoi"><a href="#easypoi" class="headerlink" title="easypoi"></a>easypoi</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>java对excel文件操作的工具类，使用简单，只需简单几个注解即可完成excel的简单导入导出，也可以基于map灵活定义的表头字段（适用于列数不定，动态生成，下面介绍）</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--springboot项目直接引入以下启动依赖也行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.afterturn<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="用于生成excel文件所需数据"><a href="#用于生成excel文件所需数据" class="headerlink" title="用于生成excel文件所需数据"></a>用于生成excel文件所需数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 用于生成excel文件所需数据</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">transformToExcelMap</span><span class="params">(Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    List&lt;ExcelExportEntity&gt; colList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	添加列</span></span><br><span class="line"><span class="comment">    	public ExcelExportEntity(String name, Object key) &#123;</span></span><br><span class="line"><span class="comment">            super.name = name;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        key用于后面数据绑定</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;班级&quot;</span>, <span class="string">&quot;className&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;学号&quot;</span>, <span class="string">&quot;username&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;姓名&quot;</span>, <span class="string">&quot;name&quot;</span>));</span><br><span class="line">    colList.add(<span class="keyword">new</span> ExcelExportEntity(<span class="string">&quot;性别&quot;</span>, <span class="string">&quot;sex&quot;</span>));</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		表格内容</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map&lt;String, Object&gt;&gt;();</span><br><span class="line">    List&lt;ExamCorrectDto&gt; examCorrectDtos = (List&lt;ExamCorrectDto&gt;) params.get(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    examCorrectDtos.forEach(examCorrectDto -&gt; &#123;</span><br><span class="line">        <span class="comment">//每一个valMap就是一行数据，key就是前面定义表头时的key</span></span><br><span class="line">        Map&lt;String, Object&gt; valMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        valMap.put(<span class="string">&quot;className&quot;</span>, examCorrectDto.getClassName());</span><br><span class="line">        valMap.put(<span class="string">&quot;username&quot;</span>, examCorrectDto.getUsername());</span><br><span class="line">        valMap.put(<span class="string">&quot;name&quot;</span>, examCorrectDto.getName());</span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将每行数据添加在表格内容list中</span></span><br><span class="line">        list.add(valMap);</span><br><span class="line">    &#125;);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//标题</span></span><br><span class="line">    String title = <span class="string">&quot;测验名：&quot;</span> + params.get(<span class="string">&quot;examName&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      课程：&quot;</span> + params.get(<span class="string">&quot;courseName&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      日期：&quot;</span> + simpleDateFormat.format(params.get(<span class="string">&quot;startTime&quot;</span>)) +</span><br><span class="line">        <span class="string">&quot;;      时长：&quot;</span> + params.get(<span class="string">&quot;durationTime&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      总题数：&quot;</span> + params.get(<span class="string">&quot;questionNum&quot;</span>) +</span><br><span class="line">        <span class="string">&quot;;      总分：&quot;</span> + params.get(<span class="string">&quot;totalScore&quot;</span>);</span><br><span class="line">    ExportParams exportParams = <span class="keyword">new</span> ExportParams(title, params.get(<span class="string">&quot;examName&quot;</span>).toString(), ExcelType.XSSF);</span><br><span class="line">    <span class="comment">//设置标题高度</span></span><br><span class="line">    exportParams.setTitleHeight((<span class="keyword">short</span>) <span class="number">15</span>);</span><br><span class="line">    <span class="comment">//自定义标题样式（代码在下面）</span></span><br><span class="line">    exportParams.setStyle(ExcelTitleStyleConfig.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**    cn.afterturn.easypoi.entity.vo.NormalExcelConstants </span></span><br><span class="line"><span class="comment"> 	单Sheet导出 EASYPOI_EXCEL_VIEW = &quot;easypoiExcelView&quot;;</span></span><br><span class="line"><span class="comment">    数据列表 DATA_LIST			    = &quot;data&quot;;</span></span><br><span class="line"><span class="comment">    多Sheet 对象 MAP_LIST   		 = &quot;mapList&quot;;</span></span><br><span class="line"><span class="comment"> 	注解对象  CLASS    				= &quot;entity&quot;;</span></span><br><span class="line"><span class="comment">    表格参数 PARAMS   			 	= &quot;params&quot;;</span></span><br><span class="line"><span class="comment">    下载文件名称 FILE_NAME 		   = &quot;fileName&quot;;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">    res.put(NormalExcelConstants.CLASS, ExcelExportEntity.class);</span><br><span class="line">    res.put(NormalExcelConstants.DATA_LIST, list);</span><br><span class="line">    res.put(NormalExcelConstants.PARAMS, exportParams);</span><br><span class="line">    res.put(NormalExcelConstants.MAP_LIST, colList);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/11/29</span></span><br><span class="line"><span class="comment"> * 设置样式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelTitleStyleConfig</span> <span class="keyword">extends</span> <span class="title">ExcelExportStylerDefaultImpl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExcelTitleStyleConfig</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(workbook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getHeaderStyle</span><span class="params">(<span class="keyword">short</span> color)</span> </span>&#123;</span><br><span class="line">        CellStyle headStyle = <span class="keyword">super</span>.getHeaderStyle(color);</span><br><span class="line">        headStyle.setWrapText(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置前景色填充颜色</span></span><br><span class="line">        headStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex());</span><br><span class="line">        <span class="comment">//设置填充模式！！！注，必要设置，否则ForegroundColor设置无效</span></span><br><span class="line">        headStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        <span class="keyword">return</span> headStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 生成多sheet文件</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> paramList 参数列表，每个Map表示一个Tab，即Sheet</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exportToExcel</span><span class="params">(List&lt;Map&lt;String, Object&gt;&gt; paramList)</span> </span>&#123;</span><br><span class="line">    Workbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line">    ExcelExportService server = <span class="keyword">new</span> ExcelExportService();</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; sheetList = <span class="keyword">new</span> ArrayList(paramList.size());</span><br><span class="line">    <span class="comment">//将信息组装成相应信息，一个map就是一个sheet</span></span><br><span class="line">    paramList.forEach(param -&gt; sheetList.add(transformToExcelMap(param)));</span><br><span class="line">    </span><br><span class="line">    sheetList.forEach(sheet -&gt; &#123;</span><br><span class="line">        server.createSheetForMap(</span><br><span class="line">            workbook,</span><br><span class="line">            (ExportParams) sheet.get(NormalExcelConstants.PARAMS),</span><br><span class="line">            (List&lt;ExcelExportEntity&gt;) sheet.get(NormalExcelConstants.MAP_LIST),</span><br><span class="line">            (List&lt;Map&lt;String, Object&gt;&gt;) sheet.get(NormalExcelConstants.DATA_LIST));</span><br><span class="line">    &#125;);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;文件名.xlsx&quot;</span>);</span><br><span class="line">        <span class="comment">//写出文件</span></span><br><span class="line">        workbook.write(fos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (workbook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                workbook.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="/2020/11/30/java/easypoi/image-20201130170342374.png" alt="image-20201130170342374"></p>
<h3 id="注解形式直接看官方文档即可"><a href="#注解形式直接看官方文档即可" class="headerlink" title="注解形式直接看官方文档即可"></a>注解形式直接看官方文档即可</h3><p><a href="http://easypoi.mydoc.io/">参考文档1</a></p>
<p><a href="http://doc.wupaas.com/docs/easypoi/easypoi-1c0u6ksp2r091">参考文档2</a></p>
<p>注：也可使用<a href="https://github.com/alibaba/easyexcel">easyexcel</a> （阿里巴巴开源的一个excel处理框架，以使用简单、节省内存著称）。</p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Javadoc简单使用</title>
    <url>/2020/11/29/java/javadoc/</url>
    <content><![CDATA[<h2 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h2><p>Java 支持三种注释方式。前两种分别是 <strong>//</strong> 和 <strong>/* */<strong>，第三种被称作说明注释，它以 **/\</strong></strong> 开始，以 ***/**结束。</p>
<p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p>
<p>说明注释，使你更加方便的记录你的程序信息。</p>
<h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><ul>
<li>第一段：概要描述，通常用一句或者一段话简要描述该类的作用，以英文句号作为结束。</li>
<li>第二段：详细描述，通常用一段或者多段话来详细描述该类的作用，一般每段话都以英文句号作为结束。</li>
<li>第三段：文档标注，用于标注作者、创建时间、参阅类等信息。</li>
</ul>
<p><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">参考地址</a></p>
<h2 id="javadoc-标签"><a href="#javadoc-标签" class="headerlink" title="javadoc 标签"></a>javadoc 标签</h2><table>
<thead>
<tr>
<th align="left"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">@author</td>
<td align="center">标识一个类的作者</td>
<td align="center">@author description</td>
</tr>
<tr>
<td align="left">@deprecated</td>
<td align="center">指名一个过期的类或成员</td>
<td align="center">@deprecated description</td>
</tr>
<tr>
<td align="left">{@docRoot}</td>
<td align="center">指明当前文档根目录的路径</td>
<td align="center">Directory Path</td>
</tr>
<tr>
<td align="left">@exception</td>
<td align="center">标志一个类抛出的异常</td>
<td align="center">@exception exception-name explanation</td>
</tr>
<tr>
<td align="left">{@inheritDoc}</td>
<td align="center">从直接父类继承的注释</td>
<td align="center">Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td align="left">{@link}</td>
<td align="center">用于快速链接到相关代码</td>
<td align="center">{@link name text}</td>
</tr>
<tr>
<td align="left">{@linkplain}</td>
<td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td align="center">Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td align="left">@param</td>
<td align="center">说明一个方法的参数</td>
<td align="center">@param parameter-name explanation</td>
</tr>
<tr>
<td align="left">@return</td>
<td align="center">说明返回值类型</td>
<td align="center">@return explanation</td>
</tr>
<tr>
<td align="left">@see</td>
<td align="center">指定一个到另一个主题的链接</td>
<td align="center">@see anchor</td>
</tr>
<tr>
<td align="left">@serial</td>
<td align="center">说明一个序列化属性</td>
<td align="center">@serial description</td>
</tr>
<tr>
<td align="left">@serialData</td>
<td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td align="center">@serialData description</td>
</tr>
<tr>
<td align="left">@serialField</td>
<td align="center">说明一个ObjectStreamField组件</td>
<td align="center">@serialField name type description</td>
</tr>
<tr>
<td align="left">@since</td>
<td align="center">标记当引入一个特定的变化时</td>
<td align="center">@since release</td>
</tr>
<tr>
<td align="left">@throws</td>
<td align="center">和 @exception标签一样.</td>
<td align="center">The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td align="left">{@value}</td>
<td align="center">显示常量的值，该常量必须是static属性。</td>
<td align="center">Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td align="left">@version</td>
<td align="center">指定类的版本</td>
<td align="center">@version info</td>
</tr>
<tr>
<td align="left">@code</td>
<td align="center">将文本标记为code</td>
<td align="center">{@code text} 会被解析成<code>&lt;code&gt; text &lt;/code&gt;</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础</title>
    <url>/2020/12/22/java/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="浮点型范围"><a href="#浮点型范围" class="headerlink" title="浮点型范围"></a>浮点型范围</h2><table>
<thead>
<tr>
<th>类型</th>
<th>符号位</th>
<th>指数位</th>
<th>尾数位</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>1bit</td>
<td>8bits</td>
<td>23bits</td>
</tr>
<tr>
<td>double</td>
<td>1bit</td>
<td>11bits</td>
<td>52bits</td>
</tr>
</tbody></table>
<p>float因为指数为 0 和 255 代表特殊值。实际浮点数的指数表示范围是1-254，减去偏阶127后得到实际表示范围：-126~+127。</p>
<p><img src="/2020/12/22/java/java%E5%9F%BA%E7%A1%80/bVbiye8" alt="å¾çæè¿°"></p>
<h3 id="精度丢失"><a href="#精度丢失" class="headerlink" title="精度丢失"></a>精度丢失</h3><p>由于我们代码在程序里写的十进制小数，而计算机内部只能用二进制的小数, 所以无法精确的表达。对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n）。所有的十进制小数都是这些一点一点的拼凑出来的一个近似的数值, 如1.2（10进制） ≈1.00110011（2进制） = 1 + 1/8+1/16+1/128+1/256 = 1 + 0.19921875。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>底层是Object[] elementData数组，默认大小DEFAULT_CAPACITY=10，使用空参构造时只是将默认的空数组赋值给elementData。在添加数据时先执行ensureCapacityInternal(size+1)方法判断容量是否够，先判断elementData是否等于默认空数组，若是，则容量初始化为Math.max(DEFAULT_CAPACITY【默认大小10】, minCapacity【当前所需容量最小大小】);否则若minCapacity大于当前容量，则调用grow方法以1.5倍扩容。</p>
<p><a href="https://www.cnblogs.com/zhangyinhua/p/7687377.html">链接</a></p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>底层是使用静态内部类Node实现的双向链表。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>底层使用数组+链表/红黑二叉树。桶数组默认长度DEFAULT_INITIAL_CAPACITY是16，负载因子loadFactor默认是0.75，数组长度大于阈值会以两倍形式增长。添加数据哈希冲突时采用尾插法（注：jdk1.7及以前采用头插法，在多线程下可能导致死循环）。当链表的长度大于8，同时桶数组长度大于等于64时，将链表转为红黑二叉树。当桶中元素小于等于6时转为链表。</p>
<h3 id="哈希值计算"><a href="#哈希值计算" class="headerlink" title="哈希值计算"></a>哈希值计算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">//用高16位参与异或运算，为了降低 hash 冲突的概率。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将(tab.length - 1) 与 hash值进行&amp;运算定位桶数组索引</span></span><br><span class="line"><span class="comment">// 注：对于2的n次方的求余，与2的n次方-1进行与运算结果相等，位运算效率更快</span></span><br><span class="line"><span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash; </span><br></pre></td></tr></table></figure>



<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>底层直接使用HashMap的key存值。map的value统一存入一个不可变的object对象。</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>继承HashMap，每个结点在其基础上多了before, after。保证元素的有序性。还可以通过设置accessOrder为true将最近获取的元素移动至链表尾部。可用作简单缓存。也可通过继承自定义removeEldestEntry（）方法实现LRU算法实现新增数据时移除最久未使用元素。</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>线程安全。底层使用数组+链表（头插法）。使用synchronized修饰方法。默认容量为11，rehash方法以2倍加1形式扩容。key/value也无法为null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hash值直接使用key的hash值</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">//&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</span></span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/ns_code/article/details/36191279">参考链接</a></p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>底层使用红黑二叉树。初始化时可指定排序规则。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>key/value都不允许为空。</strong></p>
<p>1.5~1.7前使用<strong>分段锁</strong>，把Map分成了N个Segment（相当于把Map拆分成N个小的HashTable），put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中，操作不同Segment不会锁冲突。<strong>扩容时不会对Segmengt数组增大（默认长度16），只会增加Segmengt 后面的链表容量的大小。即对每个Segmengt 的元素进行的ReHash操作。</strong></p>
<p>1.8后用cas+synchronized。</p>
<p><a href="https://blog.csdn.net/zzu_seu/article/details/106698150">图解扩容</a></p>
<p><a href="%5Bhttps://blog.csdn.net/jjc120074203/article/details/78625433?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161295910616780264080489%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161295910616780264080489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-4-78625433.pc_search_result_before_js&utm_term=ConcurrentHashMap&spm=1018.2226.3001.4187%5D(https://blog.csdn.net/jjc120074203/article/details/78625433?ops_request_misc=%7B%22request_id%22:%22161295910616780264080489%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=161295910616780264080489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-4-78625433.pc_search_result_before_js&utm_term=ConcurrentHashMap&spm=1018.2226.3001.4187)">参考链接</a></p>
<p><a href="https://blog.csdn.net/sihai12345/article/details/79383766?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161295910616780264080489%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161295910616780264080489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-5-79383766.pc_search_result_before_js&utm_term=ConcurrentHashMap&spm=1018.2226.3001.4187">参考链接</a></p>
<h3 id="sizeCtl-定义理解"><a href="#sizeCtl-定义理解" class="headerlink" title="sizeCtl 定义理解"></a>sizeCtl 定义理解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">  * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">  * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">  * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">  * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">  * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line">源码注释翻译</span><br><span class="line">sizeCtl ：默认为<span class="number">0</span>，用来控制table的初始化和扩容操作</span><br><span class="line">-<span class="number">1</span> 代表table正在初始化</span><br><span class="line">-N 表示有N-<span class="number">1</span>个线程正在进行扩容操作（注：这里理解有问题）</span><br><span class="line">其余情况：</span><br><span class="line"><span class="number">1</span>、如果table未初始化，表示table需要初始化的大小。</span><br><span class="line"><span class="number">2</span>、如果table初始化完成，表示table的容量，默认是table大小的<span class="number">0.75</span>倍</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//ConcurrentHashMap中有个大写的sizeCtl</span></span><br><span class="line"><span class="comment">//这个大写的sizectl存的是sizeCtl的偏移量，在sizeCtl进行cas使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SIZECTL;</span><br><span class="line">SIZECTL = U.objectFieldOffset</span><br><span class="line">              (k.getDeclaredField(<span class="string">&quot;sizeCtl&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>这里-N的定义是有问题的，应该取-N对应的二进制的低16位数值为M，此时有M-1个线程进行扩容。</strong></p>
<p><a href="https://blog.csdn.net/Unknownfuture/article/details/105350537">参考链接</a></p>
<h2 id="集合相关参考链接"><a href="#集合相关参考链接" class="headerlink" title="集合相关参考链接"></a>集合相关参考链接</h2><p><a href="https://blog.csdn.net/woshimaxiao1/category_8298930.html">链接</a></p>
<p><a href="https://blog.csdn.net/v123411739/category_7410582.html">链接</a></p>
<h2 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h2><ul>
<li>排序的是引用类型时</li>
</ul>
<p>​    使用的是归并排序（Collections.sort()最终也是调用这方法）。</p>
<ul>
<li>排序的是基本数据类型时</li>
</ul>
<p>​    长度小于INSERTION_SORT_THRESHOLD（47）：使用插入排序</p>
<p>​    长度小于QUICKSORT_THRESHOLD（286）: 使用快速排序</p>
<p>​    长度大于286后会先统计其<strong>降序子数组数</strong>，计数count等于MAX_RUN_COUNT（67）被判断为这个数组不具备    结构（数据时而升时而降），使用快速排序，否则进入归并排序。</p>
<h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><p>本质上是一个继承Enum抽象类的final类</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/71333103">链接</a></p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p><a href="https://blog.csdn.net/javazejian/article/details/70768369">链接</a></p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><p><a href="https://www.cnblogs.com/wuqinglong/p/9456193.html#1java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">泛型擦除与多态冲突</a></p>
<p><a href="https://blog.csdn.net/hao_yan_bing/article/details/89447792">桥方法</a></p>
<h2 id="Java多态实现原理"><a href="#Java多态实现原理" class="headerlink" title="Java多态实现原理"></a>Java多态实现原理</h2><p><a href="https://blog.csdn.net/Faker_Wang/article/details/81170838">学习链接</a></p>
<p><a href="https://blog.csdn.net/bluetjs/article/details/52608833?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-0&spm=1001.2101.3001.4242">学习链接</a></p>
<h2 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h2><p>本质上是一个继承Annotation接口的接口</p>
<p><img src="/2020/12/22/java/java%E5%9F%BA%E7%A1%80/Java%E6%B3%A8%E8%A7%A3.jpg" alt="Java注解"></p>
<p><a href="https://www.cnblogs.com/yangming1996/p/9295168.html">学习链接</a></p>
<p><a href="https://blog.csdn.net/yuzongtao/article/details/83306182">学习链接</a></p>
<p><a href="https://www.zhihu.com/question/24401191">学习链接</a></p>
<h2 id="排查Java项目线上运行慢问题"><a href="#排查Java项目线上运行慢问题" class="headerlink" title="排查Java项目线上运行慢问题"></a>排查Java项目线上运行慢问题</h2><ol>
<li>使用top查看cpu占有率。</li>
<li>使用top -hp pid或ps -mp pid -o THREAD,tid,time查看对应进程的线程使用情况。</li>
<li>使用jstat -gcutil pid 【打印间隔时间（默认毫秒）】 【 打印次数】打印Jvm运行时数据区情况。</li>
<li>用jstack pid打印该Java进程的堆栈信息。定位对应代码。</li>
</ol>
<p><a href="https://www.jb51.net/article/194193.htm">参考链接</a></p>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/104390612?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161961103816780274193565%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161961103816780274193565&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-7-104390612.first_rank_v2_pc_rank_v29&utm_term=Spring+Cloud+%E9%9D%A2%E8%AF%95%E9%A2%98">Java基础宝藏链接</a></p>
<h2 id="响应式编程（Reactive-Programming）"><a href="#响应式编程（Reactive-Programming）" class="headerlink" title="响应式编程（Reactive Programming）"></a>响应式编程（Reactive Programming）</h2><p>响应式编程是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。</p>
<p><img src="/2020/12/22/java/java%E5%9F%BA%E7%A1%80/v2-5be72cbcf804dc2953f1198a1365ed9d_720w.jpg" alt="v2-5be72cbcf804dc2953f1198a1365ed9d_720w"></p>
<p><a href="https://cloud.tencent.com/developer/article/1073888">参考链接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/92460075">参考链接</a></p>
<h3 id="WebFlux框架"><a href="#WebFlux框架" class="headerlink" title="WebFlux框架"></a>WebFlux框架</h3><p><img src="/2020/12/22/java/java%E5%9F%BA%E7%A1%80/640.jpg" alt="640"></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247486076&idx=2&sn=f3146b07c0dfcb05619df4b77e40eefe&chksm=ebd74b7ddca0c26bd2eb60e4f5c87014f3ce4f99501a58e31ea8e684b825bb3912421d2e25c1&token=1879076182&lang=zh_CN#rd">参考链接</a></p>
<p><a href="https://www.cnblogs.com/niechen/p/9303451.html">参考链接</a></p>
<h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><p>JMX(Java Management Extensions，Java管理扩展)是一个为应用程序植入管理功能的框架。JMX是一套标准的代理和服务，实际上，用户可以在任何Java应用程序中使用这些代理和服务实现管理。</p>
<p><a href="https://www.cnblogs.com/dongguacai/p/5900507.html">参考链接</a></p>
<h2 id="Java总结"><a href="#Java总结" class="headerlink" title="Java总结"></a>Java总结</h2><p><a href="https://blog.csdn.net/guorui_java/article/details/112391105">Java知识体系总结</a></p>
<p><a href="https://thinkwon.blog.csdn.net/article/details/104390612">面试参考</a></p>
<h2 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h2><p><a href="https://www.jianshu.com/p/09f73af48a98">以JDBC为例谈双亲委派模型的破坏</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>maven简单介绍</title>
    <url>/2020/10/15/java/maven%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p>
</li>
<li><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p>
</li>
<li><p>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p>
<p> 注：摘自[菜鸟教程]:<a href="https://www.runoob.com/maven/maven-tutorial.html">https://www.runoob.com/maven/maven-tutorial.html</a></p>
</li>
</ol>
<h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><h4 id="减少冗余"><a href="#减少冗余" class="headerlink" title="减少冗余"></a>减少冗余</h4><p>在项目开发中，我们常常需要引入第三方的框架和工具包来提高开发速度，以前要使用这些 jar 包就是复制粘贴到 WEB-INF/lib 目录下。当你建了多个项目时有项目都需要引入同一jar包，需要将 jar 包重复复制到 lib 目录下，从而造成工作区中存在大量重复的文件，使工程显得很臃肿。 </p>
<p>使用maven后会在本地建一个统一的仓库，用于存放所有jar包、源文件等，当项目需要引入某个jar包时，只需复制其依赖坐标至pom文件中，maven就会自动帮我们导入到项目中。每个jar包本地只保存一份，不仅极大的节约了存储空间，让项目更轻巧，更避免了重复文件太多而造成的混乱。</p>
<h4 id="解决jar包依赖"><a href="#解决jar包依赖" class="headerlink" title="解决jar包依赖"></a>解决jar包依赖</h4><p>jar包往往不是孤立存在的，很多 jar 包都需要在其他 jar 包的支持下才能够正常工作，我们称之为 jar 包之间的依赖关系。Maven 就可以替我们自动的将当前 jar 包所依赖的其他所有 jar 包全部导入进来， 无需人工参与，节约了我们大量的时间和精力。</p>
<h4 id="统一下载"><a href="#统一下载" class="headerlink" title="统一下载"></a>统一下载</h4><p>我们通常在查找第三方jar包，选择版本上花费很多时间，maven提供个中央仓库，只需你依赖坐标填对，就会自动去 [中央仓库]:<a href="https://mvnrepository.com/">https://mvnrepository.com/</a>  下载。</p>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本，打包项目等。</p>
<h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven有三套相互独立的生命周期，分别是 Clean、Default 和 Site。每个生命周期包含一些阶段，阶段是有顺序的，后面的阶段依赖于前面的阶段。不管用户要求执行的命令对应生命周期中的哪一个阶段，Maven都会自动从当前生命周期的最初位置开始执行，直到完成用户下达的指令。</p>
<ul>
<li><p>Clean 生命周期：清理项目，包含三个 phase（阶段） ：</p>
<ul>
<li><p>pre-clean：执行清理前需要完成的工作。</p>
</li>
<li><p>clean：清理上一次构建生成的文件。</p>
</li>
<li><p>post-clean：执行清理后需要完成的工作。</p>
</li>
</ul>
</li>
<li><p>Default 生命周期：构建项目，重要的 phase 如下：</p>
<ul>
<li>validate：验证工程是否正确，所有需要的资源是否可用。</li>
<li>compile：编译项目的源代码。</li>
<li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li>
<li>package：把已编译的代码打包成可发布的格式，比如 jar、war 等。</li>
<li>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</li>
<li>verify：运行所有检查，验证包是否有效且达到质量标准。</li>
<li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。</li>
<li>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。</li>
</ul>
</li>
<li><p>Site 生命周期：建立和发布项目站点，phase 如下：</p>
<ul>
<li>pre-site：生成项目站点之前需要完成的工作。</li>
<li>site：生成项目站点文档。</li>
<li>post-site：生成项目站点之后需要完成的工作。</li>
<li>site-deploy：将项目站点发布到服务器。</li>
</ul>
</li>
</ul>
<h2 id="pom文件常用标签介绍"><a href="#pom文件常用标签介绍" class="headerlink" title="pom文件常用标签介绍"></a>pom文件常用标签介绍</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的全球唯一标识符(项目名) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。默认值是../pom.xml。</span></span><br><span class="line"><span class="comment">		Maven首先在构建当前项目的地方寻找父项目的pom，</span></span><br><span class="line"><span class="comment">		其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目.(公司或组织的域名倒序) --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.czm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。(当前项目的模块名称) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>back<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--当前模块的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--项目打包格式：pom、jar、war</span></span><br><span class="line"><span class="comment">	父级项目的packing都为pom，packing默认是jar类型，如果不作配置，maven会将该项目打成jar包。作为父级项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">&lt;!--统一管理所依赖 jar 包的版本 对同一个框架的一组 jar 包最好使用相同的版本。</span></span><br><span class="line"><span class="comment">	为了方便升级框架，可以将 jar 包的版本信息统一提取出来  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR8<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.12<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--项目描述 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>just a demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">     <span class="comment">&lt;!--jar包依赖坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用上面统一声明的版本--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">			依赖的范围 ：compile、test、provided </span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。</span></span><br><span class="line"><span class="comment">			即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">          <span class="comment">&lt;!--描述与项目关联的文件是什么和在哪里--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span> <span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span> </span><br><span class="line">              <span class="comment">&lt;!-- true/false，表示为这个resource，filter是否激活--&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!--定义resource文件所在的文件夹，默认为$&#123;basedir&#125;/src/main/resources--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span> <span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!--  指定哪些文件将被匹配，以*作为通配符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>configuration.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">               <span class="comment">&lt;!-- 指定哪些文件将被忽略--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 定义和resource类似，只不过在test时使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">        ...  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>  </span><br><span class="line"> 	<span class="comment">&lt;!--指定使用的插件--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="父项目pom常用坐标"><a href="#父项目pom常用坐标" class="headerlink" title="父项目pom常用坐标"></a>父项目pom常用坐标</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!--引入springboot开始依赖--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明子模块，指定模块工程的相对路径即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>model1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>model2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--统一声明--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-boot-maven-plugin</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-maven-plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意使用import标签时，不再使用&lt;parent&gt;标签</span></span><br><span class="line"><span class="comment">			表示将父项目的dependencyManagement拿到本POM中，不再继承parent</span></span><br><span class="line"><span class="comment">			type必须是pom--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--与dependencyManagement类似，只声明--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-maven-plugin&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--添加配置跳过测试类构建--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Maven中的SNAPSHOT版本和RELEASE版本"><a href="#Maven中的SNAPSHOT版本和RELEASE版本" class="headerlink" title="Maven中的SNAPSHOT版本和RELEASE版本"></a>Maven中的SNAPSHOT版本和RELEASE版本</h2><p>在一个Nexus仓库中，一个仓库一般分为<strong>Release</strong>（public）仓和<strong>SNAPSHOT</strong>仓，前者存放<strong>发布版本</strong>（正式版），后者存放快照版本。若pom.xml中指定版本带有”-SNAPSHOT”后缀，则打包出来的就是快照版。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>快照版本和正式版本的主要区别在于，本地获取这些依赖的机制有所不同。假设你依赖一个库的<strong>正式版本</strong>，构建的时候构建工具会先在本次仓库中查找是否已经有了这个依赖库，如果没有的话才会去远程仓库中去拉取。（若远程仓库已经更新新的软件包{如只修改一点代码，没更新版本号}，则本地不会更新至最新版）。</p>
<p><strong>快照版</strong>不管本地是否已有此jar包，都会去远程仓库查看是否有最新版发布。为充分利用本地缓存机制，采用四种请求策略，分别是：</p>
<ol>
<li>always是每次都去远程仓库查看是否有更新。</li>
<li>daily是只在第一次的时候查看是否有更新，当天的其它时候则不会查看。</li>
<li>interval允许设置一个分钟为单位的间隔时间，在这个间隔时间内只会去远程仓库中查找一次。</li>
<li>never是不会去远程仓库中查找（这种就和正式版本的行为一样了）。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- maven仓库配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>仓库唯一标识<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>仓库名<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>仓库路径<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置快照查询策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>interval:XX<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span> <span class="comment">&lt;!--XX是间隔分钟数,daily是默认值--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做:</span></span><br><span class="line"><span class="comment">                ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.huangbowen.net/blog/2016/01/29/understand-official-version-and-snapshot-version-in-maven/">参考链接</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Jwt生产校验token</title>
    <url>/2020/10/21/java/jwt%E7%94%9F%E6%88%90%E6%A0%A1%E9%AA%8Ctoken/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    <strong>Jwt</strong>（JSON Web Token）是一种基于RFC 7519标准定义的一种可以安全传输的小巧和自包含的JSON对象。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token计为紧凑且安全,也可直接被用于认证，也可被加密。允许我们在用户和服务器之间传递安全可靠的信息。<strong>特别适用于分布式站点的单点登录</strong>(SingleSignOn，SSO)。支持移动平台（cookie不支持）。JWT可以使用HMAC算法对secret进行加密或者使用RSA的公钥私钥对其进行签名。</p>
<h2 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h2><ul>
<li><p><strong>Header 头部</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#令牌的类型（即JWT）和使用的签名算法组成</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Payload 负载</strong> </p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由预定义（Registered） 公有（public） 私有（private）三类属性组成</span></span><br><span class="line"><span class="comment">#Registered，由官方预定，非必需</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    iss (issuer)：签发人</span><br><span class="line"></span><br><span class="line">    sub (subject)：主题</span><br><span class="line"></span><br><span class="line">    aud (audience)：受众</span><br><span class="line"></span><br><span class="line">    exp (expiration time)：过期时间</span><br><span class="line"></span><br><span class="line">    nbf (Not Before)：生效时间，在此之前是无效的</span><br><span class="line"></span><br><span class="line">    iat (Issued At)：签发时间</span><br><span class="line"></span><br><span class="line">    jti (JWT ID)：编号</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#public: 在使用 JWT 时可以额外定义的载荷</span></span><br><span class="line"><span class="comment">#private:在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>Signature 签名/签证</strong></p>
<p>  主要是把头部的base64UrlEncode与负载的base64UrlEncode拼接起来，再用HMACSHA256进行加盐<code>secret</code>组合加密，最终得到的结果作为签名部分。</p>
</li>
</ul>
<h3 id="JWT示例"><a href="#JWT示例" class="headerlink" title="JWT示例"></a>JWT示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiItMSIsInJvbGVJZCI6LTEsInVzZXJJZCI6MSwiaWF0IjoxNjAzMjc1OTE5LCJleHAiOjE2MDMzNjIzMTl9.KVJTpGYMX8IOBFjdNQvmGAsDRQ3J7_2McajtI2WYlss</span><br></pre></td></tr></table></figure>



<h2 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Jwt工具类代码"><a href="#Jwt工具类代码" class="headerlink" title="Jwt工具类代码"></a>Jwt工具类代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/20 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间，一天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long EXPIRED_TIME = <span class="number">24</span> * <span class="number">3600</span> * <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String KEY = <span class="string">&quot;密钥&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">(String userName, Long userId)</span></span>&#123;</span><br><span class="line">        String token = Jwts</span><br><span class="line">                .builder()</span><br><span class="line">                .setSubject(String.valueOf(roleId)) <span class="comment">//设置这个JWT的主体，即它的所有人</span></span><br><span class="line">                .claim(<span class="string">&quot;userName&quot;</span>, userName)</span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date()) <span class="comment">//jwt的签发时间</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(System.currentTimeMillis()+EXPIRED_TIME))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, KEY) <span class="comment">//设置签名使用的签名算法和签名使用的秘钥</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUserName</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Claims claims = Jwts.parser()  //得到DefaultJwtParser</span></span><br><span class="line"><span class="comment">//                .setSigningKey(KEY)         //设置签名的秘钥</span></span><br><span class="line"><span class="comment">//                .parseClaimsJws(jwt).getBody();//设置需要解析的jwt</span></span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody().get(<span class="string">&quot;userName&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getUserId</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        Claims body = Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> body.get(<span class="string">&quot;userId&quot;</span>,Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExpiration</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(KEY).parseClaimsJws(token).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims.getExpiration().before(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger简单入门</title>
    <url>/2020/10/16/java/swagger/</url>
    <content><![CDATA[<h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a><strong>前后端分离</strong></h2><ul>
<li>前端 -&gt; 前端控制层、视图层</li>
<li>后端 -&gt; 后端控制层、服务层、数据访问层</li>
<li>前后端通过API进行交互</li>
<li>前后端相对独立且松耦合</li>
</ul>
<h2 id="产生的问题"><a href="#产生的问题" class="headerlink" title="产生的问题"></a><strong>产生的问题</strong></h2><ul>
<li>前后端集成，前端或者后端无法做到“及时协商，尽早解决”，最终导致问题集中爆发</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><ul>
<li>首先定义schema [ 计划的提纲 ]，并实时跟踪最新的API，降低集成风险</li>
</ul>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a><strong>Swagger</strong></h2><ul>
<li>号称世界上最流行的API框架</li>
<li>Restful Api 文档在线自动生成器 =&gt; <strong>API 文档 与API 定义同步更新</strong></li>
<li>直接运行，在线测试API</li>
<li>支持多种语言 （如：Java，PHP等）</li>
<li>官网：<a href="https://swagger.io/">https://swagger.io/</a></li>
</ul>
<h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><p>jdk 1.8 +</p>
<h3 id="方式一-使用官方依赖"><a href="#方式一-使用官方依赖" class="headerlink" title="方式一:使用官方依赖"></a>方式一:使用官方依赖</h3><h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编写一个配置类-SwaggerConfig来配置-Swagger"><a href="#编写一个配置类-SwaggerConfig来配置-Swagger" class="headerlink" title="编写一个配置类-SwaggerConfig来配置 Swagger"></a>编写一个配置类-SwaggerConfig来配置 Swagger</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration &#x2F;&#x2F;配置类</span><br><span class="line">@EnableSwagger2&#x2F;&#x2F; 开启Swagger2的自动配置</span><br><span class="line">public class SwaggerConfig &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问测试-：http-localhost-8080-swagger-ui-html-，可以看到swagger的界面；"><a href="#访问测试-：http-localhost-8080-swagger-ui-html-，可以看到swagger的界面；" class="headerlink" title="访问测试 ：http://localhost:8080/swagger-ui.html ，可以看到swagger的界面；"></a>访问测试 ：<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，可以看到swagger的界面；</h4><p><img src="/2020/10/16/java/swagger/image-20201016202312084.png" alt="image-20201016202312084"></p>
<h4 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.swagger.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringBootConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Profiles;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.VendorExtension;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/10/16 16:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">// 开启Swagger2的自动配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(ApiInfo apiInfo, Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置要显示swagger的环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断当前是否处于该环境，环境配置：spring.profiles.active=dev</span></span><br><span class="line">        <span class="comment">// 通过 enable() 接收此参数判断是否要显示</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo)</span><br><span class="line">                .groupName(<span class="string">&quot;czm&quot;</span>) <span class="comment">//配置API分组名</span></span><br><span class="line">                .enable(flag)<span class="comment">//配置是否启用Swagger，如果是false，在浏览器将无法访问</span></span><br><span class="line">                .select()<span class="comment">// 通过.select()方法，去配置扫描接口,RequestHandlerSelectors配置如何扫描接口</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  // 扫描所有，项目中的所有接口都会被扫描到</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.any()</span></span><br><span class="line"><span class="comment">                 *  // 不扫描接口</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.none()</span></span><br><span class="line"><span class="comment">                 *  // 通过方法上的注解扫描，如withMethodAnnotation(GetMapping.class)只扫描get请求</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.withMethodAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span></span><br><span class="line"><span class="comment">                 *  // 通过类上的注解扫描，如.withClassAnnotation(Controller.class)只扫描有controller注解的类中的接口</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.withClassAnnotation(final Class&lt;? extends Annotation&gt; annotation)</span></span><br><span class="line"><span class="comment">                 *  RequestHandlerSelectors.basePackage(final String basePackage) // 根据包路径扫描接口</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.czm.swagger.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// 配置如何通过path过滤,即这里只扫描请求以/czm开头的接口</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/czm/**&quot;</span>))</span><br><span class="line">                <span class="comment">/***其他参数</span></span><br><span class="line"><span class="comment">                 * PathSelectors.any() // 任何请求都扫描</span></span><br><span class="line"><span class="comment">                 * PathSelectors.none() // 任何请求都不扫描</span></span><br><span class="line"><span class="comment">                 * PathSelectors.regex(final String pathRegex) // 通过正则表达式控制</span></span><br><span class="line"><span class="comment">                 * PathSelectors.ant(final String antPattern) // 通过ant()控制</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//配置文档信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         *    Contact contact = new Contact(&quot;联系人名字&quot;, &quot;http://xxx.xxx.com/联系人访问链接&quot;, &quot;联系人邮箱&quot;);</span></span><br><span class="line"><span class="comment">         *    return new ApiInfo(</span></span><br><span class="line"><span class="comment">         *            &quot;Swagger学习&quot;, // 标题</span></span><br><span class="line"><span class="comment">         *            &quot;学习演示如何配置Swagger&quot;, // 描述</span></span><br><span class="line"><span class="comment">         *            &quot;v1.0&quot;, // 版本</span></span><br><span class="line"><span class="comment">         *            &quot;http://terms.service.url/组织链接&quot;, // 组织链接</span></span><br><span class="line"><span class="comment">         *            contact, // 联系人信息</span></span><br><span class="line"><span class="comment">         *            &quot;Apach 2.0 许可&quot;, // 许可</span></span><br><span class="line"><span class="comment">         *            &quot;许可链接&quot;, // 许可连接</span></span><br><span class="line"><span class="comment">         *            new ArrayList&lt;&gt;()// 扩展</span></span><br><span class="line"><span class="comment">         *   );</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;czm&quot;</span>, <span class="string">&quot;baidu.com&quot;</span>, <span class="string">&quot;1233@qq.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(<span class="string">&quot;swagger的测试API&quot;</span>, <span class="string">&quot;Api Documentation的描述&quot;</span>, <span class="string">&quot;1.0版&quot;</span>, <span class="string">&quot;urn:tos&quot;</span>,</span><br><span class="line">                contact, <span class="string">&quot;Apache 2.0&quot;</span>, <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>, <span class="keyword">new</span> ArrayList&lt;VendorExtension&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 其他多个API组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h4><p>1、新建一个实体类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体类&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;用户账号&quot;)</span><br><span class="line">    private String account;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;用户密码&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public User(String account, String password) &#123;</span><br><span class="line">        this.account &#x3D; account;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAccount() &#123;</span><br><span class="line">        return account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAccount(String account) &#123;</span><br><span class="line">        this.account &#x3D; account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、只要这个实体在<strong>请求接口</strong>的返回值上（即使是泛型），都能映射到实体项中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;getUser&quot;)</span><br><span class="line">public User getUser()&#123;</span><br><span class="line">   return new User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/16/java/swagger/image-20201016210951882.png" alt="image-20201016210951882"></p>
<p>注：并不是因为@ApiModel这个注解让实体显示在这里了，而是只要出现在接口方法的返回值上的实体都会显示在这里，而@ApiModel和@ApiModelProperty这两个注解只是为实体添加注释的。</p>
<p>@ApiModel为类添加注释</p>
<p>@ApiModelProperty为类属性添加注释</p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th>简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Api(tags = “xxx模块说明”)</td>
<td>作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(“xxx接口说明”)</td>
<td>作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(“xxxPOJO说明”)</td>
<td>作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = “xxx属性说明”,hidden = true)</td>
<td>作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(“xxx参数说明”)</td>
<td>作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
<tr>
<td>@ApiImplicitParam()</td>
<td>作用在方法上，表示单独的请求参数</td>
</tr>
<tr>
<td>@ApiImplicitParams()</td>
<td>作用于方法，包含多个 @ApiImplicitParam</td>
</tr>
</tbody></table>
<p>注：@ApiImplicitParam(name–参数名，value–参数说明 ，dataType–数据类型 ，example–举例说明，required–是否必填,</p>
<p>paramType–参数类型 )</p>
<p>paramType表示参数放在哪个地方</p>
<ul>
<li>header–&gt;请求参数的获取：@RequestHeader(代码中接收注解)</li>
<li>query–&gt;请求参数的获取：@RequestParam(代码中接收注解)</li>
<li>path（用于restful接口）–&gt;请求参数的获取：@PathVariable(代码中接收注解)</li>
<li>body–&gt;请求参数的获取：@RequestBody(代码中接收注解)</li>
<li>form（不常用）</li>
</ul>
<p>我们也可以给请求的接口配置一些注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.czm.swagger.controller;</span><br><span class="line"></span><br><span class="line">import com.czm.swagger.entity.User;</span><br><span class="line">import io.swagger.annotations.*;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Author CZM</span><br><span class="line"> * @create 2020&#x2F;10&#x2F;16 16:49</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@Api(value&#x3D;&quot;swagger的hello模块&quot;,tags&#x3D;&#123;&quot;用户操作接口&quot;&#125;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;getUser&quot;)</span><br><span class="line">    @ApiOperation(&quot;获取一个默认user对象&quot;)</span><br><span class="line">    @ApiResponses(&#123;@ApiResponse(code &#x3D; 200, message &#x3D; &quot;good&quot;),@ApiResponse(code &#x3D; 401, message &#x3D; &quot;no power&quot;)&#125;)</span><br><span class="line">    public User getUser(@ApiParam(value &#x3D; &quot;这是参数1&quot;,name &#x3D; &quot;param&quot;) @RequestParam String param,</span><br><span class="line">                        @ApiParam(value &#x3D; &quot;这是参数2&quot;,name &#x3D; &quot;param2&quot;) @RequestParam String param2)&#123;</span><br><span class="line">        return new User(param+&quot;123&quot;,param2+&quot;123456&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;czm&#x2F;getUser2&#x2F;&#123;account&#125;&#x2F;&#123;password&#125;&quot;)</span><br><span class="line">    @ApiOperation(&quot;获取一个指定user对象&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * name–参数ming</span><br><span class="line">             * value–参数说明</span><br><span class="line">             * dataType–数据类型</span><br><span class="line">             * paramType–参数类型</span><br><span class="line">             * example–举例说明</span><br><span class="line">             * required–是否必填</span><br><span class="line">             *&#x2F;</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;account&quot;,value&#x3D;&quot;用户名&quot;,dataType&#x3D;&quot;String&quot;, paramType &#x3D; &quot;path&quot;,</span><br><span class="line">            example &#x3D; &quot;username&quot;,required &#x3D; true),</span><br><span class="line">            @ApiImplicitParam(name&#x3D;&quot;password&quot;,value&#x3D;&quot;用户密码&quot;,dataType&#x3D;&quot;String&quot;, paramType &#x3D; 						&quot;path&quot;,example &#x3D; &quot;password&quot;)     </span><br><span class="line">    &#125;)</span><br><span class="line">    public User getUser2(@PathVariable(&quot;account&quot;) String account, </span><br><span class="line">    					@PathVariable(&quot;password&quot;) String password) &#123;</span><br><span class="line">        System.out.println(account+password);</span><br><span class="line">        return new User(account,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，可以给一些比较难理解的属性或者接口，增加一些配置信息，让人更容易阅读！</p>
<p>相较于传统的Postman或Curl方式测试接口，使用swagger简直就是傻瓜式操作，不需要额外说明文档(写得好本身就是文档)而且更不容易出错，只需要录入数据然后点击Execute，如果再配合自动化框架，可以说基本就不需要人为操作了。</p>
<p>Swagger是个优秀的工具，现在国内已经有很多的中小型互联网公司都在使用它，相较于传统的要先出Word接口文档再测试的方式，显然这样也更符合现在的快速迭代开发行情。当然了，提醒下大家在正式环境要记得关闭Swagger，一来出于安全考虑二来也可以节省运行时内存。</p>
<h3 id="方式二：使用第三方依赖"><a href="#方式二：使用第三方依赖" class="headerlink" title="方式二：使用第三方依赖"></a>方式二：使用第三方依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spring4all<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/SpringForAll/spring-boot-starter-swagger">github上有配置详情</a></p>
<h2 id="拓展：其他皮肤"><a href="#拓展：其他皮肤" class="headerlink" title="拓展：其他皮肤"></a>拓展：其他皮肤</h2><p>我们可以导入不同的包实现不同的皮肤定义：</p>
<ul>
<li>bootstrap-ui  <strong>访问 <a href="http://localhost:8080/doc.html">http://localhost:8080/doc.html</a></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/16/java/swagger/image-20201016210544771.png" alt="image-20201016210544771"></p>
<ul>
<li>Layui-ui  <strong>访问 <a href="http://localhost:8080/docs.html">http://localhost:8080/docs.html</a></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.github.caspar-chen&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-ui-layer&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.1.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>注：需注入一个groupName为默认的Docket</p>
<p><img src="/2020/10/16/java/swagger/image-20201016210310198.png" alt="image-20201016210310198"></p>
<ul>
<li>mg-ui  <strong>访问 <a href="http://localhost:8080/document.html">http://localhost:8080/document.html</a></strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.zyplayer&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;swagger-mg-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.0.6&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/16/java/swagger/image-20201016202725022.png" alt="image-20201016202725022"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内部类</title>
    <url>/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>注：</strong></p>
<p><strong>非静态内部类和外部类有同名变量和方法时，需要通过Outer.this方式来访问外部类成员变量或方法。</strong></p>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>定义在一个类的内部，外部类的每个对象都会加载一次，不可以定义<strong>静态</strong>成员和方法，可访问外部类的所有私有字段/方法,</p>
<p><strong>对于私有字段，访问，编译器会生成一个access函数提供调用。</strong></p>
<p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215210428834.png" alt="image-20201215210428834"></p>
<p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215210440082.png" alt="image-20201215210440082"></p>
<p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215210446377.png" alt="image-20201215210446377"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> * 成员内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;默认名&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> field = <span class="number">2.1f</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		也可用protected、private修饰内部类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Internal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String name = <span class="string">&quot;内部类的默认name&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Internal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Internal</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印外部与内部字段</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//内部类也有重名字段时</span></span><br><span class="line">            <span class="comment">//默认访问内部类字段</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内部age：&quot;</span> + age); <span class="comment">//内部age：0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;内部name：&quot;</span> + name); <span class="comment">//内部name：内部类的默认name</span></span><br><span class="line">            <span class="comment">// 访问外部类</span></span><br><span class="line">            System.out.println(<span class="string">&quot;外部age：&quot;</span> + InternalClass.age); <span class="comment">//外部age：9</span></span><br><span class="line">            System.out.println(<span class="string">&quot;外部name：&quot;</span> + InternalClass.<span class="keyword">this</span>.name); <span class="comment">//外部name：默认名</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回外部实例</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> InternalClass <span class="title">getOutClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> InternalClass.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Internal&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Internal internal = <span class="keyword">new</span> Internal();</span><br><span class="line">        <span class="comment">//外部类可以访问，修改内部类private字段</span></span><br><span class="line">        internal.age = <span class="number">2</span>;</span><br><span class="line">        System.out.println(internal); <span class="comment">//Internal&#123;age=2, name=&#x27;内部类的默认name&#x27;&#125;</span></span><br><span class="line">        internal.name = <span class="string">&quot;修改后的内部name&quot;</span>;</span><br><span class="line">        System.out.println(internal.name); <span class="comment">// 修改后的内部name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InternalClass internalClass = <span class="keyword">new</span> InternalClass();</span><br><span class="line">        internalClass.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化内部类前必须先实例化外部类</span></span><br><span class="line">        Internal internal = internalClass.<span class="function">new <span class="title">Internal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        internal.printOut();</span><br><span class="line">        System.out.println(internalClass == internal.getOutClass());</span><br><span class="line"></span><br><span class="line">        Class1 class1 = <span class="keyword">new</span> Class1();</span><br><span class="line">        System.out.println(class1.age1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>定义载方法内部或作用域内，不能被public、private、static修饰。可以直接访问外部类的成员。外部类无法直接创建局部内部类的实例，局部内部类可直接使用成员内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outNUm = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义在方法内</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.8之后java隐式的将x修饰为final</span></span><br><span class="line">        <span class="keyword">int</span> test1Field = <span class="number">111</span>;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Method</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> num1 = outNUm * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> num2 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//可直接访问成员内部类</span></span><br><span class="line">            InClass inClass = <span class="keyword">new</span> InClass();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类访问本地方法的变量：&quot;</span>+test1Field);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Method method = <span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(method.num1);</span><br><span class="line">        System.out.println(<span class="string">&quot;外部num2&quot;</span>+MethodClass.<span class="keyword">this</span>.num2);</span><br><span class="line">        System.out.println(method.num2);</span><br><span class="line"></span><br><span class="line">        method.method1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义在作用域内</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Partial</span></span>&#123;</span><br><span class="line">                <span class="keyword">private</span> String id;</span><br><span class="line">                <span class="function"><span class="keyword">private</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Partial ts = <span class="keyword">new</span> Partial();</span><br><span class="line">            ts.id = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">            System.out.println(ts.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MethodClass methodClass = <span class="keyword">new</span> MethodClass();</span><br><span class="line">        methodClass.test1();</span><br><span class="line">        methodClass.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>局部内部类访问局部变量，局部变量必须加final修饰。</p>
<p>因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，局部对象还要使用这个局部变量。为了让数据还能继续被使用，就用fian1修饰局部变量，这样，在堆内存里面存储的其实是一个常量值。</p>
<p><img src="/2020/12/15/java/%E5%86%85%E9%83%A8%E7%B1%BB/image-20201215213854116.png" alt="image-20201215213854116"></p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>一个接口的实现类，或者是继承于某个父类的子类，我们只使用一次。就可以使用匿名内部类。匿名内部类使用方法的本地变量也是要final修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.classes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javafx.scene.Parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Parents</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;work……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">    Parents father = <span class="keyword">new</span> Parents() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匿名内部类：&quot;</span>+flag);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部字段&quot;</span>+num1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//lamber表达式</span></span><br><span class="line">    Parents mothor =  (e)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;lamber实例化的匿名内部类：&quot;</span>+e);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Persion persion = <span class="keyword">new</span> Persion()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重写父类方法&quot;</span>);</span><br><span class="line">            <span class="keyword">super</span>.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tt = <span class="number">12</span>;</span><br><span class="line">        Persion p = <span class="keyword">new</span> Persion()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;在方法中使用后匿名内部类&quot;</span>);</span><br><span class="line">                System.out.println(tt);</span><br><span class="line">                <span class="keyword">super</span>.work();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.work();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnonymousInnerClass anonymousInnerClass = <span class="keyword">new</span> AnonymousInnerClass();</span><br><span class="line">        anonymousInnerClass.father.print(<span class="keyword">true</span>);</span><br><span class="line">        anonymousInnerClass.mothor.print(<span class="keyword">true</span>);</span><br><span class="line">        anonymousInnerClass.persion.work();</span><br><span class="line">        anonymousInnerClass.test1();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>关键字static修饰，只能访问外部静态字段和方法，根成员内部类一样可以用public等修饰符修饰，不依赖于外部类，可直接外部类.内部类使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = num;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;初始化静态内部类&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台打印如下：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 初始化静态内部类</span></span><br><span class="line"><span class="comment">     * 静态内部方法</span></span><br><span class="line"><span class="comment">     * test</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticClass.print();</span><br><span class="line">        StaticClass staticClass = <span class="keyword">new</span> StaticClass();</span><br><span class="line">        staticClass.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/12/22/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>设计模式用于在特定条件下为一些重复出现的软件设计问题提供合理的、有效的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>提高面向对象的软件系统的<strong>可维护性</strong>和<strong>可复用性</strong>是面向对象设计的核心问题之一。而面向对象的设计原则就是为支持可维护性和复用性而诞生。</p>
<h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h3><p>一个类只负责一个功能领域中的相应职责。是实现<strong>高内聚、低耦合</strong>的指导方针。</p>
<h3 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h3><p>软件实体应该对扩展开放（可复用性），对修改关闭。</p>
<h3 id="里氏代换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle, LSP)"></a>里氏代换原则(Liskov Substitution Principle, LSP)</h3><p>所有引用基类<strong>（父类）</strong>对象的地方都能透明地使用其子类的对象。<strong>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</strong></p>
<h3 id="依赖倒转原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒转原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒转原则(Dependence Inversion Principle, DIP)"></a>依赖倒转原则(Dependence Inversion Principle, DIP)</h3><p>抽象类不应该依赖于细节，细节应该依赖于抽象。</p>
<h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><p>使用多个专门的接口。而不使用单一的总接口。</p>
<h3 id="合成复用原则-Composite-Reuse-Principle-CRP"><a href="#合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="合成复用原则(Composite Reuse Principle, CRP)"></a>合成复用原则(Composite Reuse Principle, CRP)</h3><p>尽量使用对象组合，而不是继承来达到复用的目的</p>
<h3 id="迪米特法则-Law-of-Demeter-LoD"><a href="#迪米特法则-Law-of-Demeter-LoD" class="headerlink" title="迪米特法则(Law of Demeter, LoD)"></a>迪米特法则(Law of Demeter, LoD)</h3><p>一个软件实体应该尽可能少的与其他实体发生相互作用。</p>
<h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p><a href="https://blog.csdn.net/LoveLion/article/details/17517213?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160854156216780308343733%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160854156216780308343733&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-17517213.first_rank_v2_pc_rank_v29&utm_term=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">参考链接1</a></p>
<p><a href="https://blog.csdn.net/jason0539/article/details/44956775">参考链接2</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij IDEA常用快捷键</title>
    <url>/2020/10/10/%E5%85%B6%E4%BB%96/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="Intellij-IDEA常用快捷键"><a href="#Intellij-IDEA常用快捷键" class="headerlink" title="Intellij IDEA常用快捷键"></a>Intellij IDEA常用快捷键</h2><ol>
<li><p>Alt+回车 导入包,自动修正</p>
</li>
<li><p>Ctrl＋Alt＋V 插入变量名。</p>
</li>
<li><p>Ctrl＋Alt＋T可以把代码包在一块内，例如try/catch</p>
</li>
<li><p>Ctrl＋Q可以看到当前方法的声明（注释文档）</p>
</li>
<li><p>Alt＋Insert可以生成构造器/Getter/Setter等</p>
</li>
<li><p>Alt+Shift+C 对比最近修改的代码</p>
</li>
<li><p>Ctrl+N   查找类</p>
</li>
<li><p>Alt + 7 查看当前所有方法</p>
</li>
<li><p>Alt+f7 查看方法被调用(顺序)</p>
</li>
<li><p>Ctrl+Alt+H 查看方法被调用（逆推）</p>
</li>
<li><p>Ctrl+H 显示类结构图（继承结构）</p>
</li>
<li><p>Ctrl+Shift+N 查找文件</p>
</li>
<li><p>Ctrl+Alt+L  格式化代码</p>
</li>
<li><p>Ctrl+E查看最近文件</p>
</li>
<li><p>Ctrl+R 替换文本</p>
</li>
<li><p>Ctrl+F 查找文本</p>
</li>
<li><p>Ctrl+Shift+Space 代码提示</p>
</li>
<li><p>Ctrl+Alt+Space 类名或接口名提示</p>
</li>
<li><p>Ctrl+P 方法参数提示</p>
</li>
<li><p>Shift+F6  重构-重命名</p>
</li>
<li><p>Ctrl+X 复制行</p>
</li>
<li><p>Ctrl+D 删除行</p>
</li>
<li><p>Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/<em>…</em>/ ）</p>
</li>
<li><p>Alt+F1 查找代码所在位置</p>
</li>
<li><p>Ctrl+Alt+ left/right 返回至上次浏览的位置</p>
</li>
<li><p>Alt+ left/right 切换代码视图</p>
</li>
<li><p>Alt+ Up/Down 在方法间快速移动定位</p>
</li>
<li><p>Ctrl+Shift+Up/Down 代码向上/下移动。</p>
</li>
<li><p>F2 或Shift+F2 高亮错误或警告快速定位</p>
</li>
<li><p>代码标签输入完成后，按Tab，生成代码。</p>
</li>
<li><p>选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。</p>
</li>
<li><p>Ctrl+W 选中代码，连续按会有其他效果</p>
</li>
<li><p>选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。</p>
</li>
<li><p>Ctrl+Up/Down 光标跳转到第一行或最后一行下</p>
</li>
<li><p>Ctrl+B 快速打开光标处的类或方法 </p>
</li>
<li><p>Shift＋Click可以关闭文件</p>
</li>
<li><p>Ctrl＋[或]可以跳到大括号的开头结尾</p>
</li>
<li><p>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方</p>
</li>
<li><p>Ctrl＋F12，可以显示当前文件的结构</p>
</li>
<li><p>Ctrl＋F7可以查询当前元素在当前文件中的引用，然后按F3可以选择</p>
</li>
<li><p>Ctrl＋W可以选择单词继而语句继而行继而函数</p>
</li>
<li><p>Ctrl＋Shift＋Insert可以选择剪贴板内容并插入</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ快速上手</title>
    <url>/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RocketMQ是一款阿里巴巴开源的消息中间件，在2017年9月份成为Apache的顶级项目，是国内首个互联网中间件在 Apache 上的顶级项目。RocketMQ经过了阿里多年双十一大促的考验，性能和稳定性得到了充分的考验。目前在业界被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binlog分发等场景。</p>
<h3 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h3><p><a href="http://rocketmq.apache.org/">http://rocketmq.apache.org/</a></p>
<h3 id="开源项目地址"><a href="#开源项目地址" class="headerlink" title="开源项目地址"></a>开源项目地址</h3><p><a href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></p>
<h3 id="常用中间件对比"><a href="#常用中间件对比" class="headerlink" title="常用中间件对比"></a>常用中间件对比</h3><p><img src="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/20200904180457430.png" alt="20200904180457430"></p>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p><img src="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="架构设计"></p>
<p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">官方文档链接</a></p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h3 id="1-执行解压命令"><a href="#1-执行解压命令" class="headerlink" title="1. 执行解压命令"></a>1. 执行解压命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.9.0-bin-release.zip </span><br></pre></td></tr></table></figure>

<p><strong>注意启动前修改bin目录下的 runbroker.sh 和 runserver.sh 中JVM内存参数，否者可能启动不了。</strong></p>
<h3 id="2-进入bin目录"><a href="#2-进入bin目录" class="headerlink" title="2. 进入bin目录"></a>2. 进入bin目录</h3><h3 id="3-启动NameServer"><a href="#3-启动NameServer" class="headerlink" title="3. 启动NameServer"></a>3. 启动<code>NameServer</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<h3 id="4-启动Broker"><a href="#4-启动Broker" class="headerlink" title="4. 启动Broker"></a>4. 启动Broker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup sh mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="comment"># nohup sh mqbroker -c 自定义配置文件路径 &amp;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.  测试"></a>5.  测试</h3><ul>
<li><strong>发送消息</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="comment"># 2.使用安装包的Demo发送消息</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>接收消息</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.设置环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="comment"># 2.接收消息</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.C</span><br></pre></td></tr></table></figure>

<h3 id="6-关闭"><a href="#6-关闭" class="headerlink" title="6. 关闭"></a>6. 关闭</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.关闭NameServer</span></span><br><span class="line">sh mqshutdown namesrv</span><br><span class="line"><span class="comment"># 2.关闭Broker</span></span><br><span class="line">sh mqshutdown broker</span><br></pre></td></tr></table></figure>

<h2 id="配置详情"><a href="#配置详情" class="headerlink" title="配置详情"></a>配置详情</h2><p>在config目录下有相应配置示例</p>
<p><img src="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/image-20210626150015562.png" alt="image-20210626150015562"></p>
<ul>
<li>2m-2s-async：双主双从异步更新</li>
<li>2m-2s-sync：双主双从同步更新</li>
<li>2m-noslave：双主</li>
</ul>
<h3 id="参数详情"><a href="#参数详情" class="headerlink" title="参数详情"></a>参数详情</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line"><span class="attr">brokerClusterName</span>=<span class="string">DefaultCluster</span></span><br><span class="line"><span class="comment">#broker名字</span></span><br><span class="line"><span class="attr">brokerName</span>=<span class="string">broker-a</span></span><br><span class="line"><span class="comment">#身份Id 0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line"><span class="attr">brokerId</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#nameServer地址，多个用</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">localhost:9876;localhost:9877</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line"><span class="attr">defaultTopicQueueNums</span>=<span class="string">4</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组</span></span><br><span class="line"><span class="attr">autoCreateSubscriptionGroup</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line"><span class="attr">listenPort</span>=<span class="string">10911</span></span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line"><span class="attr">deleteWhen</span>=<span class="string">04</span></span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">48</span></span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G ;1G = 1073741824 字节</span></span><br><span class="line"><span class="attr">mapedFileSizeCommitLog</span>=<span class="string">1073741824</span></span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line"><span class="attr">mapedFileSizeConsumeQueue</span>=<span class="string">300000</span></span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span>=<span class="string">88</span></span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/usr/local/RoccketMQ/rocketmq1/store</span></span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/usr/local/RoccketMQ/rocketmq1/store/commitlog</span></span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line"><span class="attr">storePathConsumeQueue</span>=<span class="string">/usr/local/RoccketMQ/rocketmq1/store/consumequeue</span></span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line"><span class="attr">storePathIndex</span>=<span class="string">/usr/local/RoccketMQ/rocketmq1/store/index</span></span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line"><span class="attr">storeCheckpoint</span>=<span class="string">/usr/local/RoccketMQ/rocketmq1/store/checkpoint</span></span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line"><span class="attr">abortFile</span>=<span class="string">/usr/local/RoccketMQ/rocketmq1/store/abort</span></span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line"><span class="attr">maxMessageSize</span>=<span class="string">65536</span></span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line"><span class="attr">brokerRole</span>=<span class="string">SYNC_MASTER</span></span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line"><span class="attr">flushDiskType</span>=<span class="string">SYNC_FLUSH</span></span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：集群配置时每个broker的storePath要不同否则会报java.lang.RuntimeException: Lock failed,MQ already started错误</p>
<h2 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h2><h3 id="mqadmin"><a href="#mqadmin" class="headerlink" title="mqadmin"></a>mqadmin</h3><p>在bin目录下直接执行 ./mqadmin {command} {args}。</p>
<h3 id="图形化管理界面"><a href="#图形化管理界面" class="headerlink" title="图形化管理界面"></a>图形化管理界面</h3><ol>
<li>到<code>github</code>上下载<a href="https://github.com/apache/rocketmq-externals">RocketMQ的扩展类开源项目</a></li>
</ol>
<p><img src="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/image-20210626160220910.png" alt="image-20210626160220910"></p>
<ol start="2">
<li>解压后需修改rocketmq-console的配置文件application.properties(添加nameServer的地址)</li>
</ol>
<p><img src="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/image-20210626160428573.png" alt="image-20210626160428573"></p>
<ol start="3">
<li><p>再执行maven打包为可执行jar包运行：<code>mvn clean package -Dmaven.test.skip=true</code></p>
</li>
<li><p>直接运行jar包访问8080端口即可：java - jar ×××.jar</p>
</li>
</ol>
<p><img src="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/image-20210626161251007.png" alt="image-20210626161251007"></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消息生产者producer，并制定生产者组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        <span class="comment">// String NAME_SERVER = &quot;czm.com:9876;czm.com:9877&quot;;</span></span><br><span class="line">        producer.setNamesrvAddr(Common.NAME_SERVER);</span><br><span class="line">        <span class="comment">//3.启动producer</span></span><br><span class="line">        producer.start();</span><br><span class="line">		<span class="comment">//生产者设置监听器，可用于事务</span></span><br><span class="line">        <span class="comment">//producer.setTransactionListener(transactionListener);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//4.创建消息对象，指定主题Topic、Tag和消息体</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 消息主题Topic：base</span></span><br><span class="line"><span class="comment">             * 消息Tag： Tag1</span></span><br><span class="line"><span class="comment">             * 消息内容：byte数组</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;base&quot;</span>, <span class="string">&quot;Tag1&quot;</span>, (<span class="string">&quot;Hello World&quot;</span> + i).getBytes());</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送单向消息只管发送，无返回值无需等待，producer.sendOneway(msg);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//5.发送消息</span></span><br><span class="line">            SendResult result = producer.send(msg);</span><br><span class="line">            <span class="comment">//发送状态</span></span><br><span class="line">            SendStatus status = result.getSendStatus();</span><br><span class="line">            System.out.println(<span class="string">&quot;发送结果:&quot;</span> + result);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送异步消息</span></span><br><span class="line"><span class="comment">//            producer.send(msg, new SendCallback() &#123;</span></span><br><span class="line"><span class="comment">//                /**</span></span><br><span class="line"><span class="comment">//                 * 发送成功回调函数</span></span><br><span class="line"><span class="comment">//                 * @param sendResult</span></span><br><span class="line"><span class="comment">//                 */</span></span><br><span class="line"><span class="comment">//                @Override</span></span><br><span class="line"><span class="comment">//                public void onSuccess(SendResult sendResult) &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;发送结果：&quot; + sendResult);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                /**</span></span><br><span class="line"><span class="comment">//                 * 发送失败回调函数</span></span><br><span class="line"><span class="comment">//                 * @param e</span></span><br><span class="line"><span class="comment">//                 */</span></span><br><span class="line"><span class="comment">//                @Override</span></span><br><span class="line"><span class="comment">//                public void onException(Throwable e) &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;发送异常：&quot; + e);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.关闭生产者producer</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建消费者Consumer，制定消费者组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">        <span class="comment">//2.指定Nameserver地址</span></span><br><span class="line">        consumer.setNamesrvAddr(Common.NAME_SERVER);</span><br><span class="line">        <span class="comment">//3.订阅主题Topic和Tag=*匹配所有，可用tag或MessageSelector实现消息过滤</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;base&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定消费模式：负载均衡CLUSTERING（默认）| 广播模式BROADCASTING</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.BROADCASTING);</span><br><span class="line">        <span class="comment">//设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line"> 		consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.设置回调函数，处理消息</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接受消息内容</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumeThread=&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;,&quot;</span> + <span class="keyword">new</span> String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.启动消费者consumer</span></span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="消息延迟"><a href="#消息延迟" class="headerlink" title="消息延迟"></a>消息延迟</h2><pre><code>// 设置延时等级,延迟消息时使用
//在源码的org.apache.rocketmq.store.config.MessageStoreConfig类中有相应级别声明
//private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;
//在消息发送前设置 0表示不延迟，3表示延时10秒
//msg.setDelayTimeLevel(3);</code></pre>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h2><h3 id="使用tag是实现"><a href="#使用tag是实现" class="headerlink" title="使用tag是实现"></a>使用tag是实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;TOPIC&quot;</span>, <span class="string">&quot;TAG1 || TAG2 || TAG3&quot;</span>); <span class="comment">//接收TAG1|TAG2|TAG3的消息</span></span><br></pre></td></tr></table></figure>

<h3 id="使用MessageSelector实现"><a href="#使用MessageSelector实现" class="headerlink" title="使用MessageSelector实现"></a>使用MessageSelector实现</h3><p>生产者通过<code>putUserProperty</code>设置消息的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">producer.start();</span><br><span class="line">Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">   tag,</span><br><span class="line">   <span class="string">&quot;Hello World &quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 设置一些属性</span></span><br><span class="line">msg.putUserProperty(<span class="string">&quot;t&quot;</span>, String.valueOf(i));</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<p>消费者通过MessageSelector获取符合相应sql条件的消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">consumer.subscribe(<span class="string">&quot;tag&quot;</span>, MessageSelector.bySql(<span class="string">&quot;t between 0 and 5&quot;</span>);</span><br><span class="line">consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>



<h2 id="RocketMQ顺序消费"><a href="#RocketMQ顺序消费" class="headerlink" title="RocketMQ顺序消费"></a>RocketMQ顺序消费</h2><p><a href="https://www.cnblogs.com/hzmark/p/orderly_message.html">参考链接</a></p>
<p><a href="https://www.jianshu.com/p/0ff1b6a3da36">参考链接</a></p>
<h2 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h2><p><a href="https://www.jianshu.com/p/cc5c10221aa1">RocketMQ事务</a></p>
<p><a href="http://www.tianshouzhi.com/api/tutorials/rocketmq/50">Rocket博客</a></p>
<p><a href="https://blog.csdn.net/yjclsx/article/details/80838373?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162471071116780265467873%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162471071116780265467873&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-80838373.pc_search_result_before_js&utm_term=rocketmq%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C&spm=1018.2226.3001.4187">RocketMQ基础</a></p>
<p><a href="https://blog.csdn.net/prestigeding/article/details/78888290/">源码分析</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2020/12/15/%E5%85%B6%E4%BB%96/%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h2><p><strong>Arthas</strong> 是Alibaba开源的Java诊断工具，可以解决一下问题：</p>
<ol>
<li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li>
<li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li>
<li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li>
<li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li>
<li>是否有一个全局视角来查看系统的运行状况？</li>
<li>有什么办法可以监控到JVM的实时运行状态？</li>
<li>怎么快速定位应用的热点，生成火焰图？</li>
<li>怎样直接从JVM内查找某个类的实例？</li>
</ol>
<p><code>Arthas</code>支持JDK 6+，支持Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p>
<h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><p><a href="https://arthas.aliyun.com/doc/#arthas">https://arthas.aliyun.com/doc/#arthas</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>RK987快捷键</title>
    <url>/2020/11/15/%E5%85%B6%E4%BB%96/RK%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h2 id="Fn-A后"><a href="#Fn-A后" class="headerlink" title="Fn+A后"></a>Fn+A后</h2><ul>
<li>Caps Lock = 长按2s后 切换到大写；点按切换中英文</li>
<li>按住shift= 打印大写字母</li>
<li>ctrl + backspace=切换中英文</li>
<li>🔒 + A = 全选</li>
<li>ctrl+ ⬅️ 或者 ➡️ 桌面切换</li>
<li>ctrl+⬇️ 显示当前桌面所有窗口   ===作用等同 F3</li>
<li>ctrl+⬆️ 显示当前桌面所有窗口  ===作用等同 F3</li>
</ul>
<p>FX系列使用说明</p>
<ul>
<li>F1 亮度调暗  </li>
<li>F2 亮度调亮</li>
<li>F3 显示当前桌面所有窗口</li>
<li>F4 启动台</li>
<li>F5 +command  启动旁白</li>
<li>F8 启动苹果音乐</li>
<li>F10 静音</li>
<li>F10 + Alt 或 F11 + Alt 或 F11 + Alt 打开声音配置</li>
<li>F11 降低声音</li>
<li>F12 增加音量</li>
</ul>
<ul>
<li>Fn+SCR LK 切换灯光效果</li>
<li>Fn+A: 切换到mac 键盘 Fn+S: 切换到win键盘</li>
<li>🔒键==command键 alt==option</li>
</ul>
<h2 id="Fn-S后"><a href="#Fn-S后" class="headerlink" title="Fn+S后"></a>Fn+S后</h2><ul>
<li>Caps Lock = 长按2s后 切换到大写；点按切换中英文</li>
<li>按住shift= 打印大写字母</li>
<li>ctrl + backspace=切换中英文</li>
<li>ALT + A = 全选</li>
</ul>
<h2 id="蓝牙切换"><a href="#蓝牙切换" class="headerlink" title="蓝牙切换"></a>蓝牙切换</h2><p><img src="/2020/11/15/%E5%85%B6%E4%BB%96/RK%E5%BF%AB%E6%8D%B7%E9%94%AE/RK%E8%93%9D%E7%89%99.jpg" alt="RK蓝牙"></p>
<p><a href="http://www.rkgaming.com/zh-CN/article.php?id=5123">参考链接</a></p>
]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>前端问题记录</title>
    <url>/2021/10/30/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="axios使用form-data上传文件报错：content-Type缺少boundry"><a href="#axios使用form-data上传文件报错：content-Type缺少boundry" class="headerlink" title="axios使用form-data上传文件报错：content-Type缺少boundry"></a>axios使用form-data上传文件报错：content-Type缺少boundry</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局设置post请求</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</span><br><span class="line">axios.defaults.transformRequest = [<span class="function"><span class="keyword">function</span> (<span class="params">data, config</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 文件特殊处理 </span></span><br><span class="line">  <span class="comment">// 对content-type为multipart/form-data的不进行序列化处理</span></span><br><span class="line">  <span class="keyword">if</span> ((config[<span class="string">&#x27;Content-Type&#x27;</span>]+<span class="string">&quot;&quot;</span>).toLowerCase().startsWith(<span class="string">&#x27;multipart/form-data&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将参数序列化成URL的形式</span></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> it <span class="keyword">in</span> data) &#123;</span><br><span class="line">    ret += <span class="built_in">encodeURIComponent</span>(it) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(data[it]) + <span class="string">&#x27;&amp;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><a href="https://blog.csdn.net/weixin_43831316/article/details/105935966">参考链接</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式基础</title>
    <url>/2021/05/10/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h2><p><a href="https://blog.csdn.net/lin819747263/article/details/106313936">概念</a></p>
<p><a href="https://blog.csdn.net/cnh294141800/article/details/53768464?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">例子</a></p>
<h2 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h2><p>注：Consul注册中心就是基于此协议。</p>
<p><a href="https://zhuanlan.zhihu.com/p/91288179">参考链接</a></p>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>ZooKeeper 是一个由Java开发的开源的分布式协调服务。它是一个为分布式应用提供一致性服务的软件，分布式应用程序可以基于 Zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h3><p>Zookeeper Atomic Broadcast（Zookeeper 原子广播协议），为了保证写操作的一致性与可用性，ZooKeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，ZooKeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。根据ZAB协议，所有的写操作都必须通过Leader完成，Leader写入本地日志后再复制到所有的Follower节点。ZAB 让整个 Zookeeper 集群在<span style="color: red;">消息广播和崩溃恢复</span>两个模式之间转换。</p>
<p><a href="https://dbaplus.cn/news-141-1875-1.html">学习链接</a></p>
<h3 id="ZooKeeper的特性"><a href="#ZooKeeper的特性" class="headerlink" title="ZooKeeper的特性"></a>ZooKeeper的特性</h3><ol>
<li><p>顺序一致性： 保证客户端操作是按照顺序生效的.</p>
</li>
<li><p>原子性： 更新成功或失败，没有部分结果.</p>
</li>
<li><p>单个系统映像：无论连接到哪个集群中服务器，客户端都能看到相同的内容.</p>
</li>
<li><p>可靠性： 数据的变更不会丢失，除非被客户端覆盖修改.</p>
</li>
<li><p>zk发生数据更改时，先进行事务记录，会在集群中进行一致性算法处理，最终实现一致性，实现可靠.</p>
</li>
<li><p>及时性： 保证系统的客户端当时读取的数据是最新的.</p>
</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>主从架构下，leader 崩溃，数据一致性怎么保证？</li>
</ol>
<p>leader 崩溃之后，集群会选出新的 leader，然后就会进入恢复阶段，新的 leader 具有所有已经提交的提议，因此它会保证让 followers 同步已提交的提议，丢弃未提交的提议（以 leader 的记录为准），这就保证了整个集群的数据一致性。</p>
<ol start="2">
<li>选举 leader 的时候，整个集群无法处理写请求的，如何快速进行 leader 选举？</li>
</ol>
<p>这是通过 Fast Leader Election 实现的，leader 的选举只需要超过半数的节点投票即可，这样不需要等待所有节点的选票，能够尽早选出 leader。</p>
<p><a href="https://blog.csdn.net/ThinkWon/article/details/104397719?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161910463316780357235571%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161910463316780357235571&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-104397719.first_rank_v2_pc_rank_v29&utm_term=zookeeper+%E9%9D%A2%E8%AF%95">学习链接1</a></p>
<p><a href="https://blog.csdn.net/oldshaui/article/details/84658145">学习链接2</a></p>
<p><a href="https://blog.csdn.net/weixin_48272905/article/details/108934427?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161910463316780357235571%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161910463316780357235571&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-5-108934427.first_rank_v2_pc_rank_v29&utm_term=zookeeper+%E9%9D%A2%E8%AF%95">学习链接3</a></p>
<h2 id="强一致性算法Paxos、Raft、ZAB简单理解"><a href="#强一致性算法Paxos、Raft、ZAB简单理解" class="headerlink" title="强一致性算法Paxos、Raft、ZAB简单理解"></a>强一致性算法Paxos、Raft、ZAB简单理解</h2><p><a href="https://blog.csdn.net/ystyaoshengting/article/details/105048798">参考链接</a></p>
<h2 id="因果关系-向量时钟"><a href="#因果关系-向量时钟" class="headerlink" title="因果关系-向量时钟"></a>因果关系-向量时钟</h2><p><a href="https://blog.csdn.net/TechFlow/article/details/104231618">参考链接</a></p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><a href="https://blog.csdn.net/xiaofeng10330111/article/details/86772650?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161910501216780262582012%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161910501216780262582012&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-86772650.first_rank_v2_pc_rank_v29&utm_term=%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">学习链接1</a></p>
<h2 id="服务熔断和降级"><a href="#服务熔断和降级" class="headerlink" title="服务熔断和降级"></a>服务熔断和降级</h2><p><a href="https://blog.csdn.net/zero__007/article/details/90732554">参考链接</a></p>
<h2 id="集群、分布式、SOA-、微服务区别"><a href="#集群、分布式、SOA-、微服务区别" class="headerlink" title="集群、分布式、SOA 、微服务区别"></a>集群、分布式、SOA 、微服务区别</h2><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>多台服务部署相同应用构成一个集群。</p>
<p>作用：通过负载均衡设备共同对外提供服务。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式系统是一个硬件或软件组件（子系统）分布在不同的网络计算机上，彼此之间仅仅通过消息传递和协调完成整个业务流程的系统。不同模块部署在不同的服务器上。</p>
<p>作用：解决网站高并发带来的问题。</p>
<h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p>Service Oriented Architecture 面向服务的架构。将应用程序的不同功能单元拆分为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力，通过这些服务之间定义<strong>良好的接口和契约</strong>联系起来。SOA比分布式架构更加解耦合。扩展也更容易。</p>
<p>作用：简化维护，降低整体风险，伸缩灵活。</p>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>架构设计概念更倡导<strong>服务的细粒度，重用组合</strong>，各服务间隔（分布式也是隔离），自治（分布式依赖整体组合），其它特性（单一职责，边界，异步通信，独立部署），是分布式概念的更严执行SOA到微服务的演讲过程。</p>
<p>作用：各服务可独立应用，组合服务也可系统应用。</p>
<p><a href="https://blog.csdn.net/HeatDeath/article/details/79038795">参考链接</a></p>
<p><a href="https://blog.csdn.net/binggetong/article/details/79126359">参考链接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/61901608">Service Mesh</a></p>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>window10使用笔记</title>
    <url>/2021/10/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/window%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="cmd命令窗口乱码"><a href="#cmd命令窗口乱码" class="headerlink" title="cmd命令窗口乱码"></a>cmd命令窗口乱码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在命令行输入CHCP指令</span></span><br><span class="line"><span class="comment"># CHCP是一个计算机指令，能够显示或设置活动代码页编号。</span></span><br><span class="line">CHCP 65001 <span class="comment"># 使用utf-8代码页</span></span><br><span class="line">CHCP 936 <span class="comment">#使用gbk简体中文代码页</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2021/01/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统（operation system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与配置<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>​        内核是操作系统的基础模块，用于管理系统资源。例如提供对软件层面的抽象（例如对进程、文件系统、同步、内存、网络协议等对象的操作和权限控制），和对硬件访问的抽象（例如磁盘，显示，网络接口卡（NIC））；操作系统，在内核的基础上有延伸，包括了提供基础服务的系统组件。</p>
<p>​        内核就是计算机学科意义上的操作系统，直接与硬件交互，提供CPU时间片管理、中断、内存管理、IO管理等等；一般意义上的操作系统包含的东西要更多一些，至少要有用户交互的基本程序，比如一个命令行界面和基本的指令（文件遍历、进程管理等等），或者图形界面的桌面和文件浏览器。</p>
<p><a href="https://blog.csdn.net/qq_26849233/article/details/74527779">参考链接</a></p>
<p>……</p>
<h2 id="常见进程调度算法"><a href="#常见进程调度算法" class="headerlink" title="常见进程调度算法"></a>常见进程调度算法</h2><ol>
<li>先来先服务调度算法</li>
<li>短作业优先调度算法</li>
<li>时间片轮转法</li>
<li>多级反馈队列调度算法</li>
<li>优先权调度算法的类型</li>
<li>高响应比优先调度算法</li>
</ol>
<p><a href="https://blog.csdn.net/luyafei_89430/article/details/12971171?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161432243216780265447720%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161432243216780265447720&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-5-12971171.first_rank_v2_pc_rank_v29&utm_term=%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&spm=1018.2226.3001.4187">详情链接</a></p>
<p><a href="https://www.cnblogs.com/smuxiaolei/p/7544086.html">各种调度算法</a></p>
<h2 id="硬盘基本知识"><a href="#硬盘基本知识" class="headerlink" title="硬盘基本知识"></a>硬盘基本知识</h2><ol>
<li>盘片（platter）</li>
<li>磁头（head）</li>
<li>磁道（track）</li>
<li>扇区（sector）</li>
<li>柱面（cylinder）</li>
</ol>
<p><a href="https://www.cnblogs.com/jswang/p/9071847.html">详情链接</a></p>
<h2 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h2><p>操作系统内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。<strong>操作系统内存管理包括物理内存管理和虚拟内存管理。</strong></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><a href="https://juejin.cn/post/6844903507594575886">链接1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/96098896">链接2</a></p>
<h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ol>
<li>块式管理</li>
<li>页式管理</li>
<li>段式管理</li>
<li>段页式管理</li>
</ol>
<p><a href="https://blog.csdn.net/hguisu/article/details/5713164?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161432520816780262540622%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161432520816780262540622&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-5713164.first_rank_v2_pc_rank_v29&utm_term=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&spm=1018.2226.3001.4187">详情链接</a></p>
<p><a href="https://blog.csdn.net/ChaunceyChen/article/details/86672415">链接</a></p>
<p><a href="https://developer.aliyun.com/article/636086?spm=a2c6h.13813017.0.dArticle738638.4e383df7rJCRtx">详细链接</a></p>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>为了区分不同进程的不同权限，衍生出内核态（系统态）和用户态的概念。计算机通过CPU的一个状态字来区分当前进程属于哪个状态，内核态和用户态分别对应CPU的特权态（0级）和普通态（3级）。（注：intel CPU提供Ring0-Ring3四种级别的运行模式）</p>
<h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>CPU可以访问内存几乎所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序。</p>
<h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>所有的用户程序都运行在用户态，有时需要执行内核态才能执行的操作（如：文件操作，IO处理，设备驱动等），这时需要一种机制，让用户态进程切换到内核态，但不能控制在内核中执行的指令，这种机制称为<strong>系统调用</strong>。CPU实现称为陷阱指令。</p>
<h3 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h3><ol>
<li>系统调用</li>
<li>异常</li>
<li>外围设备中断（常见：缺页中断）</li>
</ol>
<p><a href="https://blog.csdn.net/qq_42022528/article/details/87860311">参考链接</a></p>
<p><a href="https://blog.csdn.net/qq_34170700/article/details/106996450?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161588207916780255238783%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161588207916780255238783&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-5-106996450.first_rank_v2_pc_rank_v29&utm_term=%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81+%E5%8E%9F%E7%90%86">参考链接</a></p>
<h2 id="用户态线程和内核态线程"><a href="#用户态线程和内核态线程" class="headerlink" title="用户态线程和内核态线程"></a>用户态线程和内核态线程</h2><h3 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h3><p>指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，<strong>因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。</strong>由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。</p>
<p><strong>优点：</strong></p>
<ol>
<li>线程的调度不需要内核直接参与，控制简单。</li>
<li>可以在不支持线程的操作系统中实现。</li>
<li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</li>
<li>允许每个进程定制自己的调度算法，线程管理比较灵活。</li>
<li>线程能够利用的表空间和堆栈空间比内核级线程多。</li>
<li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。</li>
</ol>
<p><strong>缺点：</strong></p>
<p>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用。</p>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp（对称多处理，即利用多核cpu）。windows线程就是这样的。一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行。</p>
<p><strong>优点：</strong></p>
<p>当有多个处理机时，一个进程的多个线程可以同时执行。</p>
<p><strong>缺点：</strong></p>
<p>由内核进行调度。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</li>
<li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</li>
<li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</li>
<li>在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</li>
<li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</li>
</ol>
<p><a href="https://www.cnblogs.com/wanglulu/p/5522809.html">参考链接</a></p>
<h3 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h3><p><img src="/2021/01/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20210801212619895.png" alt="image-20210801212619895"></p>
<h2 id="进程间的通讯"><a href="#进程间的通讯" class="headerlink" title="进程间的通讯"></a>进程间的通讯</h2><ol>
<li>管道（匿名管道、有名管道、流管道）</li>
<li>信号量</li>
<li>消息队列</li>
<li>信号</li>
<li>共享内存</li>
<li>套接字</li>
</ol>
<p><a href="https://www.cnblogs.com/wanjianjun777/p/10483861.html">参考链接</a></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul>
<li>二层负载均衡</li>
</ul>
<p>负载均衡服务器对外提供一个VIP（虚拟IP），集群内部各主机拥有<strong>相同</strong>的IP地址，但是拥有不同MAC地址，负载均衡服务器通过改写请求报文中的<strong>目标MAC地址实现负载均衡</strong>。</p>
<ul>
<li>三层负载均衡</li>
</ul>
<p>负载均衡服务器对外提供一个VIP，集群内各主机IP地址<strong>不同</strong>，服务器接收到请求后，根据负载均衡算法，通过IP将请求发送至不同的主机。</p>
<ul>
<li>四层负载均衡</li>
</ul>
<p>位于OSI模型的第四层——传输层。有TCP/UDP协议，这两协议都包含了源端口/目标端口，负载均衡服务器通过修改报文的地址信息{IP（网络层IP）+端口}实现负载均衡。</p>
<ul>
<li>七层负载均衡</li>
</ul>
<p>位于第七层——应用层。常用协议：HTTP、RADIUS、DNS等。七层负载可以基于这些协议，如根据UPL、浏览器类别、语言、地理位置进行负载均衡。</p>
<p><a href="https://mp.weixin.qq.com/s/9POrwe3jrE1kChps6r-osQ">参考链接</a></p>
<h2 id="select、poll和epoll区别"><a href="#select、poll和epoll区别" class="headerlink" title="select、poll和epoll区别"></a>select、poll和epoll区别</h2><p><a href="https://blog.csdn.net/davidsguo008/article/details/73556811">参考链接</a></p>
<p><a href="https://blog.csdn.net/wteruiycbqqvwt/article/details/90299610">参考链接</a></p>
<p><a href="https://blog.csdn.net/armlinuxww/article/details/92803381">Epoll原理</a></p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝其实是根据内核状态划分的，在这里没有经过CPU的拷贝，数据在用户态的状态下，经历了零次拷贝，所以才叫做零拷贝，但不是说不拷贝。在内核中还是有数据从硬盘拷贝到read buffer缓存区，数据的位置和长度的信息的描述符被追加到了socket buffer 缓冲区中。</p>
<p><a href="https://blog.csdn.net/li295214001/article/details/105714872/">参考链接</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>数据挖掘复习</title>
    <url>/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><p>数据挖掘一般是指从大量数据中通过算法搜索隐藏于其中的信息的过程（数据采矿）。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="数据挖掘的定义"><a href="#数据挖掘的定义" class="headerlink" title="数据挖掘的定义"></a>数据挖掘的定义</h2><h3 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h3><p>数据挖掘就是从<strong>大量</strong>数据中， 提取<strong>潜在的有用</strong>信息和知识的过程。</p>
<h4 id="商业层面"><a href="#商业层面" class="headerlink" title="商业层面"></a>商业层面</h4><p>数据挖掘就是一种商业信息处理技术。其主要特点是对大量业务数据进行<strong>抽取、转换、分析和建模处理，</strong>从中<strong>提取</strong>辅助商业决策的关键性数据。</p>
<h2 id="数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别"><a href="#数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别" class="headerlink" title="数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别"></a>数据挖掘与传统数据分析方法（如查询，报表，联机应用分析等）的区别</h2><p><strong>本质区别:</strong>  数据挖掘是在<strong>没有明确假设</strong>的前提下去挖掘信息、发现知识。数据挖掘所得到的信息应具有<strong>先前未知、有效和实用</strong>三个特征。其主要目标就是<strong>提高决策能力，能在过去的经验基础上预言未来趋势</strong>等。</p>
<h2 id="数据挖掘任务"><a href="#数据挖掘任务" class="headerlink" title="数据挖掘任务"></a>数据挖掘任务</h2><h3 id="预测任务"><a href="#预测任务" class="headerlink" title="预测任务"></a>预测任务</h3><p>根据其它属性的值<strong>预测</strong>特定属性的值，如<strong>分类</strong>、回归、<strong>离群点检测。</strong></p>
<h4 id="描述任务"><a href="#描述任务" class="headerlink" title="描述任务"></a>描述任务</h4><p>寻找概括数据中潜在联系的模式，如<strong>聚类分析、关联分析、演化分析、序列模式挖掘。</strong></p>
<h2 id="数据挖掘-入侵检查"><a href="#数据挖掘-入侵检查" class="headerlink" title="数据挖掘-入侵检查"></a>数据挖掘-入侵检查</h2><ul>
<li>入侵可以定义为任何**威胁网络资源(**如用户账号、文件系统、系统内核等)的完整性、机密性和可用性的行为。</li>
<li>大多数商业入侵检测系统主要使用<strong>误用检测策略</strong>，这种策略对已知类型的攻击通过规则可以较好地检测，但对新的未知攻击或已知攻击的变种则难以检测。</li>
<li>异常检测通过构建<strong>正常网络行为模型</strong>(称为特征描述)，来检测与特征描述<strong>严重偏离</strong>的新的模式。</li>
</ul>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><ul>
<li><p>数据清理：填写空缺数据，平滑噪声数据，识别、删除孤立点，解决不一致性。</p>
</li>
<li><p>数据集成：集成<strong>多个</strong>数据库，数据立方体或文件中的数据，存放到一个<strong>一致的数据存储设备</strong>中（需考虑<strong>一致性</strong>和<strong>冗余</strong>问题）。</p>
</li>
<li><p>数据变换： <strong>规范化</strong>和特征构造。</p>
</li>
</ul>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226175507783.png" alt="image-20201226175507783"></p>
<ul>
<li>数据归约：得到数据集的压缩表示及特征选择（从<strong>记录</strong>和<strong>维度</strong>两方面减少数据量）。</li>
<li>离散化：通过将属性域划分为区间，减少给定连续属性值的个数。</li>
</ul>
<h2 id="相似性度量"><a href="#相似性度量" class="headerlink" title="相似性度量"></a>相似性度量</h2><ul>
<li>曼哈顿（Manhattan）。</li>
<li>欧几（Euclidean）里得距离。</li>
<li>切比雪夫（Chebyshev）距离。</li>
</ul>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226172043250.png" alt="image-20201226172043250"></p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>分类的任务是对数据集进行学习并构造<strong>一个拥有预测功能的分类模型</strong>，用于预测未知样本的类标号。</p>
<ol>
<li>首先将数据集划分为2部分: <strong>训练集和测试集</strong>。</li>
<li>第一步:对训练集学习，<strong>构建分类模型</strong>。</li>
<li>第二步:用建好的分类模型<strong>对测试集分类</strong>。</li>
<li>最后，使用分类准确度高的分类模型对类标号未知的未来样本数据进行分类。</li>
</ol>
<h2 id="分类方法"><a href="#分类方法" class="headerlink" title="分类方法"></a>分类方法</h2><ul>
<li><strong>基于决策树的分类方法</strong></li>
<li><strong>贝叶斯分类方法</strong></li>
<li><strong>K-最近邻分类方法</strong></li>
<li>神经网络方法</li>
<li>支持向量机方法</li>
<li>集成学习方法</li>
<li>……</li>
</ul>
<h3 id="基于决策树的分类方法"><a href="#基于决策树的分类方法" class="headerlink" title="基于决策树的分类方法"></a>基于决策树的分类方法</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226204310765.png" alt="image-20201226204310765"></p>
<p><strong>注：信息增益越大，说明使用属性A划分后得样本子集越纯，越有利于分类。</strong></p>
<h3 id="贝叶斯分类方法（Bayes）"><a href="#贝叶斯分类方法（Bayes）" class="headerlink" title="贝叶斯分类方法（Bayes）"></a>贝叶斯分类方法（Bayes）</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226204425822.png" alt="image-20201226204425822"></p>
<h3 id="K-最近邻分类方法"><a href="#K-最近邻分类方法" class="headerlink" title="K-最近邻分类方法"></a>K-最近邻分类方法</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226204601861.png" alt="image-20201226204601861"></p>
<h2 id="其他度量指标"><a href="#其他度量指标" class="headerlink" title="其他度量指标"></a>其他度量指标</h2><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226210820366.png" alt="image-20201226210820366"></p>
<h3 id="精度-Precision"><a href="#精度-Precision" class="headerlink" title="精度(Precision)"></a>精度(Precision)</h3><p>正确分类的正例个数占<strong>分类为正例</strong>的样本个数的比例。</p>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226210831124.png" alt="image-20201226210831124"></p>
<h3 id="召回率-Recall"><a href="#召回率-Recall" class="headerlink" title="召回率(Recall)"></a>召回率(Recall)</h3><p>正确分类的正例个数占<strong>实际正例</strong>个数的比例。</p>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226210844810.png" alt="image-20201226210844810"></p>
<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><p>聚类(Clustering)是将数据集划分为若干相似对象组成的多个组(group)或簇(cluster)的过程，使得同一组中对象间的相似度最大化，不同组中对象间的相似度最小化。或者说一个簇(clustc)就是由彼此相似的一组对象所构成的集合，不同簇中的对象通常不相似或相似度很低。</p>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226215550678.png" alt="image-20201226215550678"></p>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201226220917508.png" alt="image-20201226220917508"></p>
<h1 id="关联分析"><a href="#关联分析" class="headerlink" title="关联分析"></a>关联分析</h1><p>发现对象与特征之间相互依赖的关系，通常是从给定的数据集中发现频繁出现的模式知识（又称为关联规则）。关联分析广泛用于市场营销、事务分析等领域。</p>
<h2 id="项集"><a href="#项集" class="headerlink" title="项集"></a>项集</h2><p>在关联分析中，包含0个或多个项的集合，称为项集，一个包含k个数据项的项集称为k-项集。</p>
<h2 id="频繁项集"><a href="#频繁项集" class="headerlink" title="频繁项集"></a>频繁项集</h2><p>一个项集的支持度<strong>大于或等于</strong>某个阈值，则称为频繁项集。</p>
<h2 id="支持度计数"><a href="#支持度计数" class="headerlink" title="支持度计数"></a>支持度计数</h2><p>一个项集的出现次数就是整个交易数据集中包含该项集的事务数，也称为该项集的支持度计数。</p>
<h2 id="支持度"><a href="#支持度" class="headerlink" title="支持度"></a>支持度</h2><p>一个项集的出现次数与数据集所有事务数的百分比称为该项集的支持度。</p>
<p>support(A -&gt; B) = support_count(A ∪ B) / N; (N表示数据集的事务数)</p>
<h2 id="置信度"><a href="#置信度" class="headerlink" title="置信度"></a>置信度</h2><p>置信度是一个数据集中包含A事务同时包含B事务的百分比，置信度确定B在包含A事务中出现的频繁程度，表示规则在数据集上的可靠性。</p>
<p>confidence(A-&gt;B) = support_count(A ∪ B) / support_count(A);</p>
<h2 id="强关联规则"><a href="#强关联规则" class="headerlink" title="强关联规则"></a>强关联规则</h2><p><strong>大于</strong>最<strong>小支持度阈值</strong>和最<strong>小置信度阈值</strong>的关联规则称为强关联规则。</p>
<h2 id="提升度"><a href="#提升度" class="headerlink" title="提升度"></a>提升度</h2><p>提升度（lift）是一种简单的相关度量。对于项集A和项集B，如果P(A ∪B) = P(A)P(B)，则A和B相互独立，否则存在某种依赖关系关联规则的前件项集A和后件项集B之间的<strong>依赖关系通过提升度计算</strong>。提升度可以评估项集A的出现是否能够促进项集B的出现。</p>
<p>lift(A,B) = confidence(A-&gt;B)/support(B);</p>
<p>lift(A,B) &gt; 1 ，表示A，B正相关。</p>
<p>lift(A,B) &lt; 1， 表示A， B负相关。</p>
<p>lift(A,B) = 1，表示A，B无关系。</p>
<h1 id="离群点挖掘"><a href="#离群点挖掘" class="headerlink" title="离群点挖掘"></a>离群点挖掘</h1><h2 id="离群点"><a href="#离群点" class="headerlink" title="离群点"></a>离群点</h2><p>离群点代表着数据集中少数“与众不同”的点。</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>发现与大部分其他对象显著不同的对象，大部分数据挖掘方法都将这种差异信息视为噪声而丢弃。然而在一些应用中，<strong>罕见的数据可能蕴含着更大的研究价值。</strong>离群点挖掘就是<strong>分析数据并及时发现异常</strong>，比如:<strong>及时发现欺诈行</strong>为并采集必要措施，从而避免损失!</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>欺诈检查</li>
<li>天机预报</li>
<li>公共安全</li>
<li>医疗</li>
<li>入侵检测</li>
<li>电子商务</li>
</ul>
<h2 id="研究的主要问题"><a href="#研究的主要问题" class="headerlink" title="研究的主要问题"></a>研究的主要问题</h2><p>离群点挖掘就是通过某种方法<strong>找出</strong>数据集中“与众不同”的数据。</p>
<p>定义：如何定义和度量离群点。</p>
<p>方法：①基于统计的方法。②基于距离的方法。③基于密度的方法。</p>
<h3 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h3><p>离群点定义：一个点远离数据集中大部分点，就认为它是离群点。</p>
<p>离群点挖掘：定义一种度量方式，找出远离数据集中大部分点的数据点。</p>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201227165954007.png" alt="image-20201227165954007"></p>
<p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201227165857067.png" alt="image-20201227165857067"></p>
<h3 id="基于相对密度的方法"><a href="#基于相对密度的方法" class="headerlink" title="基于相对密度的方法"></a>基于相对密度的方法</h3><p><img src="/2020/12/26/%E5%A4%A7%E5%AD%A6%E5%A4%8D%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/image-20201227164020839.png" alt="image-20201227164020839"></p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>大学科目复习</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>IP地址是<a href="https://baike.baidu.com/item/IP%E5%8D%8F%E8%AE%AE/131947">IP协议</a>提供的一种统一的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F/53569124">地址格式</a>，它为互联网上的每一个网络和每一台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA/455151">主机</a>分配一个<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/3283849">逻辑地址</a>，以此来屏蔽<a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2901583">物理地址</a>的差异。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>每一类地址都由两个固定长度的字段组成，其中一个字段是网络号<strong>net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号<strong>host-id</strong>，它标志该主机（或路由器）。</p>
<p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201206132449004.png" alt="image-20201206132449004"></p>
<p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201206132458995.png" alt="image-20201206132458995"></p>
<h3 id="各类-IP-地址的网络号字段和主机号字段"><a href="#各类-IP-地址的网络号字段和主机号字段" class="headerlink" title="各类 IP 地址的网络号字段和主机号字段"></a><strong>各类</strong> <strong>IP</strong> <strong>地址的网络号字段和主机号字段</strong></h3><p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20201206132538023.png" alt="image-20201206132538023"></p>
<h3 id="各类网络号范围"><a href="#各类网络号范围" class="headerlink" title="各类网络号范围"></a>各类网络号范围</h3><ul>
<li>A类0.0.0.0到127.255.255.255</li>
<li>B类128.0.0.0到191.255.255.255</li>
<li>C类192.0.0.0到223.255.255.255</li>
<li>D类224.0.0.0到239.255.255.255</li>
<li>E类240.0.0.0到247.255.255.255</li>
</ul>
<p>注：IP地址的host-id全为0表示网络地址，全为1表示广播地址。</p>
<h3 id="IPv4-IPv6"><a href="#IPv4-IPv6" class="headerlink" title="IPv4/IPv6"></a>IPv4/IPv6</h3><p>IPv4占32位（4字节）。</p>
<p>IPv6占128位（16字节）。</p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><a href="https://blog.csdn.net/qq_26442553/article/details/82761882">链接</a></p>
<p><a href="https://blog.51cto.com/u_6930123/2112748">子网掩码详解</a></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP各版本区别"><a href="#HTTP各版本区别" class="headerlink" title="HTTP各版本区别"></a>HTTP各版本区别</h3><p><strong>HTTP1.0</strong></p>
<ol>
<li>缓存处理：使用header里的If-Modified-Since,Expires（本地时间不准确时不可靠）作为缓存判断标准。</li>
<li>短连接：每次请求都需要三次握手和四次挥手。TCP连接无法复用。</li>
</ol>
<p><strong>HTTP1.1</strong></p>
<ol>
<li>缓存处理：新增Entity tag，If-Unmodified-Since, If-Match,If-None-Match，cache-control等更多头部字段。</li>
<li>Host头域：在1.0中认为每台服务器绑定唯一一个IP，因此没有传递主机名。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多台虚拟主机，多个虚拟主机共享一个IP。在HTTP1.1中所有请求和响应消息都应该带有Host头域，否则报400错误。</li>
<li>范围请求（range）：请求头部引入range头域，允许只请求资源的一部分响应码是206。节约了网络带宽资源。</li>
<li>错误状态码：新增24个错误状态码，如409（Conflict）表示请求资源与资源的当前状态发送冲突；410（Gone）表示服务器上某个资源被永久删除。</li>
<li>长连接：默认开启Connection：keep-alive，允许一个TCP连接上可以传递多个HTTP请求和响应。<strong>降低建立和关闭TCP连接的消耗和延迟</strong>。（注： 浏览器最多为每一个域名维护了6个TCP连接）。</li>
</ol>
<p><strong>HTTP2.0</strong></p>
<ol>
<li><p>多路复用：多个请求复用一条TCP连接，解决了HOL（下面有介绍）问题，降低了延迟同时提高了带宽的利用率。</p>
</li>
<li><p>请求优先级：可以为请求设置优先级，解决某些关键资源请求被阻塞问题（ 共享TCP连接引发的TCP队头阻塞问题）。</p>
</li>
<li><p>头部压缩： 通讯双方各自缓存一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
</li>
<li><p>服务端推送：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p>
</li>
<li><p>数据格式：HTTP2.0采用二进制格式传输。</p>
</li>
</ol>
<p><a href="https://www.cnblogs.com/heluan/p/8620312.html">HTTP1.0/1.1/2.0区别</a></p>
<p>注：</p>
<p>HTTP/1.1协议的长连接有两种工作方式，即非流水线方式(without pipelining)和流水线方式(with pipelining)。</p>
<ul>
<li>非流水线方式在收到前一个响应后才能发出下一个请求。因此，在TCP连接已建立后，客户每访问一次对象都要用去一个往返时间RTT。这比非持续连接要用去两倍RTT的开销，节省了建立TCP连接所需的一个RTT时间。但非流水线方式还是有缺点的，因为服务器在发送完一个对象后，其TCP连接就处于空闲状态，浪费了服务器资源。</li>
<li>流水线方式的特点，是客户在收到HTTP的响应报文之前就能够接着发送新的请求报文。于是一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。因此，使用流水线方式时，客户访问所有的对象只需花费一个RTT时间。流水线工作方式使TCP连接中的空闲时间减少，提高了下载文档效率。</li>
</ul>
<h3 id="HTTP-1-1流水线-和-HTTP-2多路复用区别"><a href="#HTTP-1-1流水线-和-HTTP-2多路复用区别" class="headerlink" title="HTTP / 1.1流水线 和 HTTP / 2多路复用区别"></a>HTTP / 1.1流水线 和 HTTP / 2多路复用区别</h3><p>HTTP / 1.1流水线操作仍然要求按请求的顺序完整地返回请求。</p>
<p>HTTP / 2允许将请求响应拆分为块并以混合的方式返回，从而避免<strong>行头阻塞</strong>（Head of line【HOL】通常是指每个浏览器/客户端与服务器的连接数量有限，并且对其中一个连接进行新请求必须先等待这些连接完成，然后才能完成行首请求阻止后续请求。HTTP / 2通过引入多路复用来解决此问题，以便发出新的请求）。 </p>
<p><strong>TCP队头阻塞行</strong> HTTP / 2仍然受到影响来自另一种HOL，即TCP级别。 TCP流中一个丢失的数据包使，使窗口停止，流一直等待，直到重新发送和接收该包为止。HTTP / 3正在通过QUIC协议（UDP实现）来解决该HOL问题。</p>
<h3 id="详细知识链接"><a href="#详细知识链接" class="headerlink" title="详细知识链接"></a>详细知识链接</h3><p><a href="https://www.kancloud.cn/spirit-ling/http-study/1412541">基础知识</a></p>
<p><a href="https://blog.csdn.net/sinat_34166518/article/details/83584910">HTTP头部</a></p>
<p><a href="https://blog.csdn.net/xiaoming100001/article/details/81109617">HTTP和HTTPS协议</a></p>
<p><a href="https://segmentfault.com/a/1190000021559557?utm_source=sf-related">HTTPS连接过程</a></p>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">http的三次握手与四次挥手</a></p>
<p><a href="https://blog.csdn.net/xiaofei0859/article/details/6044694">MSL（Maximum Segment Lifetime报文最大生存时间）</a></p>
<p><a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么</a></p>
<p><a href="https://www.cnblogs.com/gotodsp/p/6366163.html">HTTP长连接与短连接，实质上是TCP的长连接</a></p>
<p><a href="https://www.cnblogs.com/chenqf/p/6386163.html#!comments">Http缓存原理</a></p>
<p><a href="https://blog.csdn.net/u012375924/article/details/82806617">Cache-Control</a></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统），是一项用于管理和解析域名与 IP 地址对应关系的技术，能够将域名或 IP 地址，自动查找与之匹配，即将域名解析为 IP地址（正向解析），或将 IP 地址解析为域名（反向解析）。</p>
<h3 id="DNS服务器类型"><a href="#DNS服务器类型" class="headerlink" title="DNS服务器类型"></a>DNS服务器类型</h3><ul>
<li>主服务器：在特定区域内具有唯一性，负责维护该区域内的域名与 IP 地址之间的对应关系。</li>
<li>从服务器：从主服务器中获得域名与 IP 地址的对应关系并进行维护，以防主服务器宕机等情况。 </li>
<li>缓存服务器：通过向其他域名解析服务器查询获得域名与 IP 地址的对应关系，并将经常查询的域名信息保存到服务器本地，以此来提高重复查询时的效率。</li>
</ul>
<h3 id="解析结构"><a href="#解析结构" class="headerlink" title="解析结构"></a>解析结构</h3><p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211125154045528.png" alt="image-20211125154045528"></p>
<h3 id="域名查找过程"><a href="#域名查找过程" class="headerlink" title="域名查找过程"></a>域名查找过程</h3><p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20211125153556332.png" alt="image-20211125153556332"></p>
<p><a href="https://blog.csdn.net/jin970505/article/details/78982151">参考链接</a></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h3><p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210507155107561.png" alt="image-20210507155107561"></p>
<p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20210507155204022.png" alt="image-20210507155204022"></p>
<p><a href="https://zhuanlan.zhihu.com/p/103000747">参考链接</a></p>
<p><a href="https://blog.csdn.net/jun2016425/article/details/81506353">TCP三次握手详解</a></p>
<p><a href="https://blog.csdn.net/sinat_36629696/article/details/80740678?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">TCP详解</a></p>
<p><a href="https://javazhiyin.blog.csdn.net/article/details/115222350">TCP十连问</a></p>
<p><a href="https://blog.csdn.net/qq_41431406/article/details/97926927">拥塞控制</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/53013410">拥塞控制算法从BIC到CUBIC</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/52962727">BBR算法与Reno/CUBIC的对比</a></p>
<p><a href="http://www.cnhalo.net/2016/08/13/linux-bic-cubic/">linux内核bic和cubic实现</a></p>
<p><a href="https://blog.csdn.net/whgtheone/article/details/80983882">快重传</a></p>
<p><a href="https://blog.csdn.net/dog250/article/details/52830576?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&dist_request_id=1329187.24397.16179784043723733&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">BBR</a></p>
<p><a href="https://www.cnblogs.com/heyonggang/p/3386415.html">TCP各状态接收报文情况</a></p>
<p><a href="https://blog.csdn.net/chengqiuming/article/details/90316195">TCP交互详解</a></p>
<p><a href="https://blog.csdn.net/qq_31967569/article/details/90673732">ICMP</a></p>
<h3 id="TCP的keep-alive"><a href="#TCP的keep-alive" class="headerlink" title="TCP的keep-alive"></a>TCP的keep-alive</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -a | grep keepalive</span><br><span class="line"></span><br><span class="line">// 每隔 7200 s 检测一次</span><br><span class="line">net.ipv4.tcp_keepalive_time = 7200</span><br><span class="line">// 一次最多重传 9 个包，也就是总共发送10次没响应就断开连接</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 9</span><br><span class="line">// 每个包的间隔重传间隔 75 s</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 75</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可直接在Linux的/proc/sys/net/ipv4/目录下查看</span></span><br><span class="line">[root ipv4]<span class="comment">#  cat /proc/sys/net/ipv4/tcp_keepalive_time</span></span><br><span class="line">7200</span><br><span class="line">[root ipv4]<span class="comment"># cat /proc/sys/net/ipv4/tcp_keepalive_probes</span></span><br><span class="line">9</span><br><span class="line">[root ipv4]<span class="comment">#  cat /proc/sys/net/ipv4/tcp_keepalive_intvl </span></span><br><span class="line">75</span><br></pre></td></tr></table></figure>

<p><a href="https://zhuanlan.zhihu.com/p/224595048">详细链接</a></p>
<h3 id="TCP-Reset报文使用场景"><a href="#TCP-Reset报文使用场景" class="headerlink" title="TCP Reset报文使用场景"></a>TCP Reset报文使用场景</h3><ol>
<li>客户端尝试给未提供服务的端口建立TCP连接，服务端会回应reset报文</li>
<li>服务端接收到报文后，发现该TCP报文<span style="color:red">不在已建立的TCP连接列表中（当前主机已重启）， </span>则直接向客户端发送Reset报文。</li>
<li>在通讯过程中一方突然发送异常（如：程序崩溃），这一方会给对方发送Reset报文使其释放连接。</li>
<li>超时重传超过阈值后，会主动发送Reset报文释放连接（如：服务端TCP三次握手一直未收到确认，重传二次握手）。</li>
<li>有些应用利用<span style="color:red">Reset </span>报文以达速释放TCP连接的，提高TCP释放效率。</li>
</ol>
<h3 id="一个端口可以建立多个TCP连接"><a href="#一个端口可以建立多个TCP连接" class="headerlink" title="一个端口可以建立多个TCP连接"></a>一个端口可以建立多个TCP连接</h3><p><a href="https://blog.csdn.net/tianxiawuzhei/article/details/51086555?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-4.control">参考链接</a></p>
<p><a href="https://blog.lilydjwg.me/2015/8/19/tcp-fun.180084.html">参考链接</a></p>
<p><a href="https://blog.51cto.com/yaocoder/1312821">参考链接</a></p>
<h2 id="网络协议、socket、webSocket"><a href="#网络协议、socket、webSocket" class="headerlink" title="网络协议、socket、webSocket"></a><a href="https://blog.csdn.net/yjclsx/article/details/80922951?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161477445216780264030367%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161477445216780264030367&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-80922951.first_rank_v2_pc_rank_v29&utm_term=websocket%E6%B7%B1%E5%85%A5">网络协议、socket、webSocket</a></h2><p><a href="https://blog.csdn.net/frank_good/article/details/50856585">webSocket原理</a></p>
<h3 id="webSocket数据帧"><a href="#webSocket数据帧" class="headerlink" title="webSocket数据帧"></a>webSocket数据帧</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (<span class="keyword">if</span> payload len==126/127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, <span class="keyword">if</span> payload len == 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, <span class="keyword">if</span> MASK <span class="built_in">set</span> to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">详情</a></p>
<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20190324093704786.png" alt="TCP报文" style="zoom:150%;">

<h3 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h3><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6-1911111249535K.png" alt="UDP报文" style="zoom:200%;">



<h3 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h3><p><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/20160216233020326.png" alt="IP报文"></p>
<h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/d695563104ebf6a7d481be9fffee1c324a184f26.gif" alt="HTTP报文" style="zoom:150%;">





<h2 id="各层网络协议"><a href="#各层网络协议" class="headerlink" title="各层网络协议"></a>各层网络协议</h2><img src="/2021/04/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/各层协议.png" style="zoom:150%;">



<h2 id="其他扩展知识"><a href="#其他扩展知识" class="headerlink" title="其他扩展知识"></a>其他扩展知识</h2><h3 id="打洞"><a href="#打洞" class="headerlink" title="打洞"></a>打洞</h3><p><a href="https://blog.csdn.net/Tornado1102/article/details/76093884">打洞原理及应用</a></p>
<p><a href="https://www.jianshu.com/p/aac3bac7f8e0">NAT穿透，UDP打洞</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>打包vue项目部署到Nginx</title>
    <url>/2020/10/19/%E9%83%A8%E7%BD%B2/%E6%89%93%E5%8C%85vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0nginx/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    <strong>前后端分离，前后端项目往往分开部署，有的甚至部署到不同的服务器，大二的软件工程团队作业项目强后端分离，下面讲下用Nginx部署Vue项目及遇到的坑。</strong></p>
<h2 id="Vue项目打包"><a href="#Vue项目打包" class="headerlink" title="Vue项目打包"></a>Vue项目打包</h2><p><strong>打开命令行进入项目根目录</strong></p>
<p><strong>注：本机需先安装<a href="https://nodejs.org/en/">NodeJS</a></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装项目所需模块</span></span><br><span class="line">npm install </span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">npm run serve</span><br><span class="line"><span class="comment">#打包项目 ,该指令执行后会生成一个dist目录（存放项目的静态文件）</span></span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p><strong>将整个dist目录上传到服务器</strong></p>
<h2 id="Nginx环境搭建"><a href="#Nginx环境搭建" class="headerlink" title="Nginx环境搭建"></a>Nginx环境搭建</h2><p><strong>这里使用docker的Nginx镜像快速搭建。</strong></p>
<p><strong>连接云服务器，命令行输入如下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从Docker Hub查找镜像</span></span><br><span class="line"><span class="comment">#docker search [OPTIONS] TERM</span></span><br><span class="line"><span class="comment">#--automated :只列出 automated build类型的镜像；</span></span><br><span class="line"><span class="comment">#--no-trunc :显示完整的镜像描述；</span></span><br><span class="line"><span class="comment">#-s :列出收藏数不小于指定值的镜像。</span></span><br><span class="line">docker search -s 100 nginx <span class="comment">#从Docker Hub查找所有镜像名包含nginx，并且收藏数大于1000的镜像</span></span><br><span class="line">INDEX       NAME             DESCRIPTION                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/nginx  Official build of Nginx.        13876     [OK]       </span><br><span class="line"><span class="comment">#参数说明：</span></span><br><span class="line"><span class="comment">#NAME: 镜像仓库源的名称</span></span><br><span class="line"><span class="comment">#DESCRIPTION: 镜像的描述</span></span><br><span class="line"><span class="comment">#OFFICIAL: 是否 docker 官方发布</span></span><br><span class="line"><span class="comment">#stars: 类似 Github 里面的 star，表示点赞、喜欢的意思。</span></span><br><span class="line"><span class="comment">#AUTOMATED: 自动构建。 </span></span><br><span class="line"></span><br><span class="line">docker pull nginx <span class="comment">#拉取镜像，默认最新版</span></span><br><span class="line"></span><br><span class="line">docker images <span class="comment">#列出本机镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个新的容器并运行 （--volume , -v: 绑定一个卷，相当于将容器相应路径映射到服务器上）--name=&quot;&quot;: 为容器指定一个名称</span></span><br><span class="line">docker run --name nginx -p 本机端口:容器端口（nginx默认80） -d （后台运行）</span><br><span class="line">-v ……/nginx.conf（服务器配置文件路径）:/etc/nginx/nginx.conf（容器配置文件路径） </span><br><span class="line">-v ……/dist（前端打包文件上传路径）:/usr/share/nginx/html（容器内部目录） nginx:latest （镜像名或id）</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p><strong>注：此处若未配置 try_files $uri $uri/ /index.html;项目除根路径外刷新后会直接报404，下面有说明</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ……/nginx.conf(服务器上映射的配置文件)</span><br><span class="line"><span class="comment">#找到80端口的server模块</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  【你的域名或ip】;</span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/share/nginx/html; <span class="comment">#根路径</span></span><br><span class="line"><span class="comment">#	    proxy_pass http://127.0.0.1:8080</span></span><br><span class="line">            index  index.html index.htm; <span class="comment">#首页</span></span><br><span class="line">                 </span><br><span class="line">           try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html; <span class="comment">#方法1</span></span><br><span class="line">       <span class="comment"># try_files $uri $uri/ =404;</span></span><br><span class="line">	   <span class="comment"># try_files $uri $uri/ @router; #方法2</span></span><br><span class="line">	   <span class="comment">#参数: $uri</span></span><br><span class="line">       <span class="comment">#解释: 表示当前请求的URI(域名后的内容),不带任何参数 例如访问: http://localhost/about</span></span><br><span class="line">       <span class="comment">#$uri: &quot;/about&quot;</span></span><br><span class="line">       <span class="comment">#第一个参数$uri Nginx首先会查找/下有没有名为$uri的文件，本例中为名为demo的文件，如有则将请求传递给$uri</span></span><br><span class="line">       <span class="comment">#第二个参数$uri/ 如找不到名为$uri的文件，Nginx接着会查找/下有没有名为$uri的文件夹，本例中为名为about的文件			夹，如有则将请求传递给$uri/ ，访问该文件夹下的index</span></span><br><span class="line">       <span class="comment"># 第三个参数 </span></span><br><span class="line">       		<span class="comment">#= 404 如前两个参数都无法接收请求 就返回状态码404</span></span><br><span class="line">	   		<span class="comment">#若是路径，则访问，本例是请求http://ip:80/index.html	</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	<span class="comment">#之所以出现刷新404的现象，是因为在nginx配置的根目录 /usr/share/nginx/html下面压根没有&#x27;about/find&#x27;这个真实资源存	在，这些访问资源都是在js里渲染的</span></span><br><span class="line">	<span class="comment">#在服务端nginx配置里添加vue-route的跳转设置</span></span><br><span class="line">	<span class="comment">#location @router &#123;</span></span><br><span class="line">        <span class="comment">#	rewrite ^.*$ /index.html last;</span></span><br><span class="line">   	<span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">	location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>改完后保存退出。</strong></p>
<p><strong>执行docker restart nginx 重启容器后配置生效</strong></p>
<p><strong>到此部署结束</strong></p>
<h3 id="扩展Nginx热加载"><a href="#扩展Nginx热加载" class="headerlink" title="扩展Nginx热加载"></a>扩展Nginx热加载</h3><p><strong>docker exec -it nginx /bin/bash 进入容器，执行 service nginx  reload  按ctrl+P+Q退出容器</strong></p>
<p><strong>或者直接docker exec -i nginx（容器名） service nginx reload （执行命令）</strong></p>
<h2 id="Nginx指令（Windows）"><a href="#Nginx指令（Windows）" class="headerlink" title="Nginx指令（Windows）"></a>Nginx指令（Windows）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">start nginx</span><br><span class="line"><span class="comment">#重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="comment">#关闭，stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。</span></span><br><span class="line">nginx -s stop</span><br><span class="line">nginx -s quit</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure>





<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>bug</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常见指令笔记</title>
    <url>/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="查看内存CPU使用情况-Top"><a href="#查看内存CPU使用情况-Top" class="headerlink" title="查看内存CPU使用情况 Top"></a>查看内存CPU使用情况 Top</h2><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20201201160508354.png" alt="image-20201201160508354">

<h4 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h4><p>当前时间16：04：49</p>
<p>系统已运行时间 188天4小时32分</p>
<p>当前登陆用户数 1个user</p>
<p>负载情况 load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p>
<h4 id="第二行："><a href="#第二行：" class="headerlink" title="第二行："></a>第二行：</h4><p>  Tasks（ 任务/进程）100个进程，其中处于运行中的有1个，99个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p>
<h4 id="第三行：cpu状态"><a href="#第三行：cpu状态" class="headerlink" title="第三行：cpu状态"></a>第三行：cpu状态</h4><p> us — 用户空间占用CPU的百分比。</p>
<p> sy — 内核空间占用CPU的百分比。</p>
<p> ni — 改变过优先级的进程占用CPU的百分比。</p>
<p> id — 空闲CPU百分比。</p>
<p> wa — IO等待占用CPU的百分比。</p>
<p> hi — 硬中断（Hardware IRQ）占用CPU的百分比。</p>
<p> si — 软中断（Software Interrupts）占用CPU的百分比 。</p>
<p> st — 被虚拟机偷走的cpu。</p>
<h4 id="第四行：内存状态"><a href="#第四行：内存状态" class="headerlink" title="第四行：内存状态"></a>第四行：内存状态</h4><p> total — 物理内存总量。</p>
<p> used — 使用中的内存总量。</p>
<p> free — 空闲内存总量。</p>
<p> buffers — 缓存的内存量 。</p>
<h4 id="第五行：swap交换分区"><a href="#第五行：swap交换分区" class="headerlink" title="第五行：swap交换分区"></a>第五行：swap交换分区</h4><p>total — 交换区总量。</p>
<p>used — 使用的交换区总量。</p>
<p>free — 空闲交换区总量。</p>
<p>cached — 缓冲的交换区总量。</p>
<h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>PID — 进程id。</p>
<p>USER — 进程所有者。</p>
<p>PR — 进程优先级。</p>
<p>NI — nice值。负值表示高优先级，正值表示低优先级。</p>
<p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES。</p>
<p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA。</p>
<p>SHR — 共享内存大小，单位kb。</p>
<p> S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程。</p>
<p>%CPU — 上次更新到现在的CPU时间占用百分比。</p>
<p>%MEM — 进程使用的物理内存百分比。</p>
<p>TIME+ — 进程使用的CPU时间总计，单位1/100秒。</p>
<p>COMMAND — 进程名称（命令名/命令行）。</p>
<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><ul>
<li>b: 打开/关闭高亮效果。</li>
<li>x:打开/关闭排序列高亮效果。</li>
<li>shift + ‘&lt;’  或  ‘&gt;’ 向左向右改变排序列。</li>
<li>e修改进程列表单位显示，E修改前五行单位显示信息。</li>
</ul>
<h3 id="top-H-p-进程id-查看某进程的线程信息"><a href="#top-H-p-进程id-查看某进程的线程信息" class="headerlink" title="top -H -p [进程id] 查看某进程的线程信息"></a>top -H -p [进程id] 查看某进程的线程信息</h3><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,相比top，通过vmstat可以看到<strong>整个机器的 CPU</strong>，内存,IO的使用情况， 而不是单单看到各个进程的CPU使用率和内存使用率。</p>
<p>注：功能类似指令：sar、mpstat、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> vmstat [采样的时间间隔数(单位是秒)] [采样的次数(不写一直执行下去)]</span><br><span class="line"> procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs  us sy id wa st</span><br><span class="line"> 1  0      0 133908 298732 1127320    0    0     0     2    0    1  0  0 99  0  0</span><br><span class="line"><span class="comment"># 进程</span></span><br><span class="line">r：在运行队列中进程数 。当这个值超过了CPU数目，就会出现CPU瓶颈 了。</span><br><span class="line">b：在等待io的进程数 。</span><br><span class="line"><span class="comment"># 内存</span></span><br><span class="line">swpd：现时可用的交换内存（单位KB）。 </span><br><span class="line">free：空闲的内存（单位KB）。</span><br><span class="line">buff: 缓冲中的内存数（单位：KB）。</span><br><span class="line">cache：被用来做为高速缓存的内存数（单位：KB）。</span><br><span class="line"><span class="comment"># swap交换页</span></span><br><span class="line">si: 从磁盘交换到内存的交换页数量，单位：KB/秒。</span><br><span class="line">so: 从内存交换到磁盘的交换页数量，单位：KB/秒。</span><br><span class="line"><span class="comment"># io设备</span></span><br><span class="line">bi: 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，单位：块/秒。</span><br><span class="line">bo: 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0，单位：块/秒。</span><br><span class="line"><span class="comment"># 系统</span></span><br><span class="line"><span class="keyword">in</span>: cpu每秒的中断数，包括时钟中断。</span><br><span class="line">cs: 每秒的环境（上下文）转换次数。</span><br><span class="line"><span class="comment">#CPU 一般来说，id + us + sy = 100</span></span><br><span class="line">us：用户进程使用的时间占比。</span><br><span class="line">sy：系统进程使用的时间占比。</span><br><span class="line">id：中央处理器的空闲时间占比。</span><br><span class="line">wa：等待IO CPU时间。</span><br><span class="line">st：被虚拟机偷走的cpu。</span><br></pre></td></tr></table></figure>

<h3 id="判断负载情况"><a href="#判断负载情况" class="headerlink" title="判断负载情况"></a>判断负载情况</h3><p>1、假如 r 经常大于4 ，且 id 经常小于40，表示中央处理器的负荷很重。<br>2、假如 bi，bo 长期不等于0，表示物理内存容量太小。</p>
<p><a href="https://blog.csdn.net/wujizhishui/article/details/89333957">参考链接</a></p>
<h2 id="free-h"><a href="#free-h" class="headerlink" title="free -h"></a>free -h</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>查看内存使用使用情况</p>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20201201170143345.png" alt="image-20201201170143345"></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="find-目录-条件-动作"><a href="#find-目录-条件-动作" class="headerlink" title="find [目录] [条件] [动作]"></a>find [目录] [条件] [动作]</h3><p>如 find . -name ‘name*’ 查找当前目录下以name开头的文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment"># find . -name &quot;name*&quot;</span></span><br><span class="line">./node_modules/continuation-local-storage/<span class="built_in">test</span>/namespaces.tap.js</span><br><span class="line">./node_modules/argparse/lib/namespace.js</span><br><span class="line">./node_modules/ast-types/gen/namedTypes.js</span><br><span class="line">./node_modules/ast-types/gen/namedTypes.d.ts</span><br><span class="line">./node_modules/@pm2/js-api/src/namespace.js</span><br></pre></td></tr></table></figure>



<h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，centos7默认没安装，可执行``yum install mlocate` 安装。（注：第一次使用前需执行updatedb）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数</span></span><br><span class="line">-l num（要显示的行数）</span><br><span class="line">-f   将特定的档案系统排除在外，如将proc排除在外</span><br><span class="line">-r   使用正则运算式做为寻找条件</span><br></pre></td></tr></table></figure>

<p>查看与pwd相关的文件（显示4行）</p>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20210416200859278.png" alt="image-20210416200859278"></p>
<p>查找etc目录下sh开头的文件</p>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20210416200733042.png" alt="image-20210416200733042"></p>
<p>查找/etc目录下以dow结尾的文件</p>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20210416195942900.png" alt="image-20210416195942900"></p>
<h3 id="whitch"><a href="#whitch" class="headerlink" title="whitch"></a>whitch</h3><p>在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@~]<span class="comment"># which ps</span></span><br><span class="line">/usr/bin/ps</span><br></pre></td></tr></table></figure>



<h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment"># whereis npm</span></span><br><span class="line">npm: /usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># whereis java</span></span><br><span class="line">java: /usr/java/jdk1.8.0_221/bin/java /usr/java/jdk1.8.0_221/jre/bin/java</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># whereis nodejs</span></span><br><span class="line">nodejs: /usr/<span class="built_in">local</span>/nodejs</span><br></pre></td></tr></table></figure>



<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9 ~]<span class="comment">#  type cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line">[root@iZwz9 ~]<span class="comment">#  type npm</span></span><br><span class="line">npm is /usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment">#  type -p npm</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nodejs/node-v12.16.3-linux-x64/bin/npm</span><br><span class="line">[root@iZwz9 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>



<h2 id="防火墙（CentOS7）"><a href="#防火墙（CentOS7）" class="headerlink" title="防火墙（CentOS7）"></a>防火墙（CentOS7）</h2><h3 id="查看所有开放的端口号"><a href="#查看所有开放的端口号" class="headerlink" title="查看所有开放的端口号"></a><strong>查看所有开放的端口号</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure>

<h3 id="查看指定端口是否已开放"><a href="#查看指定端口是否已开放" class="headerlink" title="查看指定端口是否已开放"></a>查看指定端口是否已开放</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port=6379/tcp</span><br></pre></td></tr></table></figure>

<h3 id="设置开放的端口号"><a href="#设置开放的端口号" class="headerlink" title="设置开放的端口号"></a><strong>设置开放的端口号</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure>

<h3 id="重新加载防火墙"><a href="#重新加载防火墙" class="headerlink" title="重新加载防火墙"></a><strong>重新加载防火墙</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a><strong>启动</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>

<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a><strong>查看状态</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld </span><br></pre></td></tr></table></figure>

<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a><strong>停止</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>

<h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a><strong>禁用</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>



<h2 id="vim编辑常用指令"><a href="#vim编辑常用指令" class="headerlink" title="vim编辑常用指令"></a>vim编辑常用指令</h2><p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20211124151119692.png" alt="image-20211124151119692"></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>5dd</td>
<td>删除（剪切）从光标处开始的 5 行</td>
</tr>
<tr>
<td>5yy</td>
<td>复制从光标处开始的 5 行</td>
</tr>
<tr>
<td>n</td>
<td>显示搜索命令定位到的下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>显示搜索命令定位到的上一个字符串</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作</td>
</tr>
<tr>
<td>p</td>
<td>将之前删除（dd）或复制（yy）过的数据粘贴到光标后面</td>
</tr>
</tbody></table>
<h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:s/one/two</td>
<td>将当前光标所在行的第一个 one 替换成 two</td>
</tr>
<tr>
<td align="left">:s/one/two/g</td>
<td>将当前光标所在行的所有 one 替换成 two</td>
</tr>
<tr>
<td align="left">:%s/one/two/g</td>
<td>将全文中的所有 one 替换成 two</td>
</tr>
<tr>
<td align="left">:?字符串</td>
<td>在文本中从下至上搜索该字符串</td>
</tr>
<tr>
<td align="left">:/字符串</td>
<td>在文本中从上至下搜索该字符串</td>
</tr>
<tr>
<td align="left">:整数</td>
<td>跳转到该行</td>
</tr>
<tr>
<td align="left">:set nu/nonu</td>
<td>显示/不显示行号</td>
</tr>
</tbody></table>
<h2 id="查看磁盘占用空间"><a href="#查看磁盘占用空间" class="headerlink" title="查看磁盘占用空间"></a>查看磁盘占用空间</h2><ul>
<li>df -hl：查看磁盘剩余空间。</li>
<li>df -h：查看每个根路径的分区大小。</li>
<li>du -sh [目录名]：返回该目录的大小。</li>
<li>du -sm [文件夹]：返回该文件夹总数。</li>
<li>du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹）。</li>
</ul>
<h2 id="查看Linux信息"><a href="#查看Linux信息" class="headerlink" title="查看Linux信息"></a>查看Linux信息</h2><p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20210405205233246.png" alt="image-20210405205233246"></p>
<p>uname -a：查看操作系统内核信息。</p>
<p>cat /proc/version ：查看操作系统版本信息。</p>
<p>cat /etc/redhat-release：查看操作系统发行版信息。</p>
<p>getconf LONG_BIT：查看版本说明当前CPU运行在64bit模式下.</p>
<p>cat /proc/cpuinfo：查看cpu相关信息，包括型号、主频、内核信息等。</p>
<h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><ol>
<li>lsof -i : 端口号</li>
</ol>
<p>注：sentos默认没有装（yum install lsof）</p>
<ol start="2">
<li>netstat -tunlp | grep 端口号</li>
</ol>
<ul>
<li>-t (tcp) 仅显示tcp相关选项。</li>
<li>-u (udp)仅显示udp相关选项。</li>
<li>-n 拒绝显示别名，能显示数字的全部转化为数字。</li>
<li>-l 仅列出在Listen(监听)的服务状态。</li>
<li>-p 显示建立相关链接的程序名。</li>
</ul>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E6%8C%87%E4%BB%A4/image-20210405210557631.png" alt="image-20210405210557631"></p>
<h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><p>查看CPU型号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep name | sort | uniq</span><br></pre></td></tr></table></figure>

<p>查看物理CPU数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;physical id&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于显示多个 physical id相等的情况，可用管道进行过滤</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">&quot;physical id&quot;</span> | sort | uniq | wc -l</span><br></pre></td></tr></table></figure>

<p>查看每个物理CPU的核数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep <span class="string">&quot;cpu cores&quot;</span>| uniq</span><br></pre></td></tr></table></figure>

<p>查看逻辑CPU数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo| grep <span class="string">&quot;processor&quot;</span>| wc -l</span><br></pre></td></tr></table></figure>

<p>直接查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure>



<h2 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a>tar指令</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf file1.tar.gz file2 <span class="comment">#压缩file2文件为file1</span></span><br></pre></td></tr></table></figure>

<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf file <span class="comment">#将file文件解压</span></span><br></pre></td></tr></table></figure>

<h3 id="各参数意思："><a href="#各参数意思：" class="headerlink" title="各参数意思："></a>各参数意思：</h3><ul>
<li>-z：通过gzip指令处理备份文件。</li>
<li>-v：显示指令执行过程。</li>
<li>-f：指定备份文件。</li>
<li>-c：建立新的备份文件。</li>
<li>-x：从备份文件中还原文件。</li>
</ul>
<h2 id="查看进程绝对路径"><a href="#查看进程绝对路径" class="headerlink" title="查看进程绝对路径"></a>查看进程绝对路径</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef |grep <span class="comment">#获取进程pid</span></span><br><span class="line">ls -l /proc/&#123;pid&#125;/exe <span class="comment">#exe是程序的一个软连接</span></span><br></pre></td></tr></table></figure>



<h2 id="查看进程内存映射"><a href="#查看进程内存映射" class="headerlink" title="查看进程内存映射"></a>查看进程内存映射</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pmap [参数] [进程ID ]</span><br><span class="line">常用参数：</span><br><span class="line">-x	增加一个标题行，同时显示每个内存映像实际使用的物理内存大小，以及内存已修改但尚未写到磁盘的页面数量等附加进程信息</span><br><span class="line">-d	增加一个标题行，同时显示内存映射文件的偏移值，以及存储设备的主次设备号等附加进程信息</span><br><span class="line">-q	采用安静方式，禁止显示汇总信息行</span><br><span class="line">-V	显示命令的版本信息，然后退出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Address Kbytes RSS Anon Locked Mode Mapping</span><br><span class="line">08047000 596   -   -    -      r-x-- bash</span><br><span class="line">输出参数 解释</span><br><span class="line">Address 进程所占的地址空间</span><br><span class="line">Kbytes 该虚拟段的大小</span><br><span class="line">RSS 设备号（主设备：次设备）</span><br><span class="line">Anon 设备的节点号，0表示没有节点与内存相对应</span><br><span class="line">Locked 是否允许swapped</span><br><span class="line">Mode 权限：r&#x3D;read, w&#x3D;write, x&#x3D;execute, s&#x3D;shared, p&#x3D;private(copy on write)</span><br><span class="line">Mapping 对应的映像文件名</span><br></pre></td></tr></table></figure>

<h2 id="Yum"><a href="#Yum" class="headerlink" title="Yum"></a>Yum</h2><p>Yum 软件仓库可以根据用户的要求分析出所需软件包及其相关的依赖关系，然后自动从服务器下载软件包并安</p>
<p>装到系统。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>yum repolist all</td>
<td>列出所有仓库</td>
</tr>
<tr>
<td>yum list all</td>
<td>列出仓库中所有软件包</td>
</tr>
<tr>
<td>yum info 软件包名称</td>
<td>查看软件包信息</td>
</tr>
<tr>
<td>yum install 软件包名称</td>
<td>安装软件包</td>
</tr>
<tr>
<td>yum einstall 软件包名称</td>
<td>重新安装软件包</td>
</tr>
<tr>
<td>yum update 软件包名称</td>
<td>升级软件包</td>
</tr>
<tr>
<td>yum remove 软件包</td>
<td>移除软件包</td>
</tr>
<tr>
<td>yum clean all</td>
<td>清除所有仓库缓存</td>
</tr>
<tr>
<td>yum check-update</td>
<td>检查可更新的软件包</td>
</tr>
<tr>
<td>yum grouplist</td>
<td>查看系统中已经安装的软件包组</td>
</tr>
<tr>
<td>yum groupinstall 软件包组</td>
<td>安装指定的软件包组</td>
</tr>
<tr>
<td>yum groupremove 软件包组</td>
<td>移除指定的软件包组</td>
</tr>
<tr>
<td>yum groupinfo 软件包组</td>
<td>查询指定的软件包组信息</td>
</tr>
</tbody></table>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p>Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</p>
<p>守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。</p>
<p>一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。</p>
<p><a href="https://blog.csdn.net/ailaojie/article/details/88419010">参考链接</a></p>
<p><a href="https://blog.csdn.net/linkedin_35878439/article/details/81288889?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161830584216780271567766%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161830584216780271567766&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-81288889.first_rank_v2_pc_rank_v29&utm_term=%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">参考链接</a></p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>父进程结束了，而它fork的一个或多个子进程还在运行，那么这些子进程就成为孤儿进程(father died)。孤儿进程一般由init进程(进程号PID = 1)收养。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>子进程退出了，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但仍保留了进程的状态信息（包括进程号，退出状态，运行时间等），需要父进程调用wait或waitpid去获取并释放，如果父进程没有释放子进程，那么子进程的状态信息仍然保存在系统中，进程号也不会释放，这种进程称为僵死进程。</p>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动。</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆。</li>
<li>运行级别2：多用户状态(没有NFS)。</li>
<li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式。</li>
<li>运行级别4：系统未使用，保留。</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式。</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。</li>
</ul>
<p>注：NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。目前NFS主要有两个版本（NFSv2，NFSv3）两个版本，而NFSv2和NFSv3除了3版本支持更多的新特性以外，最主要的区别应该就是NFSv2是使用UDP协议进行传输的，所以NFSv2的连接在复杂网络环境下可能没有那么可靠，而NFSv3同时支持UDP和TCP协议。</p>
<h2 id="启动级别（init-0-6）"><a href="#启动级别（init-0-6）" class="headerlink" title="启动级别（init 0-6）"></a>启动级别（init 0-6）</h2><p>0：停机或者关机</p>
<p>1：单用户模式</p>
<p>2：多用户模式，不能使用NFS(Net File System)</p>
<p>3：完全多用户模式（标准的运行级别）</p>
<p>4：安全模式</p>
<p>5：图形化（即图形界面）</p>
<p>6：重启</p>
<h2 id="Linux启动过程"><a href="#Linux启动过程" class="headerlink" title="Linux启动过程"></a>Linux启动过程</h2><p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%AC%94%E8%AE%B0/image-20211123151300575.png" alt="image-20211123151300575"></p>
<p>Linux启动是从加电 BIOS自检开始，进入到Grub（一个功能强大的多系统引导程序，专门处理Linux与其它操作系统共存的问题）加载bootfs。bootfs主要包括: <strong>bootloader</strong>和 <strong>kernel</strong> （内核)，而bootloader主要用来启动内核。内核其实只有三件工作:</p>
<ol>
<li>探测当前硬件设备：通过硬件中断就可以得知。</li>
<li>根据探测到的硬件设备初始化相关驱动</li>
<li>挂载根文件系统</li>
</ol>
<blockquote>
<p>Linux内核当中只包含最基本的硬件驱动，例如硬盘、键盘、CPU、内存、I/O等，<strong>其他的驱动则放到文件系统当中，由内核根据需求再进行加载</strong>，驱动被放置在文件系统当中，但<strong>内核只有在驱动初始化之后才能挂载文件系统。</strong>为了解决这个“先有鸡还是先有蛋”的问题，Linux引入了initrd 文件。initrd文件全称是 <code>bootloader initialized RAM disk</code>，本质是由bootloader初始化的一个内存文件系统，与initramfs、rootfs、tmpfs等同属ramfs范畴，都是内存文件系统。initrd文件当中包含有:lib、bin、sbin、usr、proc、sys、var、dev、boot等目录，所以我们可以认为 initrd就是一个完整的虚拟根文件系统。initrd文件存在的目的就是为了在<strong>内核态和用户态之间建立一个桥梁</strong>，让内核加载initrd文件系统中的硬件驱动，再通过读写方式挂载用户态的根文件系统。<br>此时Linux启动顺序就变为: bootloader启动内核，并且将 initrd 文件中的内容加载到内存当中。内核就会通过 initrd中所包含的 init脚本完成各种硬件设备的初始化和加载工作，而后内核顺利加载<strong>根文件系统</strong>。这一步做完之后，内核运行根文件系统当中的/sbin/init进程，创建操作系统的<strong>1号进程</strong>，此后内核就会将操作系统控制权移交给用户空间的Init进程，当前环境由内核态转移到了用户态。用户态的 init进程开始读取/etc/inittab脚本来执行相应的脚本，从而完成系统初始化，主要包括:设置时间、设置字体、设置随机数生成器、设置网络、设置防火墙，等等。</p>
</blockquote>
<h2 id="FHS"><a href="#FHS" class="headerlink" title="FHS"></a>FHS</h2><p>文件系统层次化标准（Filesystem Hierarchy Standard）是根据以往无数 Linux 系统用户和开发者的经验而总结出来的，是用户在 Linux 系统中存储文件时需要遵守的规则。</p>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%AC%94%E8%AE%B0/image-20211124160341478.png" alt="image-20211124160341478"></p>
<table>
<thead>
<tr>
<th>目录名称</th>
<th>应放置文件的内容</th>
</tr>
</thead>
<tbody><tr>
<td>/boot</td>
<td>开机所需文件—内核、开机菜单以及所需配置文件等</td>
</tr>
<tr>
<td>/dev</td>
<td>以文件形式存放任何设备与接口</td>
</tr>
<tr>
<td>/etc</td>
<td>配置文件</td>
</tr>
<tr>
<td>/home</td>
<td>用户家目录</td>
</tr>
<tr>
<td>/bin</td>
<td>存放单用户模式下还可以操作的命令</td>
</tr>
<tr>
<td>/lib</td>
<td>开机时用到的函数库，以及/bin 与/sbin 下面的命令要调用的函数</td>
</tr>
<tr>
<td>/sbin</td>
<td>开机过程中需要的命令</td>
</tr>
<tr>
<td>/media</td>
<td>用于挂载设备文件的目录</td>
</tr>
<tr>
<td>/opt</td>
<td>放置第三方的软件</td>
</tr>
<tr>
<td>/root</td>
<td>系统管理员的家目录</td>
</tr>
<tr>
<td>/srv</td>
<td>一些网络服务的数据文件目录</td>
</tr>
<tr>
<td>/tmp</td>
<td>任何人均可使用的“共享”临时目录</td>
</tr>
<tr>
<td>/proc</td>
<td>虚拟文件系统，例如系统内核、进程、外部设备及网络状态等</td>
</tr>
<tr>
<td>/usr/local</td>
<td>用户自行安装的软件</td>
</tr>
<tr>
<td>/usr/sbin Linux</td>
<td>系统开机时不会使用到的软件/命令/脚本</td>
</tr>
<tr>
<td>/usr/share</td>
<td>帮助与说明文件，也可放置共享文件</td>
</tr>
<tr>
<td>/var</td>
<td>主要存放经常变化的文件，如日志</td>
</tr>
<tr>
<td>/lost+found</td>
<td>当文件系统发生错误时，将一些丢失的文件片段存放在这里</td>
</tr>
</tbody></table>
<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p>Linux 把每个文件的权限与属性记录在inode 中，而且每个文件占用一个独立的 inode 表格，该表格的大小默认为 128 字节，里面记录着如下信息：</p>
<ul>
<li>该文件的访问权限（read、write、execute）。</li>
<li>该文件的所有者与所属组（owner、group）。</li>
<li>该文件的大小（size）。</li>
<li>该文件的创建或内容修改时间（ctime）。</li>
<li>该文件的最后一次访问时间（atime）。</li>
<li>该文件的修改时间（mtime）。</li>
<li>文件的特殊权限（SUID、SGID、SBIT）。</li>
<li>该文件的真实数据地址（point）。</li>
</ul>
<p>而文件的实际内容则保存在 block 块中（大小可以是 1KB、2KB 或 4KB），一个 inode 的默认大小仅为 128B（Ext3），记录一个 block 则消耗 4B。当文件的 inode 被写满后，Linux 系统会自动分配出一个 block 块，专门用于像 inode 那样记录其他 block 块的信息，这样把各个block 块的内容串到一起，就能够让用户读到完整的文件内容了。</p>
<h3 id="在-Linux-系统中存在硬链接和软连接两种文件。"><a href="#在-Linux-系统中存在硬链接和软连接两种文件。" class="headerlink" title="在 Linux 系统中存在硬链接和软连接两种文件。"></a>在 Linux 系统中存在硬链接和软连接两种文件。</h3><ul>
<li><strong>硬链接（hard link）</strong></li>
</ul>
<blockquote>
<p>可以将它理解为一个“指向原始文件 inode 的指针”，系统不为它分配独立的 inode 和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的 inode 连接数就会增加 1；而且只有当该文件的 inode 连接数为 0 时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件 inode 的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。</p>
</blockquote>
<ul>
<li><strong>软链接（也称为符号链接[symbolic link]）</strong></li>
</ul>
<blockquote>
<p>仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与 Windows 系统中的“快捷方式”具有一样的性质。</p>
</blockquote>
<h2 id="SSH认证过程"><a href="#SSH认证过程" class="headerlink" title="SSH认证过程"></a>SSH认证过程</h2><blockquote>
<p>前提：客户端使用工具生成一个密钥对并将客户端生成的公钥拷贝到服务器。</p>
</blockquote>
<ol>
<li>当客户端发送登陆请求（包含IP、用户名）。</li>
<li>服务器会在本地的<code>./ssh/authorized_keys</code>中是否有对应用户公钥。</li>
<li>若存在对应用户的公钥则随机生成一个随机数并使用客户端拷贝过来的公钥进行加密，然后发送给客户端。</li>
<li>客户端得到服务器发来的加密随机数后使用私钥进行解密，然后将解密后的随机数发送给服务器。</li>
<li>服务器收到客户端发来的随机数后，与之前其生成的随机数进行对比，如果一致则认证成功。</li>
</ol>
<h2 id="SELinux-安全子系统"><a href="#SELinux-安全子系统" class="headerlink" title="SELinux 安全子系统"></a>SELinux 安全子系统</h2><p>SELinux（Security-Enhanced Linux）是美国国家安全局在 Linux 开源社区的帮助下开发的一个强制访问控制（MAC，Mandatory Access Control）的安全子系统。RHEL 7 系统使用SELinux 技术的目的是为了让各个服务进程都受到约束，使其仅获取到本应获取的资源。例如，在自己的电脑上下载了一个美图软件，当您全神贯注地使用它给照片进行美颜的时候，它却在后台默默监听着浏览器中输入的密码信息，而这显然不应该是它应做的事情。SELinux 安全子系统就是为了杜绝此类情况而设计的，它能够从多方面监控违法行为：对服务程序的功能进行限制（SELinux 域限制可以确保服务程序做不了出格的事情）；对文件资源的访问限制（SELinux 安全上下文确保文件资源只能被其所属的服务程序进行访问）。</p>
<p>SELinux 服务有三种配置模式（持久化配置路径：<code>/etc/selinux/config</code>）</p>
<ul>
<li>enforcing：强制启用安全策略模式，将拦截服务的不合法请求。</li>
<li>permissive：遇到服务越权访问时，只发出警告而不强制拦截。</li>
<li>disabled：对于越权的行为不警告也不拦截。</li>
</ul>
<h3 id="获得当前-SELinux服务的运行模式"><a href="#获得当前-SELinux服务的运行模式" class="headerlink" title="获得当前 SELinux服务的运行模式"></a>获得当前 SELinux服务的运行模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost /]<span class="comment"># getenforce</span></span><br><span class="line">Enforcing</span><br><span class="line"><span class="comment"># 临时禁用SELinux 服务</span></span><br><span class="line">[root@localhost html]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@localhost html]<span class="comment"># getenforce</span></span><br><span class="line">Permissive</span><br><span class="line">[root@localhost html]<span class="comment">#  setenforce --help</span></span><br><span class="line">usage:  setenforce [ Enforcing | Permissive | 1 | 0 ]</span><br></pre></td></tr></table></figure>

<h3 id="查看指定目录安全上下文"><a href="#查看指定目录安全上下文" class="headerlink" title="查看指定目录安全上下文"></a>查看指定目录安全上下文</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost html]<span class="comment"># ls -Zd /var/www/html</span></span><br><span class="line">drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="comment"># -Z Display security context so it fits on most displays.  Displays only mode, user, group,security context and file name.(显示安全上下文，使其适合大多数应用程序,显示。仅显示模式、用户、组、安全上下文和文件名。)</span></span><br><span class="line"><span class="comment"># -d list directories themselves, not their contents(list directories themselves, not their contents)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在文件上设置的 SELinux 安全上下文是由用户段、角色段以及类型段等多个信息项共同组成的。其中，用户段 system_u 代表系统进程的身份，角色段 object_r 代表文件目录的角色，类型段 httpd_sys_content_t 代表网站服务的系统文件。</span></span><br></pre></td></tr></table></figure>

<h3 id="semanage"><a href="#semanage" class="headerlink" title="semanage"></a>semanage</h3><p>semanage 命令用于管理 SELinux 的策略，格式为“semanage [选项] [文件]”。SELinux 服务极大地提升了 Linux 系统的安全性，将用户权限牢牢地锁在笼子里。semanage 命令不仅能够像传统 chcon 命令那样—设置文件、目录的策略，还可以管理网络端口、消息接口（这些新特性将在本章后文中涵盖）。使用 semanage 命令时，经常用到的几个参数及其功能如下所示：</p>
<ul>
<li>-l 参数用于查询。</li>
<li>-a 参数用于添加。</li>
<li>-m 参数用于修改。</li>
<li>-d 参数用于删除。</li>
</ul>
<p>例：向httpd服务网站数据目录中新添加一条 SELinux 安全上下文，让<code>/home/wwwroot</code>目录以及里面的所有文件能够被 httpd 服务程序所访问到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost html]<span class="comment"># semanage fcontext -a -t httpd_sys_content_t /home/wwwroot </span></span><br><span class="line">[root@localhost html]<span class="comment"># semanage fcontext -a -t httpd_sys_content_t /home/wwwroot/* </span></span><br><span class="line"><span class="comment">##注意，执行上述设置之后，还无法立即访问网站，还需要使用 restorecon 命令将设置好的 SELinux 安全上下文立即生效。在使用 restorecon 命令时，可以加上-Rv 参数对指定的目录进行递归操作，以及显示 SELinux 安全上下文的修改过程。</span></span><br><span class="line">[root@localhost html]<span class="comment"># restorecon -Rv /home/wwwroot/ </span></span><br><span class="line">restorecon reset /home/wwwroot context unconfined_u:object_r:home_root_t:s0-&gt; unconfined_u:object_r:httpd_sys_content_t:s0 </span><br><span class="line">restorecon reset /home/wwwroot/index.html context unconfined_u:object_r:home_root_t:s0-&gt;unconfined_u:object_r:httpd_sys_content_t:s0 </span><br></pre></td></tr></table></figure>



<h2 id="文件存储结构"><a href="#文件存储结构" class="headerlink" title="文件存储结构"></a>文件存储结构</h2><p>Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。</p>
<p><strong>目录项</strong>:  包括文件名和inode节点号。</p>
<p><strong>inode</strong>：文件索引节点，包含文件的属性(如读写属性、owner等，以及指向数据块的指针)。</p>
<p><strong>数据块</strong>：文件的具体内容存放地。</p>
<p><img src="/2020/12/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Linux%E7%AC%94%E8%AE%B0/71b142e7-2d50-37e9-bdba-340a60afca43.png" alt="img"></p>
<p><a href="https://blog.csdn.net/github_37882837/article/details/90672881">参考链接</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Linux就该这么学》</p>
<h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p><a href="https://blog.csdn.net/ThinkWon/article/details/104588679?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161833384316780265478622%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161833384316780265478622&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-1-104588679.first_rank_v2_pc_rank_v29&utm_term=linux%E9%9D%A2%E8%AF%95%E9%A2%98">参考链接1</a></p>
<p><a href="https://blog.csdn.net/a303549861/article/details/93754526">参考链接2</a></p>
<p><a href="https://www.linuxprobe.com/">linux学习网站</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存管理</title>
    <url>/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>为了方便自主管理内存，会先向系统申请一块内存，然后将内存切割成小块，通过一定的内存分配算法管理内 存。以64位系统为例，Golang程序启动时会向系统申请的内存如下图所示：</p>
<p><img src="/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211116215313520.png" alt="image-20211116215313520"></p>
<ul>
<li>arena为堆区，应用中需要的内存从这里分配，大小为512G，为了方便管理把arena区域划分成一个个的page，每个page为8KB,一共有512GB/8KB个页。</li>
<li>spans区域存放span的指针，每个指针对应一个page，所以span区域的大小为(512GB/8KB)*指针大小8byte = 512M </li>
<li>bitmap区域大小也是通过arena计算出来，不过主要用于GC。 </li>
</ul>
<h2 id="span"><a href="#span" class="headerlink" title="span"></a>span</h2><p>span是<strong>内存管理的基本单位</strong>, 是用于<strong>管理arena页</strong>的关键数据结构，每个span中包含1个或多个连续页，为了满足小对象分配，span中的一页会划分更小的粒度，而对于大对象比如超过页大小，则通过多页实现。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>跟据对象大小，划分了一系列class，每个class都代表一个固定大小的对象，以及每个span的大小。如下表所示： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class  bytes/obj  bytes/span  objects  waste bytes</span></span><br><span class="line"><span class="comment">//     1          8        8192     1024            0</span></span><br><span class="line"><span class="comment">//     2         16        8192      512            0</span></span><br><span class="line"><span class="comment">//     3         32        8192      256            0</span></span><br><span class="line"><span class="comment">//     4         48        8192      170           32</span></span><br><span class="line"><span class="comment">//     5         64        8192      128            0</span></span><br><span class="line"><span class="comment">//     6         80        8192      102           32</span></span><br><span class="line"><span class="comment">//     7         96        8192       85           32</span></span><br><span class="line"><span class="comment">//     8        112        8192       73           16</span></span><br><span class="line"><span class="comment">//     9        128        8192       64            0</span></span><br><span class="line"><span class="comment">//    10        144        8192       56          128</span></span><br><span class="line"><span class="comment">//    11        160        8192       51           32</span></span><br><span class="line"><span class="comment">//    12        176        8192       46           96</span></span><br><span class="line"><span class="comment">//    13        192        8192       42          128</span></span><br><span class="line"><span class="comment">//    14        208        8192       39           80</span></span><br><span class="line"><span class="comment">//    15        224        8192       36          128</span></span><br><span class="line"><span class="comment">//    16        240        8192       34           32</span></span><br><span class="line"><span class="comment">//    17        256        8192       32            0</span></span><br><span class="line"><span class="comment">//    18        288        8192       28          128</span></span><br><span class="line"><span class="comment">//    19        320        8192       25          192</span></span><br><span class="line"><span class="comment">//    20        352        8192       23           96</span></span><br><span class="line"><span class="comment">//    21        384        8192       21          128</span></span><br><span class="line"><span class="comment">//    22        416        8192       19          288</span></span><br><span class="line"><span class="comment">//    23        448        8192       18          128</span></span><br><span class="line"><span class="comment">//    24        480        8192       17           32</span></span><br><span class="line"><span class="comment">//    25        512        8192       16            0</span></span><br><span class="line"><span class="comment">//    26        576        8192       14          128</span></span><br><span class="line"><span class="comment">//    27        640        8192       12          512</span></span><br><span class="line"><span class="comment">//    28        704        8192       11          448</span></span><br><span class="line"><span class="comment">//    29        768        8192       10          512</span></span><br><span class="line"><span class="comment">//    30        896        8192        9          128</span></span><br><span class="line"><span class="comment">//    31       1024        8192        8            0</span></span><br><span class="line"><span class="comment">//    32       1152        8192        7          128</span></span><br><span class="line"><span class="comment">//    33       1280        8192        6          512</span></span><br><span class="line"><span class="comment">//    34       1408       16384       11          896</span></span><br><span class="line"><span class="comment">//    35       1536        8192        5          512</span></span><br><span class="line"><span class="comment">//    36       1792       16384        9          256</span></span><br><span class="line"><span class="comment">//    37       2048        8192        4            0</span></span><br><span class="line"><span class="comment">//    38       2304       16384        7          256</span></span><br><span class="line"><span class="comment">//    39       2688        8192        3          128</span></span><br><span class="line"><span class="comment">//    40       3072       24576        8            0</span></span><br><span class="line"><span class="comment">//    41       3200       16384        5          384</span></span><br><span class="line"><span class="comment">//    42       3456       24576        7          384</span></span><br><span class="line"><span class="comment">//    43       4096        8192        2            0</span></span><br><span class="line"><span class="comment">//    44       4864       24576        5          256</span></span><br><span class="line"><span class="comment">//    45       5376       16384        3          256</span></span><br><span class="line"><span class="comment">//    46       6144       24576        4            0</span></span><br><span class="line"><span class="comment">//    47       6528       32768        5          128</span></span><br><span class="line"><span class="comment">//    48       6784       40960        6          256</span></span><br><span class="line"><span class="comment">//    49       6912       49152        7          768</span></span><br><span class="line"><span class="comment">//    50       8192        8192        1            0</span></span><br><span class="line"><span class="comment">//    51       9472       57344        6          512</span></span><br><span class="line"><span class="comment">//    52       9728       49152        5          512</span></span><br><span class="line"><span class="comment">//    53      10240       40960        4            0</span></span><br><span class="line"><span class="comment">//    54      10880       32768        3          128</span></span><br><span class="line"><span class="comment">//    55      12288       24576        2            0</span></span><br><span class="line"><span class="comment">//    56      13568       40960        3          256</span></span><br><span class="line"><span class="comment">//    57      14336       57344        4            0</span></span><br><span class="line"><span class="comment">//    58      16384       16384        1            0</span></span><br><span class="line"><span class="comment">//    59      18432       73728        4            0</span></span><br><span class="line"><span class="comment">//    60      19072       57344        3          128</span></span><br><span class="line"><span class="comment">//    61      20480       40960        2            0</span></span><br><span class="line"><span class="comment">//    62      21760       65536        3          256</span></span><br><span class="line"><span class="comment">//    63      24576       24576        1            0</span></span><br><span class="line"><span class="comment">//    64      27264       81920        3          128</span></span><br><span class="line"><span class="comment">//    65      28672       57344        2            0</span></span><br><span class="line"><span class="comment">//    66      32768       32768        1            0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>class ID，每个span结构中都有一个class ID, 表示该span可处理的对象类型。</li>
<li>bytes/obj：该class代表对象的字节数。</li>
<li>bytes/span：每个span占用堆的字节数，也即页数*页大小。</li>
<li>objects: 每个span可分配的对象个数，也即（bytes/spans）/（bytes/obj）。</li>
<li>waste bytes: 每个span产生的内存碎片，也即（bytes/spans）%（bytes/obj）。 </li>
</ul>
<p>注：上表可见最大的对象是32K（32*1024=32768）大小，超过32K大小的由特殊的class表示，该class ID为0，每个class只包含一个对象。</p>
<h3 id="span数据结构"><a href="#span数据结构" class="headerlink" title="span数据结构"></a>span数据结构</h3><p>每个span用于管理特定的class对象, 跟据对象大小，span将一个或多个页拆分成多个块进行管理。 </p>
<p><code>src/runtime/mheap.go:mspan</code>定义了其数据结构： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123; </span><br><span class="line">    next *mspan <span class="comment">//链表后向指针，用于将span链接起来 </span></span><br><span class="line">    prev *mspan <span class="comment">//链表前向指针，用于将span链接起来 </span></span><br><span class="line">    startAddr <span class="keyword">uintptr</span> <span class="comment">// 起始地址，也即所管理页的地址 </span></span><br><span class="line">    npages <span class="keyword">uintptr</span> <span class="comment">// 管理的页数 </span></span><br><span class="line">    nelems <span class="keyword">uintptr</span> <span class="comment">// 块个数，也即有多少个块可供分配 </span></span><br><span class="line">    allocBits *gcBits <span class="comment">//分配位图，每一位代表一个块是否已分配 type gcBits uint8</span></span><br><span class="line">    gcmarkBits *gcBits	<span class="comment">//用于标记内存块被引用情况。</span></span><br><span class="line">    allocCount <span class="keyword">uint16</span> <span class="comment">// 已分配块的个数 </span></span><br><span class="line">    spanclass spanClass <span class="comment">// class表中的class ID </span></span><br><span class="line">    elemsize <span class="keyword">uintptr</span> <span class="comment">// class表中的对象大小，也即块大小 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>以class 10为例，span和管理的内存如下图所示： </p>
<p><img src="/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211116230522011.png" alt="image-20211116230522011"></p>
<p>spanclass为10，参照class表可得出npages=1,nelems=56,elemsize为144。其中startAddr是在span初始化时就指定了某个页的地址。allocBits指向一个位图，每位代表一个块是否被分配，本例中有两个块已经被分配，其allocCount也为2。next和prev用于将多个span链接起来，这有利于管理多个span。</p>
<h2 id="central"><a href="#central" class="headerlink" title="central"></a>central</h2><p>全局管理span的数据结构，各线程需要内存时从 central管理的span中申请内存，当某个线程释放内存时又会回收进central。 为了避免多线程申请内存时不断的加锁，Go为每个线程分配了span的缓存，这个缓存即是<strong>cache</strong>。 </p>
<p><code>src/runtime/mcentral.go:mcentral</code>定义了central数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex     <span class="comment">//互斥锁,防止多线程读写冲突</span></span><br><span class="line">    spanclass spanClass <span class="comment">// span class ID,每个mcentral管理着一组有相同class的span列表</span></span><br><span class="line">    nonempty  mSpanList <span class="comment">// non-empty 指还有空闲块的span列表</span></span><br><span class="line">    empty     mSpanList <span class="comment">// 指没有内存可用的span列表</span></span><br><span class="line">    nmalloc <span class="keyword">uint64</span>      <span class="comment">// 已累计分配的对象个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程从central获取span步骤："><a href="#线程从central获取span步骤：" class="headerlink" title="线程从central获取span步骤："></a>线程从central获取span步骤：</h3><ol>
<li>加锁</li>
<li>从nonempty列表获取一个可用span，并将其从链表中删除</li>
<li>将取出的span放入empty链表</li>
<li>将span返回给线程</li>
<li>解锁</li>
<li>线程将该span缓存进cache</li>
</ol>
<h3 id="线程将span归还步骤："><a href="#线程将span归还步骤：" class="headerlink" title="线程将span归还步骤："></a>线程将span归还步骤：</h3><ol>
<li>加锁</li>
<li>将span从empty列表删除</li>
<li>将span加入noneempty列表</li>
<li>解锁</li>
</ol>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p><code>runtime/mcache.go:mcache</code>定义了cache的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">    alloc [<span class="number">67</span>*<span class="number">2</span>]*mspan <span class="comment">// 按class分组的mspan列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc</code>为<code>mspan</code>的指针数组，数组大小为class总数的2倍。<strong>数组中每个元素代表了一种class类型的span列表</strong>，每种class类型都有两组span列表，第一组列表中所表示的对象中包含了指针，第二组列表中所表示的对象不含有指针，<strong>这么做是为了提高GC扫描性能，</strong>对于不包含指针的span列表，没必要去扫描。根据对象是否包含指针，将对象分为<code>noscan</code>和<code>scan</code>两类，分别代表没有指针和有指针。</p>
<p><code>mcache</code>和<code>span</code>的对应关系如下图所示：</p>
<p><img src="/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211116232304382.png" alt="mcache-span"></p>
<p>mcache在初始化时是没有任何span的，在使用过程中会动态地从central中获取并缓存下来，根据使用情况，每种class的span个数也不相同。上图所示，class 0的span数比class1的要多，说明本线程中分配的小对象要多一些。</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>从mcentral数据结构可见，每个mcentral对象只管理特定的class规格的span。<span style="color:red;">事实上每种class都会对应一个mcentral</span>,这个mcentral的集合存放于mheap数据结构中。mheap管理着全部的内存，事实上Go就是通过一个mheap类型的全局变量进行内存管理的。</p>
<p><code>src/runtime/mheap.go:mheap</code>定义了heap的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock      mutex			<span class="comment">//互斥锁</span></span><br><span class="line">    spans []*mspan			<span class="comment">//指向spans区域，用于映射span和page的关系</span></span><br><span class="line">    bitmap        <span class="keyword">uintptr</span>		<span class="comment">//指向bitmap首地址，bitmap是从高地址向低地址增长的</span></span><br><span class="line">    arena_start <span class="keyword">uintptr</span>			<span class="comment">//指示arena区首地址</span></span><br><span class="line">    arena_used  <span class="keyword">uintptr</span>			<span class="comment">//指示arena区已使用地址位置</span></span><br><span class="line">    central [<span class="number">67</span>*<span class="number">2</span>]<span class="keyword">struct</span> &#123;		<span class="comment">//central: 每种class对应的两个mcentral</span></span><br><span class="line">        mcentral mcentral</span><br><span class="line">        pad      [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mheap内存管理示意图如下：</p>
<p><img src="/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211117003445098.png" alt="image-20211117003445098"></p>
<p>系统预分配的内存分为spans、bitmap、arean三个区域，通过mheap管理起来。</p>
<h2 id="内存分配过程"><a href="#内存分配过程" class="headerlink" title="内存分配过程"></a>内存分配过程</h2><p>分配步骤如下： </p>
<ol>
<li>获取当前线程的私有缓存mcache 。</li>
<li>跟据size计算出适合的class的ID 。</li>
<li>从mcache的alloc[class]链表中查询可用的span 。</li>
<li>如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中 。</li>
<li>如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral 。</li>
<li>从该span中获取到空闲对象地址并返回。</li>
</ol>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>由于span的数据结构可知，span中维护了一个位图gcmarkBits用于标记内存块被引用情况。allocBits和gcmarkBits数据结构是完全一样的，标记结束后就是内存回收，<strong>回收时将allocBits指向gcmarkBits</strong>，则代表标记过的才是存活的，gcmarkBits则会在下次标记时重新分配内存，非常的巧妙。</p>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>前面介绍了对象标记状态的存储方式，还需要有一个标记队列来存放待标记的对象，可以简单想象成把对象从标记队列中取出，将对象的引用状态标记在span的gcmarkBits，把对象引用到的其他对象再放入队列中。三色只是为了叙述上方便抽象出来的一种说法，实际上对象并没有颜色之分。这里的三色，对应了垃圾回收过程中对象的三种状态：</p>
<ul>
<li>灰色：对象还在标记队列中等待</li>
<li>黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）</li>
<li>白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）</li>
</ul>
<p>例如，当前内存中有A~F一共6个对象，根对象a,b本身为栈上分配的局部变量，根对象a、b分别引用了对象A、B, 而B对象又引用了对象D，则内存回收前各对象的状态如下图所示:</p>
<p><img src="/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211117010250864.png" alt="image-20211117010250864"></p>
<h3 id="标记过程"><a href="#标记过程" class="headerlink" title="标记过程"></a>标记过程</h3><ol>
<li>把所有的未对象都放到白色的集合中。</li>
<li>从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中。</li>
<li>遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中。</li>
<li>循环步骤3，直到灰色集合中没有对象。</li>
</ol>
<p>注：在GC的过程中所有新分配的对象都会立刻变为黑色。</p>
<h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>由于垃圾回收过程中需要控制住内存的变化，回收过程中指针传递会引起内存引用关系变化。Go的垃圾回收也会STW就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。</p>
<h2 id="垃圾回收优化"><a href="#垃圾回收优化" class="headerlink" title="垃圾回收优化"></a>垃圾回收优化</h2><h3 id="写屏障-Write-Barrier"><a href="#写屏障-Write-Barrier" class="headerlink" title="写屏障(Write Barrier)"></a>写屏障(Write Barrier)</h3><p>STW目的是防止<strong>GC扫描时</strong>内存变化而停掉goroutine，Go在进行三色标记的时候并没有STW，而写屏障就是让goroutine与GC同时运行的手段。虽然写屏障不能完全消除STW，但是可以大大减少Mark Termination中STW的时间。写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。</p>
<p>GC过程中新分配的内存会被立即标记，用的并不是写屏障技术，也即GC过程中分配的内存不会在本轮GC中回收。</p>
<h4 id="举例解释："><a href="#举例解释：" class="headerlink" title="举例解释："></a>举例解释：</h4><p>如：用户代码可能会修改已经标记为黑色的对象，让它引用白色对象。</p>
<p>stack -&gt; A.ref -&gt; B ，A是从栈对象直接可达，将它标记为灰色。此时B是白色对象。假设这个时候用户代码执行： localRef = A.ref，A.ref = NULL， localRef是栈上面的一个黑色对象，前一行赋值语句使得它引用到B对象。后一行A.ref被置为空之后，<strong>A将不再引用到B</strong>。<strong>A是灰色但是不再引用到B了，B不会着色</strong>。<strong>localRef是黑色，处理完毕的对象，引用了B但是不会被再次处理。</strong>于是B将永远不再有机会被标记，它会被误当作垃圾清理掉！<strong>而写屏障会保证B不会被回收。</strong></p>
<p><a href="https://www.zhihu.com/question/62000722/answer/193462425">参考</a></p>
<h3 id="辅助GC-Mutator-Assist"><a href="#辅助GC-Mutator-Assist" class="headerlink" title="辅助GC(Mutator Assist)"></a>辅助GC(Mutator Assist)</h3><p>为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作<strong>Mutator Assist</strong>。</p>
<h2 id="GC的几个阶段"><a href="#GC的几个阶段" class="headerlink" title="GC的几个阶段:"></a>GC的几个阶段:</h2><ol>
<li><p>Mark阶段该阶段又分为两个部分：</p>
</li>
<li><ul>
<li>Mark Prepare：初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等，<strong>这个过程需要STW。</strong><ul>
<li>GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。该过程后台并行执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>Mark Termination阶段：该阶段主要是完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下，<strong>这个过程也是会STW的</strong>。</p>
</li>
<li><p>Sweep: 按照标记结果回收所有的白色对象，该过程后台并行执行。</p>
</li>
<li><p>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。</p>
</li>
</ol>
<p>注：GC过程有<strong>两次STW</strong>:第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist)。第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist)。</p>
<p><a href="https://segmentfault.com/a/1190000020086769">参考链接</a></p>
<h2 id="垃圾回收触发时机"><a href="#垃圾回收触发时机" class="headerlink" title="垃圾回收触发时机"></a>垃圾回收触发时机</h2><h3 id="内存分配量达到阀值触发GC"><a href="#内存分配量达到阀值触发GC" class="headerlink" title="内存分配量达到阀值触发GC"></a>内存分配量达到阀值触发GC</h3><p>每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动GC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">阀值 &#x3D; 上次GC内存分配量 * 内存增长率</span><br></pre></td></tr></table></figure>

<p>内存增长率由环境变量<code>GOGC</code>控制，默认为100，即每当内存扩大一倍时启动GC。</p>
<h3 id="定期触发GC"><a href="#定期触发GC" class="headerlink" title="定期触发GC"></a>定期触发GC</h3><p>默认情况下，最长2分钟触发一次GC，这个间隔在<code>src/runtime/proc.go:forcegcperiod</code>变量中被声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forcegcperiod is the maximum time in nanoseconds between garbage</span></span><br><span class="line"><span class="comment">// collections. If we go this long without a garbage collection, one</span></span><br><span class="line"><span class="comment">// is forced to run.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is a variable for testing purposes. It normally doesn&#x27;t change.</span></span><br><span class="line"><span class="keyword">var</span> forcegcperiod <span class="keyword">int64</span> = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1e9</span></span><br></pre></td></tr></table></figure>

<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>程序代码中也可以使用<code>runtime.GC()</code>来手动触发GC。这主要用于GC性能测试和统计。</p>
<h2 id="GC总时间"><a href="#GC总时间" class="headerlink" title="GC总时间"></a>GC总时间</h2><p><code>Tgc = Tseq + Tmark + Tsweep</code>( T 表示 time)</p>
<ul>
<li><code>Tseq</code> 表示是停止用户的 goroutine 和做一些准备活动（通常很小）需要的时间。</li>
<li><code>Tmark </code>是堆标记时间，标记发生在<strong>所有用户 goroutine 停止时</strong>，因此可以显著地影响处理的延迟。</li>
<li><code>Tsweep</code> 是堆清除时间，清除通常与正常的程序并发运行，所以对延迟来说是不太关键的。</li>
</ul>
<h2 id="各版本垃圾回收器"><a href="#各版本垃圾回收器" class="headerlink" title="各版本垃圾回收器"></a>各版本垃圾回收器</h2><p>go语言垃圾回收总体采用的是经典的mark and sweep算法。</p>
<ul>
<li>1.3版本以前，go的垃圾回收算法都非常简陋，然后其性能也广被诟病：go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后启动所有任务的执 行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的！这个时期国内外很多在生产环境实践go语言的团队都或多或少踩过gc的 坑。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。</li>
<li>1.3版本开始go team开始对gc性能进行持续的改进和优化，每个新版本的go发布时gc改进都成为大家备受关注的要点。1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务了，而是 让sweep任务和普通协程任务一样并行的和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码 的执行。go team自己的说法是减少了50%-70%的暂停时间。</li>
<li>1.4版本（当前最新稳定版本）对gc的性能改动并不多。1.4版本中runtime很多代码取代了原生c语言实现而采用了go语言实现，对 gc带来的一大改变是可以是实现精确的gc。c语言实现在gc时无法获取到内存的对象信息，因此无法准确区分普通变量和指针，只能将普通变量当做指针，如 果碰巧这个普通变量指向的空间有其他对象，那这个对象就不会被回收。而go语言实现是完全知道对象的类型信息，在标记时只会遍历指针指向的对象，这样就避 免了C实现时的堆内存浪费（解决约10-30%）。</li>
<li>1.5版本go team对gc又进行了比较大的改进（1.4中已经埋下伏笔如write barrier的引入）,官方的主要目标是减少延迟。go 1.5正在实现的垃圾回收器是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。分代算法上文已经提及，是一种比较好的垃圾回收管理策略，然 1.5版本中并未考虑实现；我猜测的原因是步子不能迈太大，得逐步改进，go官方也表示会在1.6版本的gc优化中考虑。同时引入了上文介绍的三色标记 法，这种方法的mark操作是可以渐进执行的而不需每次都扫描整个内存空间，可以减少stop the world的时间。</li>
</ul>
<p><a href="https://www.open-open.com/lib/view/open1435846881544.html">参考链接</a></p>
<h2 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h2><p>每当函数中申请新的对象，编译器会跟据该对象是否被函数外部引用来决定是否逃逸： </p>
<ul>
<li>如果函数外部没有引用，则优先放到栈中； </li>
<li>如果函数外部存在引用，则必定放到堆中； </li>
</ul>
<p>注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过<strong>大超过栈的存储能力</strong>。</p>
<p>通过编译参数-gcflag=-m可以查看编译过程中的逃逸分析：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags=-m</span><br></pre></td></tr></table></figure>

<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础数据实现原理</title>
    <url>/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p><code>src/runtime/chan.go:hchan</code> 定义了channel的数据结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123; </span><br><span class="line">    qcount <span class="keyword">uint</span> <span class="comment">// 当前队列中剩余元素个数 </span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span> <span class="comment">// 环形队列长度，即可以存放的元素个数 </span></span><br><span class="line">    buf unsafe.Pointer <span class="comment">// 环形队列指针 </span></span><br><span class="line">    elemsize <span class="keyword">uint16</span> <span class="comment">// 每个元素的大小 </span></span><br><span class="line">    closed <span class="keyword">uint32</span> <span class="comment">// 标识关闭状态 </span></span><br><span class="line">    elemtype *_type <span class="comment">// 元素类型 </span></span><br><span class="line">    sendx <span class="keyword">uint</span> <span class="comment">// 队列下标，指示元素写入时存放到队列中的位置 </span></span><br><span class="line">    recvx <span class="keyword">uint</span> <span class="comment">// 队列下标，指示元素从队列的该位置读出 </span></span><br><span class="line">    recvq waitq <span class="comment">// 等待读消息的goroutine队列 </span></span><br><span class="line">    sendq waitq <span class="comment">// 等待写消息的goroutine队列 </span></span><br><span class="line">    lock mutex <span class="comment">// 互斥锁，chan不允许并发读写 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。 </p>
<p>下图展示了一个可缓存6个元素的channel示意图： </p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211112200406133.png" alt="image-20211112200406133"></p>
<ul>
<li>dataqsiz指示了队列长度为6，即可缓存6个元素； </li>
<li>buf指向队列的内存，队列中还剩余两个元素； </li>
<li>qcount表示队列中还有两个元素； </li>
<li>sendx指示后续写入的数据存储的位置，取值[0, 6)； </li>
<li>recvx指示从该位置读取数据, 取值[0, 6)； </li>
</ul>
<h3 id="向channel中写数据"><a href="#向channel中写数据" class="headerlink" title="向channel中写数据"></a>向channel中写数据</h3><ol>
<li>如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据 </li>
</ol>
<p>写入，最后把该G唤醒，结束发送过程； </p>
<ol start="2">
<li><p>如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； </p>
</li>
<li><p>如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤 </p>
</li>
</ol>
<p>醒； </p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211112200511237.png" alt="image-20211112200511237"></p>
<h3 id="从channel读数据"><a href="#从channel读数据" class="headerlink" title="从channel读数据"></a>从channel读数据</h3><ol>
<li>如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束 </li>
</ol>
<p>读取过程； </p>
<ol start="2">
<li>如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾 </li>
</ol>
<p>部，把G唤醒，结束读取过程； </p>
<ol start="3">
<li><p>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程； </p>
</li>
<li><p>将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；</p>
</li>
</ol>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211112200705569.png" alt="image-20211112200705569"></p>
<p>注：关闭channel时会把recvq中的G全部唤醒。</p>
<h3 id="panic出现的常见场景："><a href="#panic出现的常见场景：" class="headerlink" title="panic出现的常见场景："></a>panic出现的常见场景：</h3><ol>
<li><p>关闭值为nil的channel </p>
</li>
<li><p>关闭已经被关闭的channel </p>
</li>
<li><p>向已经关闭的channel写数据 </p>
</li>
</ol>
<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p> <code>src/runtime/slice.go:slice</code> 定义了Slice的数据结构： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123; </span><br><span class="line">    array unsafe.Pointer </span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span> </span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>使用数组来创建Slice时，Slice将与原数组共用一部分内存。 </p>
<p>如，语句 slice := array[5:7] 所创建的Slice，结构如下图所示：</p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211112234408441.png" alt="image-20211112234408441"></p>
<p>切片从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切 </p>
<p>片的预留内存，即capacity为5。 </p>
<h3 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h3><p>如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍； </p>
<p>如果原Slice容量大于等于1024，则新Slice容量将扩大为原来的1.25倍；</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h3><p>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长 度的最小值。例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。 也就是说，<strong>copy过程中不会发生扩容。</strong></p>
<h3 id="数组或切片生成新的切片"><a href="#数组或切片生成新的切片" class="headerlink" title="数组或切片生成新的切片"></a>数组或切片生成新的切片</h3><p>slice[start :end :cap]生成的切片长度为end-start，容量为5。</p>
<p>slice[start:end] 方式生成的切片并没有指定切片的容量，实际上新切片的<strong>容量</strong>是从start开始直至slice的结束。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>Golang的map使用<strong>哈希表</strong>作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存 了map中的一个或一组键值对。 </p>
<p>map数据结构由 <code>runtime/map.go/hmap</code> 定义: </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="keyword">int</span>				<span class="comment">// 当前保存的元素个数</span></span><br><span class="line">    flags     <span class="keyword">uint8</span>				<span class="comment">// 状态标志</span></span><br><span class="line">    B         <span class="keyword">uint8</span>				<span class="comment">// 指示bucket数组的大小:2^B</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span>			<span class="comment">// 溢出的个数</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span>			<span class="comment">// 哈希种子</span></span><br><span class="line">    buckets    unsafe.Pointer 	<span class="comment">// bucket数组指针，数组的大小为2^B</span></span><br><span class="line">    oldbuckets unsafe.Pointer 	<span class="comment">// 旧桶的地址，用于扩容</span></span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span>			<span class="comment">// 搬迁进度（已经搬迁的buckets数量）</span></span><br><span class="line">    extra *mapextra				<span class="comment">// 当key不是指针类型的数据的时候，里面会存溢出桶，这样会避免gc的扫描</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mapextra"><a href="#mapextra" class="headerlink" title="mapextra"></a>mapextra</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapextra是一个为了优化bucket而设计的，当key或value是指针的时候，此时overflow和oldoverflow就不会被使用，只有nextOverflow会被使用，该字段保存了<strong>预先申请的溢出桶</strong>。在没有发生扩容的时候，一个桶或者说bmap的8个tophash都被使用完了，那么就要考虑使用逸出桶。<br>当key和value都没有指针的时候bucket的bmap的_type的ptrdata就是0，意味着该结构体是没有指针的，申请bmap内存的时候，会申请一个没有指针的span，这样会避免gc扫描该内存，会提高效率，但是bmap的最后一个内存块是确确实实存放指针的，所以用uintptr存储着该map的逸出桶的地址，但是由于没有指向下一个逸出桶，可能会被gc回收掉，所以就需要overflow存取指向该逸出桶的指针避免被gc回收掉。</p>
<h3 id="bucket数据结构"><a href="#bucket数据结构" class="headerlink" title="bucket数据结构"></a>bucket数据结构</h3><p><code>runtime/map.go/bmap</code> 定义： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123; </span><br><span class="line">    tophash [<span class="number">8</span>]<span class="keyword">uint8</span> <span class="comment">//存储哈希值的高8位 </span></span><br><span class="line">    </span><br><span class="line">    data <span class="keyword">byte</span>[<span class="number">1</span>] <span class="comment">//key value数据:key1/key2/key3/.../value1/value2/value3... </span></span><br><span class="line">    <span class="comment">// 为什么不是k1v1，k2v2..... 而是k1k2...v1v2...，</span></span><br><span class="line">    <span class="comment">// 如 map[int64]int8,key是int64（8个字节），value是int8（1个字节），kv的长度不同，如果按照kv格式存放，则考虑内存对齐v也会占用int64，而按照后者存储时，8个v刚好占用一个int64,从这个就可以看出go的map设计之巧妙。</span></span><br><span class="line">    overflow *bmap <span class="comment">//溢出bucket的地址 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意！！！，上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的</span></span><br><span class="line">    <span class="comment">//真正源码如下</span></span><br><span class="line">    <span class="comment">//type bmap struct &#123;</span></span><br><span class="line">    <span class="comment">//    // bucketCnt = 1 &lt;&lt; 3</span></span><br><span class="line">    <span class="comment">//    tophash [bucketCnt]uint8</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值<strong>低位相同</strong>的键）存入当前bucket时会将哈 希值的高位存储在该数组中，以方便后续匹配。 </li>
<li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了<strong>节省字节对齐带来的空间浪费。</strong> </li>
<li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。 </li>
</ul>
<p><strong>一个bucket占272个字节</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash        [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">	debugKeys      [bucketCnt]<span class="keyword">string</span></span><br><span class="line">	debugElems     [bucketCnt]<span class="keyword">string</span></span><br><span class="line">	debugOverflows <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bucketCnt*(uint8的字节为1)+bucketCnt*(string的字节16)+bucketCnt*(string的字节16)+指针大小8字节 = 272</span></span><br></pre></td></tr></table></figure>

<p>下图展示bucket存放8个key-value对： </p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211113001659704.png" alt="image-20211113001659704"></p>
<h3 id="map的整体结构"><a href="#map的整体结构" class="headerlink" title="map的整体结构"></a>map的整体结构</h3><p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211113163849173.png" alt="image-20211113163849173"></p>
<p><span style="color:red">如果申请内存桶的时候有多余的溢出桶，那么mapextra的nextOverflow就会指向[]bmap其中的某块桶的地址，地址后之后的桶都是溢出桶。在一个桶装不下的时候，会去溢出桶拿桶然后bmap的overflow指向溢出桶。</span></p>
<p><a href="https://blog.csdn.net/u010927340/article/details/109982682">参考链接</a></p>
<h3 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h3><p>Go使用<strong>链地址法</strong>来解决键冲突。由 于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。 如下：</p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211113002216521.png" alt="image-20211113002216521"></p>
<p>bucket数据结构指示下一个bucket的指针称为<strong>overflow bucket</strong>，意为当前bucket盛不下而溢出的部分。</p>
<h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>负载因子用于衡量一个哈希表冲突情况，公式为： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">负载因子 = 键数量/bucket数量 </span><br></pre></td></tr></table></figure>

<p>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1. 哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行rehash，也即键值对重新组织： </p>
<ol>
<li>哈希因子过小，说明空间利用率低 </li>
<li>哈希因子过大，说明冲突严重，存取效率低 </li>
</ol>
<p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载 因子达到<strong>6.5</strong>时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对， 所以Go可以容忍更高的负载因子。 </p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol>
<li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li>
<li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li>
</ol>
<h4 id="增量式扩容"><a href="#增量式扩容" class="headerlink" title="增量式扩容"></a>增量式扩容</h4><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。 </p>
<p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域): </p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211113005214552.png" alt="image-20211113005214552"></p>
<p>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。扩容后示意图如下： </p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211113005241603.png" alt="image-20211113005241603"></p>
<p>hmap数据结构中oldbuckets成员指身原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的 bucket中。后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键 值对全部搬迁完毕后，删除oldbuckets。 </p>
<p>搬迁完成后的示意图如下： </p>
<p><img src="https://img2020.cnblogs.com/blog/1961904/202111/1961904-20211113005310397-1718462163.png" alt="image-20211113005307033"></p>
<p>数据搬迁过程中<strong>原bucket中的键值对将存在于新bucket的前面</strong>，新插入的键值对将存在于新bucket的后面。</p>
<h4 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h4><p>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。在极端场景下，比如不断的增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况。</p>
<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><ol>
<li><p>跟据key值算出哈希值 </p>
</li>
<li><p>取哈希值低8位与2^hmpa.B取模确定bucket位置 </p>
</li>
<li><p>取哈希值高8位在tophash数组中查询 </p>
</li>
<li><p>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较 </p>
</li>
<li><p>当前bucket没有找到，则继续从下个overflow的bucket中查找。 </p>
</li>
<li><p>如果当前处于搬迁过程，则<strong>优先从oldbuckets</strong>查找 </p>
</li>
</ol>
<p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。 </p>
<h3 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h3><ol>
<li><p>跟据key值算出哈希值 </p>
</li>
<li><p>取哈希值低8位与2^hmap.B取模确定bucket位置 </p>
</li>
<li><p>查找该key是否已经存在，如果存在则直接更新值 </p>
</li>
<li><p>如果没找到将key，将key插入 </p>
</li>
</ol>
<h3 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h3><p><code>runtime/map.go</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行delete(map, key)</span></span><br><span class="line"><span class="comment">// 部分源码 emptyOne = 1 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="comment">//清空key</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(k, t.key.size)</span><br><span class="line">			&#125;</span><br><span class="line">			e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.elemsize))</span><br><span class="line">            <span class="comment">//清空value</span></span><br><span class="line">            <span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(e, t.elem.size)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(e, t.elem.size)</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 标记为值已经被清除</span></span><br><span class="line">			b.tophash[i] = emptyOne</span><br><span class="line">            h.count--</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上可知，map的删除只是将tophash置为emptyOne，它修改了当前 key 的标记，但没有直接删除了内存里面的数据。</p>
<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p>iota常用于<strong>const表达式中</strong>，iota代表了<strong>const声明块</strong>的行索引（下标从0开始） 。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li><strong>题目一</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// mutex is locked </span></span><br><span class="line">    mutexWoken </span><br><span class="line">    mutexStarving</span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span> </span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> </span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<p>mutexLocked == 1；mutexWoken == 2；mutexStarving == 4；mutexWaiterShift == 3； starvationThresholdNs == 1000000。</p>
<ul>
<li><strong>题目二</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ( </span><br><span class="line">    bit0, mask0 = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>, <span class="number">1</span>&lt;&lt;<span class="literal">iota</span> - <span class="number">1</span><span class="comment">//const声明第0行，即iota==0 </span></span><br><span class="line">    bit1, mask1				<span class="comment">//const声明第1行，即iota==1, 表达式继承上面的语句 </span></span><br><span class="line">    _, _				<span class="comment">//const声明第2行，即iota==2 </span></span><br><span class="line">    bit3, mask3				<span class="comment">//const声明第3行，即iota==3 </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>bit0 == 1， mask0 == 0， bit1 == 2， mask1 == 1， bit3 == 8， mask3 == 7</p>
<ul>
<li><strong>题目三</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a  = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	b</span><br><span class="line">	str = <span class="string">&quot;str&quot;</span></span><br><span class="line">	c</span><br><span class="line">	d = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	e  = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line">	f</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>a == 0，b == 1，c == str，d == 4，e == 0，f == 1</p>
<p>注：原理有解释。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>const块中每一行在GO中使用spec数据结构描述，spec声明如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A ValueSpec node represents a constant or variable declaration </span></span><br><span class="line"><span class="comment">// (ConstSpec or VarSpec production). </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">ValueSpec <span class="keyword">struct</span> &#123; </span><br><span class="line">    Doc *CommentGroup <span class="comment">// associated documentation; or nil </span></span><br><span class="line">    Names []*Ident <span class="comment">// value names (len(Names) &gt; 0) </span></span><br><span class="line">    Type Expr <span class="comment">// value type; or nil </span></span><br><span class="line">    Values []Expr <span class="comment">// initial values; or nil </span></span><br><span class="line">    Comment *CommentGroup <span class="comment">// line comments; or nil </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>ValueSpec.Names这个切片中保存了一行中定义的常量，如果一行定义N个常量，那么ValueSpec.Names切片长度即为N。 </p>
<p>const块实际上是spec类型的切片，用于表示const中的多行。 </p>
<p>所以编译期间构造常量时的伪算法如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="literal">iota</span>, spec := <span class="keyword">range</span> ValueSpecs &#123; </span><br><span class="line">    <span class="keyword">for</span> i, name := <span class="keyword">range</span> spec.Names &#123; </span><br><span class="line">        obj := NewConst(name, <span class="literal">iota</span>...) <span class="comment">//此处将iota传入，用于构造常量 </span></span><br><span class="line">        ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><span style="color:red">从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。 多个const块的iota不互相影响。</span></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>string是8比特字节的集合，通常但并不一定是UTF-8编码的文本。</li>
<li>string可以为空（长度为0），但不会是nil。</li>
<li>string对象不可以修改。 </li>
</ul>
<p><code>src/runtime/string.go:stringStruct</code> 定义了string的数据结构： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123; </span><br><span class="line">    str unsafe.Pointer <span class="comment">//字符串的首地址</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string数据结构跟切片有些类似，只不过切片还有一个表示容量cap的成员，事实上string和切片，准确的说是byte切片经常发生转换。</p>
<p>字符串构建过程是先跟据字符串构建stringStruct，再转换成string。转换的源码如下： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostringnocopy</span><span class="params">(str *<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123; <span class="comment">// 跟据字符串地址构建string </span></span><br><span class="line">    ss := stringStruct&#123;</span><br><span class="line">        str: unsafe.Pointer(str), <span class="built_in">len</span>: findnull(str)</span><br><span class="line">    &#125; <span class="comment">// 先构造stringStruct </span></span><br><span class="line">    s := *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;ss)) <span class="comment">// 再将stringStruct转换成string</span></span><br><span class="line">    <span class="keyword">return</span> s </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string在runtime包中就是stringStruct，对外呈现叫做string。</p>
<h3 id="byte转string"><a href="#byte转string" class="headerlink" title="[]byte转string"></a>[]byte转string</h3><p>byte切片可以很方便的转换成string，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStringBySlice</span><span class="params">(s []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123; </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(s) </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>需要注意的是这种转换需要一次内存拷贝。 </p>
<p> <strong>转换过程</strong></p>
<ol>
<li>跟据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)。</li>
<li>构建string（string.str = p；string.len = len；）。</li>
<li>拷贝数据(切片中数据拷贝到新申请的内存空间) 。</li>
</ol>
<p>注：string转[]byte同理。</p>
<p><strong>转换示意图</strong>：</p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211114000900320.png" alt="image-20211114000900320"></p>
<h3 id="byte转换成string一定会拷贝内存吗？"><a href="#byte转换成string一定会拷贝内存吗？" class="headerlink" title="[]byte转换成string一定会拷贝内存吗？"></a>[]byte转换成string一定会拷贝内存吗？</h3><p>​        byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成 string时并不会拷贝内存，而是直接返回一个string，这个string的指针(string.str)指向切片的内存。 比如，编译器。</p>
<p><strong>会识别如下临时场景：</strong> </p>
<ul>
<li>使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）。</li>
<li>字符串拼接，如”&lt;” + “string(b)” + “&gt;”。</li>
<li>字符串比较：string(b) == “foo” 。</li>
</ul>
<p>因为是临时把byte切片转换成string，也就避免了因byte切片同容改成而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。 </p>
<h2 id="Mutex互斥锁"><a href="#Mutex互斥锁" class="headerlink" title="Mutex互斥锁"></a>Mutex互斥锁</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="keyword">int32</span> <span class="comment">//表示互斥锁的状态，比如是否被锁定等。</span></span><br><span class="line">	sema  <span class="keyword">uint32</span> <span class="comment">//表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。如下所示：</p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211115153438218.png" alt="Mutex.state"></p>
<ul>
<li>Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定。 </li>
<li>Woken: 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。 </li>
<li>Starving：表示该Mutex是否处理饥饿状态， 0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过1ms。 </li>
<li>Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。</li>
</ul>
<h3 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h3><p>加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测Locked位是否变为0，这个过程即为自旋过程。 自旋对应于CPU的”PAUSE”指令，CPU对该指令什么都不做，相当于CPU空转，对程序而言相当于sleep了一小段时间，时间非常短，当前实现是30个时钟周期。</p>
<h3 id="自旋条件"><a href="#自旋条件" class="headerlink" title="自旋条件"></a>自旋条件</h3><ul>
<li>自旋次数要足够小，通常为4，即自旋最多4次 </li>
<li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁 </li>
<li>协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋 </li>
<li>协程调度机制中的可运行队列必须为空，否则会延迟协程调度 </li>
</ul>
<h3 id="Mutex模式"><a href="#Mutex模式" class="headerlink" title="Mutex模式"></a>Mutex模式</h3><p>​        为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。 </p>
<ul>
<li>normal模式 （默认）</li>
</ul>
<p>​    加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程。</p>
<ul>
<li>starvation模式</li>
</ul>
<p>​    自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释 放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞， 不过<strong>阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞。</strong> 处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1。</p>
<h2 id="RWMutex读写锁"><a href="#RWMutex读写锁" class="headerlink" title="RWMutex读写锁"></a>RWMutex读写锁</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123; </span><br><span class="line">    w Mutex <span class="comment">//用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此 </span></span><br><span class="line">    writerSem <span class="keyword">uint32</span> <span class="comment">//写阻塞等待的信号量，最后一个读者释放锁时会释放信号量 </span></span><br><span class="line">    readerSem <span class="keyword">uint32</span> <span class="comment">//读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量 </span></span><br><span class="line">    readerCount <span class="keyword">int32</span> <span class="comment">//记录读者个数，写操作将readerCount变成负值来阻止读操作的。 </span></span><br><span class="line">    readerWait <span class="keyword">int32</span> <span class="comment">//记录写阻塞时读者个数 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>源码包中 src/sync/waitgroup.go:WaitGroup 定义了其数据结构： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123; </span><br><span class="line">	state1 [<span class="number">3</span>]<span class="keyword">uint32</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>state1是个长度为3的数组，其中包含了state和一个信号量，而state实际上是两个计数器： </p>
<ul>
<li>counter： 当前还未执行结束的goroutine计数器 </li>
<li>waiter count: 等待goroutine-group结束的goroutine数量，即有多少个等候者 </li>
<li>semaphore: 信号量 </li>
</ul>
<p>考虑到字节是否对齐，三者出现的位置不同，为简单起见，依照字节已对齐情况下，三者在内存中的位置如下所示：</p>
<p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/image-20211118003355994.png" alt="image-20211118003355994"></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p><img src="/2021/11/12/GoLang/Go%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/333D1FC3.gif" alt="img"></p>
]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Go学习笔记</title>
    <url>/2021/09/25/GoLang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="各数据类型内存占用大小"><a href="#各数据类型内存占用大小" class="headerlink" title="各数据类型内存占用大小"></a>各数据类型内存占用大小</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>bool</code></td>
<td align="center">1个字节</td>
</tr>
<tr>
<td align="center"><code>intN, uintN, floatN, complexN</code></td>
<td align="center">N/8个字节(例如float64是8个字节)</td>
</tr>
<tr>
<td align="center"><code>int, uint, uintptr</code></td>
<td align="center">1个机器字</td>
</tr>
<tr>
<td align="center"><code>*T</code></td>
<td align="center">1个机器字</td>
</tr>
<tr>
<td align="center"><code>string</code></td>
<td align="center">2个机器字(type,value)</td>
</tr>
<tr>
<td align="center"><code>[]T</code></td>
<td align="center">3个机器字(data,len,cap)</td>
</tr>
<tr>
<td align="center"><code>map</code></td>
<td align="center">1个机器字</td>
</tr>
<tr>
<td align="center"><code>func</code></td>
<td align="center">1个机器字</td>
</tr>
<tr>
<td align="center"><code>chan</code></td>
<td align="center">1个机器字</td>
</tr>
<tr>
<td align="center"><code>interface</code></td>
<td align="center">2个机器字(type,value)</td>
</tr>
</tbody></table>
<h2 id="fmt-Printf转换字符（动词：verb）"><a href="#fmt-Printf转换字符（动词：verb）" class="headerlink" title="fmt.Printf转换字符（动词：verb）"></a>fmt.Printf转换字符（动词：verb）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%d 			十进制整数 </span><br><span class="line">%x, %o, %b 	十六进制，八进制，二进制整数。 </span><br><span class="line">%f, %g, %e 	浮点数： 3.141593 3.141592653589793 3.141593e+00 </span><br><span class="line">%t 			布尔：true或false </span><br><span class="line">%c 			字符（rune） (Unicode码点) </span><br><span class="line">%s 			字符串 </span><br><span class="line">%q 			带双引号的字符串&quot;abc&quot;或带单引号的字符&#39;c&#39; </span><br><span class="line">%v 			变量的自然形式（natural format） </span><br><span class="line">%T 			变量的类型 </span><br><span class="line">%% 			字面上的百分号标志（无操作数） </span><br></pre></td></tr></table></figure>



<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>case 后默认break，可用fallthrough关键字接着执行下一个case（无论其值是否符合）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> coinflip() &#123; </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;heads&quot;</span>: heads++ </span><br><span class="line">    <span class="comment">//fallthrough 去掉注释后heads匹配，tails++也会执行</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;tails&quot;</span>: tails++ </span><br><span class="line"><span class="keyword">default</span>: fmt.Println(<span class="string">&quot;landed on edge!&quot;</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无tag switch(tagless switch)；这和switch true是等价的。相当于多个if else</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Signum</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内置函数len"><a href="#内置函数len" class="headerlink" title="内置函数len"></a>内置函数len</h2><p>len函数可以返回一个字符串中的<strong>字节数目</strong>（不是rune字符数目），索引操作s[i]返回第i 个字节的字节值，i必须满足0 ≤ i&lt; len(s)条件约束。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;12中3&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(str))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v, %[1]q\n&quot;</span>,str[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// 中文‘中’占3个字节</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v, %[1]q\n&quot;</span>,str[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 50, &#x27;2&#x27;</span></span><br><span class="line"><span class="comment">// 中, &quot;中&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计字符串字符数：utf8.RuneCountInString(str)</span></span><br><span class="line"><span class="comment">//使用utf8解码器获取rune字符</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); &#123;</span><br><span class="line">    r, size := utf8.DecodeRuneInString(str[i:])</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d\t%c\n&quot;</span>, i, r)</span><br><span class="line">    i += size</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简洁做法,range隐式地解码</span></span><br><span class="line"><span class="keyword">for</span> i, r := <span class="keyword">range</span> <span class="string">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d,%q,%d\n&quot;</span>, i, r, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">0,&#x27;H&#x27;,72</span></span><br><span class="line"><span class="comment">1,&#x27;e&#x27;,101</span></span><br><span class="line"><span class="comment">2,&#x27;l&#x27;,108</span></span><br><span class="line"><span class="comment">3,&#x27;l&#x27;,108</span></span><br><span class="line"><span class="comment">4,&#x27;o&#x27;,111</span></span><br><span class="line"><span class="comment">5,&#x27;,&#x27;,44</span></span><br><span class="line"><span class="comment">6,&#x27; &#x27;,32</span></span><br><span class="line"><span class="comment">7,&#x27;世&#x27;,19990</span></span><br><span class="line"><span class="comment">10,&#x27;界&#x27;,30028</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的值是<strong>不可变</strong>的，数据安全的，一个字符串和两个子串<strong>共享相同</strong>的底层数据，如下。</p>
<p><img src="/2021/09/25/GoLang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210910204012922.png" alt="image-20210910204012922"></p>
<p><a href="https://studygolang.com/pkgdoc">API文档</a></p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>函数声明包括<strong>函数名</strong>、<strong>形式参数列表</strong>、<strong>返回值列表</strong>（可省略）以及<strong>函数体</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给出4种方法声明拥有2个int型参数和1个int型返回值的函数</span></span><br><span class="line"><span class="comment">//(注：即下文的_符号)可以强调某个参数未被使用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span>   &#123; <span class="keyword">return</span> x + y &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(z <span class="keyword">int</span>)</span></span>   &#123; z = x - y; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">first</span><span class="params">(x <span class="keyword">int</span>, _ <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zero</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span></span>      &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add) 	<span class="comment">// &quot;func(int, int) int&quot; </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, sub) 	<span class="comment">//&quot;func(int, int) int&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, first) 	<span class="comment">//&quot;func(int, int) int&quot; </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, zero) 	<span class="comment">//&quot;func(int, int) int&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="反射中的Type与Kind"><a href="#反射中的Type与Kind" class="headerlink" title="反射中的Type与Kind"></a>反射中的Type与Kind</h2><p>Type是类型，Kind是类别，Type与Kind可能<strong>相同</strong>，也可能<strong>不同</strong>。</p>
<ul>
<li>var num int = 10, num的Type和Kind都是int。</li>
<li>var people = Student{}，people的Type是 包名.Student,Kind是struct。</li>
</ul>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="go-env-查看环境配置"><a href="#go-env-查看环境配置" class="headerlink" title="go env 查看环境配置"></a>go env 查看环境配置</h3><h3 id="go-version-查看当前go版本"><a href="#go-version-查看当前go版本" class="headerlink" title="go version 查看当前go版本"></a>go version 查看当前go版本</h3><h3 id="go-get-param-packages-拉取远程依赖包"><a href="#go-get-param-packages-拉取远程依赖包" class="headerlink" title="go get [param] packages 拉取远程依赖包"></a>go get [param] packages 拉取远程依赖包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数介绍</span></span><br><span class="line">-d 让命令程序只执行下载动作，而不执行安装动作。</span><br><span class="line"></span><br><span class="line">-f 仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里Fork过来的，那么这样做就尤为重要了。</span><br><span class="line"></span><br><span class="line">-fix 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。</span><br><span class="line"></span><br><span class="line">-insecure 允许命令程序使用非安全的scheme（如HTTP）去下载指定的代码包。如果你用的代码仓库（如公司内部的Gitlab）没有HTTPS支持，可以添加此标记。请在确定安全的情况下使用它。</span><br><span class="line"></span><br><span class="line">-t 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。</span><br><span class="line"></span><br><span class="line">-u 让命令利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。</span><br><span class="line"></span><br><span class="line">-v 打印出被构建的代码包的名字。</span><br><span class="line"></span><br><span class="line">-x 打印出用到的命令。</span><br></pre></td></tr></table></figure>

<h3 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h3><p>编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main， go build 将调用链接器在当前目录创建 一个可执行程序；以导入路径的最后一段作为可执行程序的名字。默认情况下， go build 命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。</p>
<h3 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h3><p>go install 命令 和 go build 命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH/pkg目录下，目录路径和 src目录路径对应，可执行 程序被保存到$GOPATH/bin目录。</p>
<p>注： go install 命令和 go build 命令都不会重新编译没有发生变化的包。</p>
<h3 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h3><p>是go build 与执行可执行文件的结合，即<strong>构建并运行</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ cat quoteargs.<span class="keyword">go</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"><span class="keyword">import</span> ( </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;os&quot;</span> </span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">	fmt.Printf(<span class="string">&quot;%q\n&quot;</span>, os.Args[<span class="number">1</span>:]) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> build quoteargs.<span class="keyword">go</span> </span><br><span class="line">$ ./quoteargs one <span class="string">&quot;two three&quot;</span> four\ five </span><br><span class="line">[<span class="string">&quot;one&quot;</span> <span class="string">&quot;two three&quot;</span> <span class="string">&quot;four five&quot;</span>]</span><br><span class="line"><span class="comment">// 与上面两命令等价</span></span><br><span class="line">$ <span class="keyword">go</span> run quoteargs.<span class="keyword">go</span> one <span class="string">&quot;two three&quot;</span> four\ five </span><br><span class="line">[<span class="string">&quot;one&quot;</span> <span class="string">&quot;two three&quot;</span> <span class="string">&quot;four five&quot;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h3><p>go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有 以 _test.go 为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测 试的一部分。 在 *_test.go 文件中，有三种类型的函数：测试函数、基准测试(benchmark)函数、示例函数。一个测试函数是以<strong>Test</strong>为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确； go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以 <strong>Benchmark</strong>为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。go test命令会遍历所有的 *_test.go 文件中符合上述命名规则的函数，生成一个临时的main 包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试函数</span></span><br><span class="line"><span class="comment"># -v 可用于打印每个测试函数的名字和运行时间：</span></span><br><span class="line">$ go <span class="built_in">test</span> -v </span><br><span class="line">=== RUN TestPalindrome </span><br><span class="line">--- PASS: TestPalindrome (0.00s) </span><br><span class="line">=== RUN TestNonPalindrome </span><br><span class="line">--- PASS: TestNonPalindrome (0.00s)</span><br><span class="line"><span class="comment">#-run 对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被 go test 测 试命令运行</span></span><br><span class="line">$ go <span class="built_in">test</span> -v -run=<span class="string">&quot;NonPalind&quot;</span></span><br><span class="line">=== RUN   TestNonPalindrome</span><br><span class="line">--- PASS: TestNonPalindrome (0.00s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -coverprofile=c.out 这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据，写入c.out文件</span></span><br><span class="line"><span class="comment"># 如果使用了 -covermode=count 标志参数，那么将在每个代码块插入一个计数器而不是布尔标 志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代 码。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行 go tool cover -html=c.out 生成一个HTML文件报告，然后在浏览器中打开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基准测试函数（性能测试）</span></span><br><span class="line"><span class="comment"># 使用-bench= 指定基准测试函数 </span></span><br><span class="line"><span class="comment"># -benchtime= 10x表示每个benchmark跑满10轮，10s表示每个benchmark跑满10秒。默认为s</span></span><br><span class="line"><span class="comment"># -cpu= 指定使用cpu数 比如1,2,3，表示跑3组，第一组用1个cpu，第二组用2个cpu，第三组用3个cpu。默认为runtime.GOMAXPROCS(-1)。</span></span><br><span class="line"><span class="comment"># -count= 每组运行次数，比如3，表示每组跑3次。默认为1。</span></span><br><span class="line">$ go <span class="built_in">test</span> -cpuprofile=cpu.out </span><br><span class="line">CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到 操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。 </span><br><span class="line">$ go <span class="built_in">test</span> -memprofile=mem.out</span><br><span class="line">堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的 内存申请会触发一个剖析数据。 </span><br><span class="line">$ go <span class="built_in">test</span> -blockprofile=block.out </span><br><span class="line">阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁 等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</span><br></pre></td></tr></table></figure>



<h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><p>go mod <command> [arguments]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">download    <span class="comment">//下载模块到本地缓存，具体可以通过命令go env查看，其中环境变量GOCACHE就是缓存的地址，如果该文件夹的内容太大，可以通过命令go clean -cache</span></span><br><span class="line">edit        <span class="comment">//从工具或脚本中编辑go.mod文件</span></span><br><span class="line">graph       <span class="comment">//打印模块需求图</span></span><br><span class="line">init        <span class="comment">//在当前目录下初始化新的模块</span></span><br><span class="line">tidy        <span class="comment">//添加缺失的模块以及移除无用的模块，执行后会生成go.sum文件(go.sum是一个模块版本内容的校验值，用来验证当前缓存的模块。go.sum包含了直接依赖和间接依赖的包的信息，比go.mod要多一些)。</span></span><br><span class="line">verify      <span class="comment">//验证依赖项是否达到预期的目的，即检查当前模块的依赖是否已经存储在本地下载的源代码缓存中，以及检查自从下载下来是否有修改。如果所有的模块都没有修改，那么会打印all modules verified，否则会打印变化的内容。</span></span><br><span class="line">why         <span class="comment">//解释为什么需要包或模块</span></span><br><span class="line">vendor		<span class="comment">//将build阶段需要的所有依赖包放到主模块所在的vendor目录中，并且测试所有主模块的包。增加-v参数：go mod vendor -v会将添加到vendor中的模块打印到标准输出。</span></span><br></pre></td></tr></table></figure>





<h2 id="按需编译"><a href="#按需编译" class="headerlink" title="按需编译"></a>按需编译</h2><p>有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可 移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型 名字，例如net_linux.go或asm_amd64.s, Go语言的构建工具将只在对应的平台编译这些文 件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释： </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build linux darwin</span></span><br><span class="line"><span class="comment">// 在包声明和包注释的前面，该构建注释参数告诉 go build 只在编译程序对应的目标操作系统 是Linux或Mac OS X时才编译这个文件。</span></span><br></pre></td></tr></table></figure>

<p>下面的构建注释则表示不编译这个文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build ignore</span></span><br></pre></td></tr></table></figure>



<h2 id="GMP"><a href="#GMP" class="headerlink" title="GMP"></a>GMP</h2><ul>
<li><p>M(Machine)：工作线程。 执行系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</p>
</li>
<li><p>P（Processor），是一个抽象的概念，表示逻辑CPU，代表线程M的执行的上下文，调度goroutine。当P有任务时需要创建或者唤醒一个系统线程来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元。P的最大作用是其拥有的<strong>各种G对象队列、链表、cache和状态</strong>。P的数量也代表了golang的执行并发度，即有多少goroutine可以同时运行，可通过GOMAXPROCS限制同时执行用户级任务的操作系统线程。可以通过runtime.GOMAXPROCS进行指定。</p>
</li>
<li><p>G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。</p>
<p>  G协程栈初始分配大小为2k，最大值由操作系统限制，64位为1GB，32位为250MB，以2倍形式增长。</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">@runtime/stack.<span class="keyword">go</span>:<span class="number">72</span></span><br><span class="line"><span class="comment">// The minimum size of stack used by Go code</span></span><br><span class="line">_StackMin = <span class="number">2048</span></span><br><span class="line"></span><br><span class="line">@runtime/proc.<span class="keyword">go</span>:<span class="number">115</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">    maxstacksize = <span class="number">1000000000</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    maxstacksize = <span class="number">250000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  注：</p>
<p>  Linux线程默认大小为8M。windows线程栈默认大小为1M。操作系统线程栈大小可在创建线程（CreateThread）时指定，不可在程序执行过程中动态修改。</p>
</li>
</ul>
<h3 id="GMP关系"><a href="#GMP关系" class="headerlink" title="GMP关系"></a>GMP关系</h3><p>M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。其关系如下图所示： </p>
<p><img src="/2021/09/25/GoLang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211106172814330.png" alt="GMP关系"></p>
<p>图中M是交给操作系统调度的线程，M持有一个P，P将G调度进M中执行。P同时还维护着一个包含G的队列（图中灰色部分），可以按照一定的策略将不能的G调度进M中执行。 </p>
<p>P的个数在程序启动时决定，在Go1.5之后被默认设置CPU的核数，而之前则默认为1。由于M必须持有一个P才可以运行Go代码，所以同时运行的 M个数，也即线程数一般等同于CPU的个数，以达到尽可能的使用CPU而又不至于产生过多的线程切换开销。 </p>
<h3 id="Goroutine调度策略"><a href="#Goroutine调度策略" class="headerlink" title="Goroutine调度策略"></a>Goroutine调度策略</h3><ul>
<li><p><strong>队列轮转</strong></p>
<p>  上图中可见每个P维护着一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行， 执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。 除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期性的查看全局队列中是否有G待运行并将期调度到M 中执行，全局队列中G的来源，主要有从系统调用中恢复的G。之所以P会周期性的查看全局队列，也是为了防止全局队 列中的G被饿死。 </p>
</li>
<li><p><strong>系统调用</strong> </p>
<p>  上面说到P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，这多 出来的M将会在G产生系统调用时发挥作用。类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池 子，不够用时就再创建一个。 </p>
<p>  当M运行的某个G产生系统调用时，如下图所示：<img src="/2021/09/25/GoLang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211106195922043.png" alt="系统调用"></p>
</li>
</ul>
<p>如图所示，当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于 陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。 M1的来源有可能是M的缓存池，也可能是新建的。当G0系统调用结束后，跟据M0是否能获取到P，将会将G0做不同的 处理： </p>
<ol>
<li>如果有空闲的P，则获取一个P，继续执行G0。 </li>
<li>如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。 </li>
</ol>
<ul>
<li><p><strong>工作量窃取</strong></p>
<p>  当P中G全部执行完，会去查询<strong>全局队列</strong>，若全局队列中也没有G，而另一个M中除了正在运行的G 外，队列中还有3个G待运行（如下图所示）。此时，空闲的P会将其他P中的<strong>G偷取一部分过来</strong>，一般每次偷取一半。</p>
</li>
</ul>
<p><img src="/2021/09/25/GoLang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211107164610440.png" alt="image-20211107164610440"></p>
<p>注：从全局队列（GQ）取的 G 数量符合下面的公式：n =  min(len(GQ)/GOMAXPROCS + 1, len(GQ/2)) </p>
<h3 id="m0和g0"><a href="#m0和g0" class="headerlink" title="m0和g0"></a>m0和g0</h3><ul>
<li><p><strong>m0</strong><br>  m0 表示进程启动的第一个线程，也叫主线程。它和其他的m没有什么区别，要说区别的话，它是进程启动通过汇编直接复制给m0的，m0是个全局变量，而其他的m都是runtime内自己创建的。 m0 的赋值过程，可以看前面 runtime/asm_amd64.s 的代码。一个go进程只有一个m0。</p>
</li>
<li><p><strong>g0</strong><br>  首先要明确的是每个m都有一个g0，因为每个线程有一个系统堆栈，g0 虽然也是g的结构，但和普通的g还是有差别的，最重要的差别就是栈的差别。g0 上的栈是系统分配的栈，在linux上栈大小默认固定8MB，不能扩展，也不能缩小。 而普通g一开始只有2KB大小，可扩展。在 g0 上也没有任何任务函数，也没有任何状态，并且它不能被调度程序抢占。因为调度就是在g0上跑的。</p>
</li>
<li><p>proc.go 中的全局变量 m0和g0</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	m0           m</span><br><span class="line">	g0           g</span><br><span class="line">	raceprocctx0 <span class="keyword">uintptr</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在 <code>runtime/proc.go</code> 的文件中声明了两个全局变量，m0表示主线程，这里的g0表示和m0绑定的g0，也可以理解为m0线程的堆栈，这两个变量的赋值是汇编实现的。</p>
<h3 id="调度流程图"><a href="#调度流程图" class="headerlink" title="调度流程图"></a>调度流程图</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">                            +-------------------- sysmon ---------------<span class="comment">//------+ </span></span><br><span class="line">                            |                                                   |</span><br><span class="line">                            |                                                   |</span><br><span class="line">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> ---&gt; | <span class="title">G</span> | ---&gt; | <span class="title">P</span> | <span class="title">local</span> | &lt;=== <span class="title">balance</span> ===&gt; | <span class="title">global</span> | &lt;--//--- | <span class="title">P</span> | <span class="title">M</span> |</span></span><br><span class="line">               +---+      +---+-------+                   +--------+          +---+---+</span><br><span class="line">                            |                                 |                 | </span><br><span class="line">                            |      +---+                      |                 |</span><br><span class="line">                            +----&gt; | M | &lt;--- findrunnable ---+--- steal &lt;--<span class="comment">//--+</span></span><br><span class="line">                                   +---+ </span><br><span class="line">                                     |</span><br><span class="line">                                   mstart</span><br><span class="line">                                     |</span><br><span class="line">              +--- execute &lt;----- schedule </span><br><span class="line">              |                      |   </span><br><span class="line">              |                      |</span><br><span class="line">              +--&gt; G.fn --&gt; goexit --+ </span><br><span class="line"></span><br><span class="line">              <span class="number">1.</span> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> 语气创建<span class="title">G</span>。</span></span><br><span class="line">              <span class="number">2.</span> 将G放入P的本地队列（或者平衡到全局队列）。</span><br><span class="line">              <span class="number">3.</span> 唤醒或新建M来执行任务。</span><br><span class="line">              <span class="number">4.</span> 进入调度循环</span><br><span class="line">              <span class="number">5.</span> 尽力获取可执行的G，并执行</span><br><span class="line">              <span class="number">6.</span> 清理现场并且重新进入调度循环</span><br></pre></td></tr></table></figure>

<p>上图基本上概括了整个调度流程，go 关键字创建了G，并插入到P的本地队列或者全局队列，线程M从各个队列中或者从别的P中得到G， 切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到调度程序，调度程序重新找个可执行的G，并执行，如此反复。 其中 <code>sysmon</code> 会监控整个调度系统，如果某个G长时间占用cpu，会被标记为可抢占。</p>
<p><strong>参考</strong></p>
<p>《Go专家编程》</p>
<p><a href="https://zboya.github.io/post/go_scheduler/">golang runtime的调度</a></p>
<p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html#gmp-%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6">GMP原理与调度</a></p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="包初始化-init函数。"><a href="#包初始化-init函数。" class="headerlink" title="包初始化 init函数。"></a><strong>包初始化 init函数。</strong></h3><p>如果一个包 p 导入了包 q，那么 q 的 init 函数完成<strong>happens before</strong> p 的 init 。main.main 函数的开始<strong>happens after</strong> 所有的 init 函数完成。</p>
<h3 id="创建goroutine"><a href="#创建goroutine" class="headerlink" title="创建goroutine"></a><strong>创建goroutine</strong></h3><p>创建goroutine <strong>happens before</strong> goroutine执行。</p>
<h3 id="销毁goroutine"><a href="#销毁goroutine" class="headerlink" title="销毁goroutine"></a><strong>销毁goroutine</strong></h3><p>goroutine执行<strong>happens before</strong> goroutine的销毁。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a><strong>锁</strong></h3><ol>
<li><p>对任意的sync.Mutex或sync.RWMutex变量l和n &lt; m，n次调用l.Unlock()先行发生于m次l.Lock()返回。</p>
</li>
<li><p>对于sync.RWMutex变量l，任意的函数调用l.RLock满足第n次l.RLock后发生于第n次调用l.Unlock，对应的l.RUnlock先行发生于第n+1次调用l.Lock。</p>
</li>
</ol>
<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a><strong>Once</strong></h3><p>sync.Once对于 f() 的单个调用在所有的 once.Do(f) 返回之前发生。</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a><strong>channel</strong></h3><ol>
<li>对一个channel的发送操作 happens-before 相应channel的接收操作完成。</li>
<li>关闭一个channel happens-before 从该Channel接收到最后的返回值0。</li>
<li>不带缓冲的channel的接收操作 happens-before 相应channel的发送操作完成。</li>
</ol>
<h2 id="其他知识链接"><a href="#其他知识链接" class="headerlink" title="其他知识链接"></a>其他知识链接</h2><p><a href="https://studygolang.com/pkgdoc">goSDK中文文档</a></p>
<p><a href="https://gin-gonic.com/">Gin Web Framework</a></p>
<p><a href="https://beego.me/">Beego Framework</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODg0NDkzOA==&mid=2247487157&idx=1&sn=cbf1c87efe98433e07a2e58ee6e9899e&source=41#wechat_redirect">go跟踪剖析工具trace</a></p>
<p><a href="https://mp.weixin.qq.com/s/d0olIiZgZNyZsO-OZDiEoA">Go的性能分析工具pprof</a></p>
<p><a href="https://studygolang.com/articles/685">利用unsafe操作未导出变量</a></p>
<p><a href="https://www.bookstack.cn/read/qcrao-Go-Questions/channel-%E4%BB%80%E4%B9%88%E6%98%AF%20CSP.md">Go问题收集</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>GoLang</category>
      </categories>
      <tags>
        <tag>Go基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础</title>
    <url>/2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><a href="https://redis.io/">官网</a></p>
<p><a href="http://www.redis.cn/">中文文档</a></p>
<p><a href="https://github.com/redis/">git地址</a></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal">Pivotal</a>赞助。（百度百科）</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</li>
<li>redis默认16个数据库，类似数组下表从零开始，默认数据库为0，可以使用SELECT  id 命令切换指定数据库。</li>
<li>Redis索引都是从零开始</li>
<li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</li>
<li>redis6.0前是单线程的，6.0后支持多线程，默认单线程</li>
</ul>
<h4 id="redis使用单线程原因"><a href="#redis使用单线程原因" class="headerlink" title="redis使用单线程原因"></a>redis使用单线程原因</h4><ol>
<li>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。</li>
<li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li>
</ol>
<!--注：Redis进行持久化的时候会以子进程或者子线程的方式执行-->

<h4 id="Redis的高并发和快速原因"><a href="#Redis的高并发和快速原因" class="headerlink" title="Redis的高并发和快速原因"></a><strong>Redis的高并发和快速原因</strong></h4><ol>
<li>redis是基于内存的，内存的读写速度比硬盘快得多；（CPU高速缓存&gt;内存&gt;外存（硬盘、光盘、U盘等））</li>
<li>redis是单线程的，省去了很多CPU上下文切换线程的时间；(CPU上下文切换是很耗内存的)</li>
<li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll（Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。）和自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。“多路”指的是多个socket连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>keys * ：查看所有key（*匹配所有字符，？匹配单个字符,如 keys  ?ist可匹配 list，aist，bist……）</li>
<li>info 查看redis详细信息，key数量也在里面</li>
<li>set key value：存入键值对</li>
<li>get key：获取key对应值</li>
<li>DBSIZE：查看当前基本数据库大小（当前数据库的key的数量）。</li>
<li>Flushdb：清空当前库 | Flushall：通杀全部库</li>
<li>exists key : 判断key是否存在（存在返回1，不存在返回2）</li>
<li>del key：删除key</li>
<li>rename key newname：重命名key</li>
<li>move key  db_id  ：将当前数据库的 key 移动到给定的数据库 db 当中。</li>
<li>type key ：查看当前key存储类型</li>
<li>expire key second(秒) 设置超时时间（即几秒后过期）</li>
<li>ttl key 查看key剩余时间（-1表示永久有效，-2表示当前key不存在）</li>
<li>persist key 移除过期时间，让key永久有效</li>
<li>set key value [EX seconds] [PX milliseconds] [NX|XX] (EX 200：200秒后过期，NX：key不存在才操作，XX： key已存在才操作)</li>
<li>shutdown：关闭redis</li>
</ul>
<h3 id="设置修改密码"><a href="#设置修改密码" class="headerlink" title="设置修改密码"></a>设置修改密码</h3><h4 id="1-客户端连接修改"><a href="#1-客户端连接修改" class="headerlink" title="1.客户端连接修改"></a>1.<strong>客户端连接修改</strong></h4><!--立即生效，具有临时性，重启失效-->

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##到安装目录下打开命令行</span></span><br><span class="line"><span class="comment">#wingdow下客户端连接 redis-cli.exe -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"><span class="comment">#Linux下客户端连接 ./redis-cli -h &#123;ip&#125; -p &#123;端口&#125; [-a &#123;密码&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##查看密码（默认为空）</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;&quot;  //默认空</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置密码 config set requirepass 123456</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; config set requirepass 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass //密码设置后必须先验证通过密码，否则所有命令都不可用</span></span><br><span class="line"><span class="meta">(error)</span> <span class="string">NOAUTH Authentication required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#验证密码 auth &#123;密码&#125;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; auth 123456</span></span><br><span class="line"><span class="attr">OK</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt; CONFIG GET requirepass</span></span><br><span class="line"><span class="meta">1)</span> <span class="string">&quot;requirepass&quot;</span></span><br><span class="line"><span class="meta">2)</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="meta">127.0.0.1</span>:<span class="string">6379&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.<strong>修改配置文件</strong></h4><!-- 永久生效-->

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找到redis.conf配置文件中的requirepass</span></span><br><span class="line"><span class="comment">#requirepass foobared</span></span><br><span class="line"><span class="comment">#去掉注释配置自己密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">&#123;密码&#125;</span></span><br><span class="line"><span class="attr">保存后重启</span></span><br></pre></td></tr></table></figure>



<h3 id="五大基本类型"><a href="#五大基本类型" class="headerlink" title="五大基本类型"></a>五大基本类型</h3><h4 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h4><p>​        String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p>
<p>​        底层没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了<strong>SDS</strong>(简单动态字符串/Simple Dynamic String)</p>
<p>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>
<p>补：String内部编码有三种方式，可使用object encoding key 查看。</p>
<ol>
<li>int ： 长度小于20且保存的是64位有符号整型类型。</li>
<li>embstr：长度小于等于44，对于嵌入式的String，从内存结构上说，就是字符串sds结构体与其对应的redisObject对象分配在同一块连续的内存空间，<strong>只需一次内存分配</strong>。</li>
<li>raw：长度大于44，redisObject内存不在连续，采用指针的形式，实现连接。<strong>需要分配两次内存空间</strong>（分别为redisObject和sds分配空间）。</li>
</ol>
<p><strong>注：Redis中每个对象都是由redisObject表示的</strong></p>
<p><img src="/2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/image-20210406141632606.png" alt="image-20210406141632606"></p>
<h5 id="常用操作："><a href="#常用操作：" class="headerlink" title="常用操作："></a>常用操作：</h5><ol>
<li><p>append key value ：往字符串后面追加字符串（若key不存在，则新建key，相当于set key value）</p>
</li>
<li><p>strlen key ：返回字符串长度</p>
</li>
<li><p>incr key： 自增1</p>
</li>
<li><p>decr key：自减1</p>
</li>
<li><p>incrby key num：自增num</p>
</li>
<li><p>decrby key num：自减num</p>
</li>
<li><p>getrange key start end ：截取字符串[start,end] [0,-1]表示全部</p>
</li>
<li><p>setrange key start str ：用str替换指定位置开始的字符串</p>
</li>
<li><p>setex  key seconds value：保存key-value并设置过期时间（set with expire）</p>
</li>
<li><p>setnx key value：不存在则设置（set if not exist），成功返回1，若已存在，则创建失败，返回-1</p>
</li>
<li><p>mset  k1 v1 k2 v2 k3 v3：同时设置多个值</p>
</li>
<li><p>mget  k1 k2 k3： 同时获取多个值</p>
</li>
<li><p>getset key value：先get后set，如果不存在则返回null，如果存在，则返回旧值，再设置新值</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/yangbodong22011/article/details/78419966">深入理解String</a></p>
<h5 id="SDS组成结构"><a href="#SDS组成结构" class="headerlink" title="SDS组成结构"></a>SDS组成结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>len：SDS字符串已使用的空间。</li>
<li>alloc：申请的空间，减去len就是未使用的空间，初始时和len一致。</li>
<li>flag：只使用了低三位表示类型，细化了SDS的分类，根据字符串的长度的不同选择不同的sds结构体，而结构体的主要区别是len和alloc的类型，这样做可以节省一部分空间大小。</li>
<li>buf:  用了C的特性表示不定长字符串。</li>
</ul>
<h4 id="列表（List"><a href="#列表（List" class="headerlink" title="列表（List)"></a>列表（List)</h4><p>​        列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层是<strong>压缩列表（ziplist）或双端链表（linkedlist）</strong>（Redis3.2后改为快表quicklist，前两个的结合，实际上是个双端链表，链节点上存着压缩列表的引用指针）。</p>
<h5 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li><p>LPUSH list value1  value2 value3 …… ：将一个或多个值插入列表头部（左部）</p>
</li>
<li><p>LRANGE  list start end ：[start,end]通过区间获取列表具体值,[0,-1]获取list全部</p>
</li>
<li><p>RPUSH list  value1  value2 value3 …… ：将一个或多个值插入列表尾部（右部）</p>
</li>
<li><p>LPOP list ：移除列表的第一个元素</p>
</li>
<li><p>RPOP list：移除列表的最后一个值</p>
</li>
<li><p>Lindex list  index ：通过下标获取 元素</p>
</li>
<li><p>Llen list：返回列表长度</p>
</li>
<li><p>Lrem lsit  count value：移除list中count个value</p>
</li>
<li><p>ltrim list start end：通过下标截取list，原list已经被改变</p>
</li>
<li><p>rpoplpush sourceList newList：移除sourceList列表的最后一个元素，将他移动到newList列表中</p>
</li>
<li><p>lset list index newvalue： 替换将列表指定下标值（list或index不存在则报错）</p>
</li>
<li><p>linsert list value before|after newValue：将某一个具体的newValue插入到第一个value前面|后面</p>
</li>
</ol>
<h4 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h4><p>Set是string类型的无序集合，不可重复。它是通过<strong>整数集合（intset）【当集合中的元素都是整数，且元素个数小于set-max-intset-entries配置值（默认512个）】或哈希表（hashtable）</strong>实现的。</p>
<h5 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li>sadd set value1 value2 value3 ……：往set集合添加元素</li>
<li>smembers set：查看set元素</li>
<li>sismembers set  value：是否存在指定元素（存在返回1，不存在返回0）</li>
<li>scard set：查看set集合元素数</li>
<li>srem set value ：移除set集合指定元素</li>
<li>srandmember set （count）：随机抽取num个元素（count不写默认一个）</li>
<li>spop  set （count）：随机移除count个元素</li>
<li>smove  set1 set2 value：将set1中value移动到set2中</li>
<li>sdiff set1 set2：set1与set2取差集，返回set1中存在，set2不存在的元素集合</li>
<li>sinter set1 set2 ：取交集</li>
<li>sunion set1 set2：取并集</li>
</ol>
<h4 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希(Hash)"></a>哈希(Hash)</h4><p>hash 是一个键值对集合,是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;。底层是<strong>压缩列表（ziplist）或哈希表（hashtable）</strong>实现。</p>
<h5 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li>hset hash key value ：存入hash一个 key-value键值对</li>
<li>hget  hash key：获取hash中key的值</li>
<li>hmset hash key1 value1 key2 value2 ……：存入hash多个键值对</li>
<li>hmget hash key1 key2 ……：获取hash多个key字段的值</li>
<li>hgetall hash ：获取全部key-value内容</li>
<li>hdel hash key ：删除hash中指定key字段</li>
<li>hlen hash ：返回hash长度</li>
<li>hexists hash key：判断hash中key字段是否存在</li>
<li>hkeys hash：返回所有key字段</li>
<li>hvals  hash：放回所有value</li>
<li>hincrby hash key  num：指定key增量num</li>
<li>hsetnx hash key value：不存在则存入</li>
</ol>
<h4 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合(Zset)"></a>有序集合(Zset)</h4><p>zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。底层使用<strong>压缩列表（ziplist）或跳跃表（skiplist）</strong>实现。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>
<h5 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h5><ol>
<li><p>ZADD key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数.</p>
</li>
<li><p>ZCARD key 获取有序集合的成员数.</p>
</li>
<li><p>ZCOUNT key min max 计算在有序集合中指定区间分数[min,max]的成员数。</p>
</li>
<li><p>ZINCRBY key increment member:有序集合中对指定成员的分数加上增量 increment。</p>
</li>
<li><p>ZINTERSTORE newkey num key …:计算给定的一个或多(num)个有序集key的交集并将结果集存储在新的有序集合 newkey 中。</p>
</li>
<li><p>ZLEXCOUNT key min max:在有序集合中计算指定字典区间内成员数量。</p>
<p> min max: { - [a =(-∞，a]; -  (a=(-∞，a)；[a [b=[a,b];-  +=(-∞,+∞)</p>
</li>
<li><p>ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员。-inf +inf = -∞ +∞</p>
</li>
<li><p>ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员。</p>
</li>
<li><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员。</p>
</li>
<li><p>ZRANK key member 返回有序集合中指定成员的索引。</p>
</li>
<li><p>ZREM key member [member …] 移除有序集合中的一个或多个成员。</p>
</li>
<li><p>ZREMRANGEBYLEX key min max :移除有序集合中给定的字典区间的所有成员。</p>
</li>
<li><p>ZREMRANGEBYRANK key start stop:移除有序集合中给定的排名区间的所有成员。</p>
</li>
<li><p>ZREMRANGEBYSCORE key min max移除有序集合中给定的分数区间的所有成员。</p>
</li>
<li><p>ZREVRANGE key start stop [WITHSCORES]返回有序集中指定区间内的成员，通过索引，分数从高到低。</p>
</li>
<li><p>ZREVRANGEBYSCORE key max min [WITHSCORES]返回有序集中指定分数区间内的成员，分数从高到低排序。</p>
</li>
<li><p>ZREVRANK key member返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序。</p>
</li>
<li><p>ZSCORE key member返回有序集中，成员的分数值。</p>
</li>
<li><p>ZUNIONSTORE destination numkeys key [key …]计算给定的一个或多个有序集的并集，并存储在新的 key 中。</p>
</li>
<li><p>ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）。</p>
</li>
</ol>
<h5 id="注"><a href="#注" class="headerlink" title="注"></a>注</h5><p>​    集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)，其实不太准确。</p>
<p>​    其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： </p>
<ul>
<li>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 </li>
<li>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) </li>
<li>其他的range操作复杂度一般为O(log(n))</li>
<li>当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)</li>
</ul>
<h4 id="五大基本类型底层实现"><a href="#五大基本类型底层实现" class="headerlink" title="五大基本类型底层实现"></a>五大基本类型底层实现</h4><p><img src="/2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/Snipaste_2021-03-25_00-12-59.png" alt="Snipaste_2021-03-25_00-12-59"></p>
<h4 id="hashtable结构图"><a href="#hashtable结构图" class="headerlink" title="hashtable结构图"></a>hashtable结构图</h4><p><img src="/2020/09/23/Redis/Redis%E5%9F%BA%E7%A1%80/20190623214252310.png" alt="hashtable结构图"></p>
<h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><h4 id="地理空间（geospatial-）"><a href="#地理空间（geospatial-）" class="headerlink" title="地理空间（geospatial ）"></a>地理空间（geospatial ）</h4><p>​    Redis的Geo，3.2版本推出，可以推算地理位置的信息，两地之间的距离</p>
<p>​    城市经纬度查询：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p>
<!--**注：有效经度为-180至180度。有效纬度为-85.05112878至85.05112878度。**-->

<h5 id="六大操作"><a href="#六大操作" class="headerlink" title="六大操作"></a>六大操作</h5><p><strong>geoadd   key  经度 维度 坐标名</strong>：添加地理位置（两级无法直接添加，可一次添加多个）， 先经度后维度（官方文档疑似写错了）</p>
<p>例：geoadd china:city   116.405285  39.904989     beijing    121.4   31.2  shanghai  ……</p>
<p>​                        key            经度     维度    地理名称</p>
<p><strong>geopos key  name1 name2……</strong>：获取key中name的地理位置</p>
<p>例：GEOPOS china:city beijing shanghai shenzhen xianggang</p>
<p><strong>georadius key  经度 维度 距离：</strong> 以给定的经纬度为中心，找出某一半径内所有的元素</p>
<p>例：GEORADIUS china:city 110 30 1000 km [withcoord] [withdist]</p>
<p><strong>GEORADIUSBYMEMBER key  坐标名（元素名） 距离</strong> ：根据给定的元素确定中心点，再进行查找</p>
<p>例：GEORADIUSBYMEMBER china:city beijing 1000 km [withcoord] [withdist]</p>
<!--注：withcoord：经纬度,withdist：距离坐标城市的距离，count num：筛选出num个结果-->

<p><strong>GEODIST  key name1  name2 [单位]</strong> ：返回指定单位中两个指定成员之间的距离。如果缺少一个或两个成员，该命令将返回NULL。</p>
<!--单位必须是以下之一，默认为米：m（米）、km（千米）、mi（英里）、ft（英尺）-->

<p>例：GEODIST china:city beijing xianggang km</p>
<p><strong>GEOHASH key name1 name2……</strong>：该命令返回11个字符的Geohash字符串，因此与Redis内部52位表示形式相比，不会损失任何精度。该命令返回一个数组，其中每个元素是与作为参数传递给命令的每个成员名称相对应的Geohash。</p>
<p>返回的Geohashhes具有以下属性：  </p>
<ol>
<li>以从右侧删除字符来缩短它们。它将失去精度，但仍将指向同一区域。</li>
<li>可以在<code>geohash.org</code>URL中使用它们，例如<code>http://geohash.org/&lt;geohash-string&gt;</code>。这是<a href="http://geohash.org/sqdtr74hyu0">此类URL</a>的<a href="http://geohash.org/sqdtr74hyu0">示例</a>。</li>
<li>前缀相似的字符串在附近，但事实并非如此，前缀不同的字符串也可能在附近。</li>
</ol>
<p>geo底层实现原理其实是zset，我们可以使用zset命令操作他</p>
<p>zrange key 0 -1：查看地图key中的所有元素</p>
<p>zrem key member：删除key中指定元素</p>
<h4 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h4><p><strong>简介：Hyperloglog 可用于基数统计（基数：在数学上，是集合论中刻画任意集合集大小的一个概念。即一个集合中不重复的元素数。）</strong></p>
<p><strong>redis2.8.9后更新了hyperloglog数据结构</strong></p>
<p>示例：网页UV</p>
<p>uv（Unique Visitor）:网站的独立访客，统计1天内访问某站点的用户数(以cookie为依据);访问网站的一台电脑客户端为一个访客。可以理解成访问某网站的电脑的数量。</p>
<p>访问用户量大的情况下，若用传统的set集合统计将耗费大量内存。使用hyperloglog基数统计占用内存固定，2^64不同的元素，只需要废12kb内存。（官网统计hyperloglog有0.81%的错误率，但在统计UV任务上，我们可以忽略不计）</p>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>PFADD keyset  value1 value2 value3……往集合keyset中添加元素</p>
<p>PFCOUNT keyset：统计集合keyset的基数</p>
<p>PFMERGE  newset keyset1 ketset2：将集合keyset1和keyset2的元素合并（并集）到newset中</p>
<h4 id="Bitmap（位存储）"><a href="#Bitmap（位存储）" class="headerlink" title="Bitmap（位存储）"></a>Bitmap（位存储）</h4><p><strong>简介：</strong> Biymaps位图，该数据结构都是操作二进制位来记录数据的，就只有0和1两个状态。（适用于只有两个状态的数据）</p>
<h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><p>setbit  sign index  value：往sign的index（从0开始）位置上存value（0或1）</p>
<p>getbit sign index ：获取sign中index位上的值（默认0）</p>
<p>bitcount sign：统计sgin中为1的数量</p>
<p>注：bitcount sign start  end  获取sgin中第start<strong>字节</strong>到end<strong>字节</strong>的1的数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k bb</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># b的二进制表示0110 0010第7位（从0开始）改为1即为c</span></span><br><span class="line">127.0.0.1:6379&gt; setbit k 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line"><span class="string">&quot;cb&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setbit k 7 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get k</span><br><span class="line"><span class="string">&quot;bb&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount k 0 0</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount k 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; bitcount k 0 3</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>



<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础</title>
    <url>/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="JVM架构模型"><a href="#JVM架构模型" class="headerlink" title="JVM架构模型"></a>JVM架构模型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    Java编译器输入的指令流基本上是一种基于栈的指令集架构，与之对比的是另外一种基于寄存器的指令集架构。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="基于栈式架构特点："><a href="#基于栈式架构特点：" class="headerlink" title="基于栈式架构特点："></a>基于栈式架构特点：</h4><ol>
<li>设计简单，资源受限等小型系统也适用。</li>
<li>避开寄存器的分配难题，直接使用零地址指令，指令集更小，实现更加简单。</li>
<li>不需要硬件支持，可移植性更好，更好实现跨平台。</li>
</ol>
<h4 id="基于寄存器架构特点"><a href="#基于寄存器架构特点" class="headerlink" title="基于寄存器架构特点"></a>基于寄存器架构特点</h4><ol>
<li>指令集架构完全依赖硬件，可移植性差。</li>
<li>指令执行更高效，性能更好。</li>
<li>花费更少指令完成一项操作。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于跨平台的设计，java的指令都是根据栈来设计的，不同平台的CPU架构不同，所以不能设计基于寄存器的。基于栈来设计的<strong>优点</strong>是跨平台，指令集小，编译器更容易实现。<strong>缺点</strong>是性能下降，实现同一项操作需要更多指令。</p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>通过引导类加载器（bootstrap class loader）创建一个初始类来完成，一个Jvm启动后就是一个进程。</p>
<p>注：可在命令窗口使用jps指令查看当前进程id</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>执行Java程序，即执行一个叫做java虚拟机的进程。</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ol>
<li>程序执行结束正常退出。</li>
<li>程序执行过程中遇到异常或错误而异常终止。</li>
<li>操作系统出现错误导致JVM进程终止。</li>
<li>程序中执行System.exit(status)或Runtime.getRuntime().halt(status)方法。</li>
<li>除此之外，JNI(Java Native Interface)规范描述了JNI Invocation API来加载或卸载java虚拟机时，java虚拟机退出的情况。</li>
</ol>
<h2 id="字节码执行过程"><a href="#字节码执行过程" class="headerlink" title="字节码执行过程"></a>字节码执行过程</h2><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/1.png" alt="jvm整体架构"></p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>​    负责将字节码文件即class文件加载到JVM中，加载的类信息将存储于JVM运行时数据区的方法区中。（除类信息外，方法区还存放运行时的常量池信息等）</p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/2.png" alt="image-20201115151642295"></p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过类的全限定类名获取此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>1.验证（Verify）</p>
<p>目的：保证Class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性以及虚拟机自身安全。</p>
<ul>
<li>​    文件格式验证</li>
<li>​    元数据验证</li>
<li>​    字节码验证</li>
<li>​    符号引用验证</li>
</ul>
<p>2.准备（Prepare）</p>
<p>​    为类变量（静态属性）分配内存并设置默认初始值，即零值。</p>
<p>注：</p>
<ul>
<li>final修饰的static除外，因为final在编译的时候就分配了，准备阶段会显式初始化。</li>
<li>实例变量（普通属性）不会被分配初始化，类变量会被分配在方法区中，而实例变量会随java对象一起分配在堆中。</li>
</ul>
<p>3.解析(Pesolve)</p>
<p>​    将常量池的符号引用转换为直接引用（直接引用就是直接指向目标的指针，相对偏移量或间接定位到目标的句柄）。主要针对的是类的接口、字段、类方法、接口方法、方法类型等。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>本质：就是执行类构造方法clinit()的过程。</li>
<li>此方法不需要定义，javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句。</li>
<li>指令的执行顺序会按代码在源文件出现的顺序执行。</li>
<li>若该类有父类，JVM会先加载并执行完父类的clinit()方法。clinit()方法在多线程下是被同步加锁的。</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>注：所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器（User-Defined ClassLoader）（即只有Bootstrap 不是）。</p>
<h4 id="引导（启动）类加载器（Bootstrap-ClassLoader）"><a href="#引导（启动）类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导（启动）类加载器（Bootstrap ClassLoader）"></a>引导（启动）类加载器（Bootstrap ClassLoader）</h4><ol>
<li>由C/C++语言实现，嵌套在JVM内部。</li>
<li>用来加载Java核心库（JAVA_HOME/jre/lib/rt.jar、resourse.jar或sun.boot.class.path路径下的内容），提供JVM自身所需类。</li>
<li>并不继承自java.lang.ClassLoader,没有父加载器，加载扩展类加载器并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap启动加载器只加载包名为java、javax、sun等开头的类。</li>
</ol>
<h4 id="扩展类加载器（ExClassLoader）"><a href="#扩展类加载器（ExClassLoader）" class="headerlink" title="扩展类加载器（ExClassLoader）"></a>扩展类加载器（ExClassLoader）</h4><ol>
<li>Java语言编写，由sun.mis.Launcher$ExtClassLoader实现。</li>
<li>派生于ClassLoader类，父类加载器为Bootsrap ClassLoader 。</li>
<li>从java.ext.dirs系统属性所加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR包放在此目录下，也会自动由扩展类加载器加载。</li>
</ol>
<h4 id="系统类（应用程序类）加载器（AppClassLoader）"><a href="#系统类（应用程序类）加载器（AppClassLoader）" class="headerlink" title="系统类（应用程序类）加载器（AppClassLoader）"></a>系统类（应用程序类）加载器（AppClassLoader）</h4><ol>
<li>Java语言编写，由sun.mis.Launcher$AppClassLoader实现。</li>
<li>派生于ClassLoader类，父类加载器为Bootsrap ClassLoader 。</li>
<li>负责加载类环境变量classpath或系统属性 java.class.path 指定路径下的类库</li>
<li>程序中的默认加载器，一般来说，Java应用类都是由它来完成加载</li>
<li>可以通过ClassLoader.getSystemClassLoader()方法获取</li>
</ol>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><ol>
<li>作用：隔离加载类、修改加载方式、扩展加载源、防止源码泄露。</li>
<li>实现：可继承java.lang.ClassLoader或java.net.URLClassLoader类实现自己的类加载器，</li>
</ol>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>一个加载器收到类加载请求，不会自己先去加载，而是先将请求委托给父类的加载器去执行，若父类加载器还有其父类加载器，则进一步向上委托，依次递归到启动类加载器，父类加载器可以加载则成功返回，无法加载则子类再去加载。</p>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a><strong>优势：</strong></h4><p>避免类重复加载，保护程序安全，防止核心API被随意算改</p>
<h4 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h4><p>​    如我们在程序中自己定义了一个 String 类，但是加载自定义 String 类的时候会先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 java\lang\String.class），这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​    又称PC计数器、指令计数器，程序钩子。JVM的PC寄存器是对物理PC寄存器的抽象模拟。占用内存少，几乎可忽略不记，运行速度最快的存储区域。在JVM规范中，<strong>每个线程独享一个程序计数器</strong>，生命周期与线程一致。任何时期每个线程都只有一个方法在执行，也就是当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；如果是正在执行本地方法，则是未指定值（undefned）。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</li>
<li>程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li>
<li>字节码解释器工作时需要通过计数器的值来选取下一条需要执行的字节码指令。</li>
<li>它是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>
<h3 id="虚拟机栈-JVM-Stacks"><a href="#虚拟机栈-JVM-Stacks" class="headerlink" title="虚拟机栈(JVM Stacks)"></a>虚拟机栈(JVM Stacks)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈，<strong>每个线程在创建时都会创建一个虚拟机栈</strong>，其内部保存一个个栈帧（Stack Frame），对应着一次次的Java方法调用。生命周期与线程一致。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li>
<li>JVM对Java的栈操作只有两个：进栈（入栈、压栈）【方法执行】，出栈【方法结束】。</li>
<li><strong>栈不存在垃圾回收问题。</strong></li>
</ol>
<h4 id="可能存在异常"><a href="#可能存在异常" class="headerlink" title="可能存在异常"></a>可能存在异常</h4><ul>
<li>栈大小固定：StackOverflowError</li>
<li>栈大小可动态扩展：OutOfMemoryError</li>
</ul>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><ul>
<li><h5 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h5></li>
</ul>
<p>又称局部变量数组或本地变量表，定义为一个数字数组，主要存储方法参数和定义在方法体内的局部变量【基本数据类型、对象引用、以及returnAddress类型】，局部变量表是建立在线程栈上的，线程私有，不存在数据安全问题，表容量大小是编译期确定下来，最基本单位是slot（变量槽）32位以内类型占一个slot，64位类型占两个。</p>
<p><strong>注：若当前帧是由构造方法或实例方法创建的，那么该栈帧的slot的index=0存放的是该对象的引用—this</strong></p>
<ul>
<li><h5 id="操作数栈-Operand-Stack-或-表达式栈"><a href="#操作数栈-Operand-Stack-或-表达式栈" class="headerlink" title="操作数栈(Operand Stack)(或 表达式栈)"></a>操作数栈(Operand Stack)(或 表达式栈)</h5></li>
</ul>
<p>在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。主要用于保存计算过程的中间结果。其栈深度在编译期就定义好，保存在方法的Code属性中，为max_stack的值。32位占一个、64位占两个单位的栈深度。</p>
<p>栈顶缓存（Top-of-Stack Cashing）技术：将栈顶元素全部缓存在物理cpu的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。</p>
<ul>
<li><h5 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h5></li>
</ul>
<p>每个栈帧都包含一个指向常量池中该栈帧所属方法的引用。动态链接就是将变量和方法的引用转换为调用方法的直接引用</p>
<ul>
<li><h5 id="方法返回值-Return-Address-（或方法退出或异常退出的定义）"><a href="#方法返回值-Return-Address-（或方法退出或异常退出的定义）" class="headerlink" title="方法返回值(Return Address)（或方法退出或异常退出的定义）"></a>方法返回值(Return Address)（或方法退出或异常退出的定义）</h5></li>
</ul>
<p>正常退出：调用者的pc计数器的值作为返回地址，即调用该方法的下一条指令地址。</p>
<p>异常退出：异常表来确定。</p>
<p>区别：异常退出的不会给他的上层调用者产生任何返回值。</p>
<ul>
<li><h5 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h5></li>
</ul>
<p>对程序调试提供支持的信息</p>
<h3 id="本地方法栈-Native-Method-Stacks"><a href="#本地方法栈-Native-Method-Stacks" class="headerlink" title="本地方法栈(Native Method Stacks)"></a>本地方法栈(Native Method Stacks)</h3><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域（最大的内存空间），堆可以在物理上不连续，但在逻辑上它应该被视为连续的，<strong>堆区域是所有线程共享的</strong>，但也有划分出线程私有的缓存区Thread Local Allocation Buffer（TLAB，解决指针冲突）。</p>
<p>可细分为新生区和养老区；</p>
<p>新生区又可细分为Eden，Survivor0，Survivor1三个空间 （也称Eden, from, to）， 官网说默认比例是8:1:1 。</p>
<p>实际操作发现并不是，需关闭自适应内存分配策略：-XX:-UseAdaptiveSizePolicy，或直接通过-XX:SurvivorRatio=8调整此比例</p>
<h4 id="设置堆空间新生代和老年代占比"><a href="#设置堆空间新生代和老年代占比" class="headerlink" title="设置堆空间新生代和老年代占比"></a>设置堆空间新生代和老年代占比</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:NewRatio= <span class="comment">#设置新生代和老年代空间占比，默认2</span></span><br><span class="line">-XX:NewRatio=2 <span class="comment">#表示新生代占1，老年代占2，新生代占整个堆空间的1/3</span></span><br><span class="line">-XX:NewRatio=4 <span class="comment">#表示新生代占1，老年代占4，新生代占整个堆空间的1/5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行查看此参数</span></span><br><span class="line">&gt;jinfo -flag NewRatio 【进程id】</span><br><span class="line">-XX:NewRatio=2</span><br></pre></td></tr></table></figure>



<p>idea可直接在Run-&gt;Eidt Configurations-&gt;VM options里设置（注：设置多个时用空格隔开）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-X 是jvm的运行参数 m是memory， s是start， x是max</span></span><br><span class="line"><span class="comment">#官网建议： For server deployments, -Xms and -Xmx are often set to the same value.</span></span><br><span class="line">-Xms300m <span class="comment">#设置堆空间（年轻代+老年代）的初始内存大小300M ,单位不指定默认字节（k,m,g）</span></span><br><span class="line">-Xmx300m <span class="comment">#设置堆空间（年轻代+老年代）的最大内存大小300M</span></span><br><span class="line"><span class="comment">#不设置默认值：初始内存大小=物理电脑内存/64，最大内存大小=物理电脑内存/4</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">#控制台打印相关参数</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsInitial <span class="comment">#查看所有参数的默认值（就算有指定，也显示默认值）</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintFlagsFinal <span class="comment">#查看所有参数的最终值</span></span><br><span class="line"><span class="comment">#具体查看某个参数指令：命令行输入 </span></span><br><span class="line"><span class="comment">#jps #查看进程id</span></span><br><span class="line"><span class="comment">#jinfo -flag 参数 进程id</span></span><br><span class="line">如：</span><br><span class="line">&gt;jps</span><br><span class="line">2932 Jps</span><br><span class="line">6628</span><br><span class="line">11944 Launcher</span><br><span class="line">12952 RemoteMavenServer</span><br><span class="line">13096 Launcher</span><br><span class="line">6392 Launcher</span><br><span class="line">&gt;jinfo -flag SurvivorRatio 13096</span><br><span class="line">-XX:SurvivorRatio=8</span><br><span class="line"></span><br><span class="line">-Xmn <span class="comment">#设置新生代大小</span></span><br><span class="line"></span><br><span class="line">-XX:NewRatio <span class="comment">#配置新生代与老年代在堆中占比</span></span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio <span class="comment">#设置新生代中Eden和s0/s1空间比例</span></span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold <span class="comment">#设置新生代垃圾最大年龄 （默认15岁进入老年代）</span></span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">#输出详细的Gc处理日志</span></span><br><span class="line"><span class="comment">#打印GC简要信息 -XX:+PrintGC 或 -verbose:gc</span></span><br><span class="line"></span><br><span class="line">-XX:HandlePromotionFailure <span class="comment">#是否设置空间分配担保</span></span><br></pre></td></tr></table></figure>



<h4 id="命令行查看运行参数"><a href="#命令行查看运行参数" class="headerlink" title="命令行查看运行参数"></a>命令行查看运行参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jstat -gc 【进程id】 【打印间隔时间单位（秒或毫秒），不指定默认毫秒】(不写只打印一次)<span class="comment">#查看进程GC情况</span></span><br><span class="line"></span><br><span class="line">&gt;jstat -gc 48476</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC …… </span><br><span class="line">7680.0 1024.0  0.0   768.0  63488.0  34050.8   70656.0     5471.6   24064.0 23307.3 2816.0 2640.8  5…… </span><br></pre></td></tr></table></figure>



<h4 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h4><p><img src="/2020/11/15/JVM/jvm%E5%9F%BA%E7%A1%80/image-20201115210033571.png" alt="image-20201115210033571"></p>
<h5 id="STW（Stop-The-World）："><a href="#STW（Stop-The-World）：" class="headerlink" title="STW（Stop The World）："></a>STW（Stop The World）：</h5><p>​    指在进行垃圾回收时，暂停其它用户线程，等垃圾回收结束，用户线程才能恢复运行。</p>
<h5 id="新生代收集MinorGC（Young-GC）"><a href="#新生代收集MinorGC（Young-GC）" class="headerlink" title="新生代收集MinorGC（Young GC）"></a>新生代收集MinorGC（Young GC）</h5><p>清理年轻代的内存，Survivor中基数达到15的对象移至老年代，当年轻代Eden空间满时触发，Survuivor满不会触发GC</p>
<h5 id="老年代收集MajorGC-Old-GC"><a href="#老年代收集MajorGC-Old-GC" class="headerlink" title="老年代收集MajorGC(Old GC)"></a>老年代收集MajorGC(Old GC)</h5><p>目前只有CMS GC会有单独收集老年代的行为，很多时候Major GC会和Full GC混合使用。Major GC的速度一般会比Minor GC慢10倍以上。STW更长</p>
<p>Major GC经常会胖随至少一次Minor  GC，若Major GC后内存还不足，就直接报OOM。</p>
<h5 id="混合收集（Mixed-GC）"><a href="#混合收集（Mixed-GC）" class="headerlink" title="混合收集（Mixed GC）"></a>混合收集（Mixed GC）</h5><p>目前只有G1 GC会有这种行为。</p>
<h5 id="整堆收集FullGC"><a href="#整堆收集FullGC" class="headerlink" title="整堆收集FullGC"></a>整堆收集FullGC</h5><p>收集整个java堆和方法区的垃圾。</p>
<p>触发条件：</p>
<ol>
<li>调用System.gc(),系统建议执行，但不是必须执行。</li>
<li>老年代空间不足。</li>
<li>方法区空间不足。</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</li>
</ol>
<h3 id="方法区-Metaspace"><a href="#方法区-Metaspace" class="headerlink" title="方法区(Metaspace)"></a>方法区(Metaspace)</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>方法区是线程共享的，jdk7以前永久代实现，jdk8后改为元空间（Metaspace ）使用本地内存。存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><a href="https://blog.csdn.net/duoyu779553/article/details/105878755/">参考链接</a></p>
<p><a href="https://blog.csdn.net/qingtiantianqing/article/details/51405517">参考链接</a></p>
<h2 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h2><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p>
<p><a href="https://www.hollischuang.com/archives/2398">参考链接</a></p>
<p><a href="https://blog.csdn.net/hollis_chuang/article/details/80922794">参考链接2</a></p>
<p>jdk1.7后默认开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis #开启方法逃逸</span><br><span class="line">-XX:-DoEscapeAnalysis #关闭方法逃逸</span><br></pre></td></tr></table></figure>



<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>一、<strong>为什么要字节码，用不同平台虚拟机直接将java代码编译成对应指令集不就行？</strong></p>
<ol>
<li>准备工作：（源代码———&gt; 机器码）每次执行都需要检查语法和语义检查，每次执行语义分析的结果都不会被保留下来，都要重新编译，重新去分析，整体性能会受到影响，做很多重复的事情，因此引出中间字节码，保证一次编译，多次运行时不需要重复校验。</li>
<li>兼容性：也可以将别的语言解析成字节码，例如scala，生成字节码同样也可以被JVM调用执行，提高平台兼容扩展能力，符合软件设计的中庸之道。</li>
</ol>
<p>二、<strong>堆是内存分配对象的唯一选择码？</strong></p>
<p>　    随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。<br>　　在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。<br>　　此外，基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (Gcinvisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且Gc不能管理GCIH内部的Java对象，以此达到降低Gc的回收频率和提升GC的回收效率的目的。</p>
<p>注：《深入理解Java虚拟机》</p>
<p>三、 <strong>什么是解释器（Interpreter），什么是即时编译器(JIT)</strong></p>
<p>​    <strong>解释器：</strong>当java虚拟机启动时，会根据预定义的规范对字节码文件进行逐行解释的方式执行。每条指令都会被翻译成机械指令执行。</p>
<p>​    <strong>JIT（Just In Time）编译器：</strong>虚拟机直接将源码转换成可以直接发送给处理器的指令的程序。</p>
<p>四、 <strong>为什么说java是半编译半解释型语言</strong></p>
<ol>
<li>jdk1.0时代，java虚拟机的执行引擎只用解释器将字节码逐行翻译成机械指令执行，效率较慢，此时可算解释型语言。</li>
<li>现在虚拟机的执行引擎里有JIT编译器，可直接将方法编译成机械码后再执行，通常两者会结合使用，所以说java是半编译半解释型语言。</li>
</ol>
<p>五、<strong>JIT比解释器快，为啥不直接只使用JIT</strong></p>
<p>​    虚拟机刚启动时，解释器可以先发挥作用（表现为启动时响应用户更快），即时编译器全部编译完再执行，需要一定时间等待。随着时间的推移，即时编译器逐渐发挥作用，利用热点探测功能， 将有价值的字节码编译成本地机械指令，以换取更高的执行效率。</p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>框架源码学习</title>
    <url>/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring是一个轻量级的IOC和AOP容器框架，是为Java应用程序提供基础性服务的一套框架，目的是简化企业应用程序的开发，使开发者只需关心业务需求，将对象之间的依赖关系交由框架处理，减低组件的耦合性。</p>
<h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><ol>
<li>Spring Core：核心类库，所有功能都依赖与它，主要组件是BeanFactory，提供IOC（控制反转）和DI（依赖注入）服务。</li>
<li>Spring Contenxt：提供上下文信息，框架式Bean访问方式，以及企业级功能（JNDI、定时任务、添加国际化的使用、事件传播等）。</li>
<li>Spring AOP： 提供面向切面的编程功能。</li>
<li>Spring Web：提供基本面向Web的综合特性，提供对常见框架（Struts2,SpringMVC）的支持，能够管理这些框架，将Spring资源注入其中，也能在这些框架前后添加拦截器。</li>
<li>Spring MVC ：提供面向Web应用的MVC三层架构（Model-View-Controller）。</li>
<li>Spring Dao：操作数据库模块，对JDBC的抽象封装，简化数据库访问异常处理，并能统一管理JDBC事务。</li>
<li>Spring ORM：对现有ORM（Object Relational Mapping对象关系映射）框架的支持。</li>
</ol>
<p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/115629-c2e1e90a738b75f9.png" alt="核心组件"></p>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a><a href="https://www.cnblogs.com/joy99/p/10941543.html">SpringAOP</a></h3><p><a href="https://blog.csdn.net/jiankunking/article/details/52143504">JDK动态代理</a></p>
<p><a href="https://blog.csdn.net/yhl_jxy/article/details/80633194">CGLIB动态代理</a></p>
<h3 id="spring启动流程"><a href="#spring启动流程" class="headerlink" title="spring启动流程"></a>spring启动流程</h3><h4 id="配置形式：5-2-12-RELEASE"><a href="#配置形式：5-2-12-RELEASE" class="headerlink" title="配置形式：5.2.12.RELEASE"></a>配置形式：5.2.12.RELEASE</h4><ol>
<li>启动代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationConfig.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ClassPathXmlApplicationContext内部</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先加载ContextClosedEvent类</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">// Eagerly load the ContextClosedEvent class to avoid weird classloader issues</span></span><br><span class="line">		<span class="comment">// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)</span></span><br><span class="line">    	<span class="comment">//急切地加载ContextClosedEvent类以避免奇怪的类加载器问题</span></span><br><span class="line">		<span class="comment">//weblogic8.1中的应用程序关闭。（达斯汀·伍兹报道）</span></span><br><span class="line">		ContextClosedEvent.class.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);<span class="comment">//初始化父类</span></span><br><span class="line">	<span class="comment">//设置AbstractRefreshableConfigApplicationContext中的配置文件目录configLocations数组</span></span><br><span class="line">    setConfigLocations(configLocations); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        refresh(); <span class="comment">//IOC真正初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20210401145150319.png" alt="image-20210401145150319"></p>
<ol start="3">
<li>初始化AbstractApplicationContext 父类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>();</span><br><span class="line">	setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//this();无参构造</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//在这之前会初始化必要实例字段，如</span></span><br><span class="line">       <span class="comment">//logger（日志记录）</span></span><br><span class="line">       <span class="comment">//id（容器id），displayName（展示名） 两者值一样，都是		</span></span><br><span class="line">       <span class="comment">//ObjectUtils.identityToString(this);</span></span><br><span class="line">       <span class="comment">//初始化BeanFactoryPostProcessor集合（空ArrayList），</span></span><br><span class="line">       <span class="comment">//原子boolean类active、closed</span></span><br><span class="line">       <span class="comment">//初始化监听器集合（LinkedList）等</span></span><br><span class="line">   </span><br><span class="line">   	<span class="comment">//初始化资源解析器</span></span><br><span class="line">	<span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//Ant模式通配符的ResourceLoader子类资源查找器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用refresh()正真初始化IOC</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">//预处理，设置开始时间以及容器状态，属性验证等</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">//初始化BeanFactory：销毁存在的并新建新的</span></span><br><span class="line">        <span class="comment">//调用loadBeanDefinitions方法使用XmlBeanDefinitionReader加载Bean定义，</span></span><br><span class="line">        <span class="comment">//initBeanDefinitionReader方法通过读取配置文件configLocations数组，解析xml文件，</span></span><br><span class="line">        <span class="comment">//通过beanDefinitionRegistry将BeanDefinition存放到</span></span><br><span class="line">        <span class="comment">//DefaultListableBeanFactory类的Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256)中;</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">//为Bean工厂添加类加载器，表达式解析器（StandardBeanExpressionResolver）、</span></span><br><span class="line">        <span class="comment">//资源编辑器（ResourceEditorRegistrar）、自动装配、</span></span><br><span class="line">        <span class="comment">//Bean工厂早期后置处理器（用以将内部bean检测为ApplicationListeners。）等</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">//提供给想要实现BeanPostProcessor的三方框架使用的。谁要使用谁就去实现。作用是在BeanFactory</span></span><br><span class="line">            <span class="comment">//准备工作完成后做一些定制化的处理，一般结合BeanPostProcessor接口的实现类一起使用，</span></span><br><span class="line">            <span class="comment">//注入一些重要资源（类似Application的属性和ServletContext的属性）</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">//在BeanFactory标准初始化之后执行BeanFactoryPostProcessor的方法，即BeanFactory的后置处理器：</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">//注册Bean后置处理器</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">//初始化MessageSource组件，负责国际功能</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">//初始化事件派发器，在注册监听器时会用到</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">//留给子容器、子类重写这个方法，在容器刷新的时候可以自定义逻辑</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">//查找所有的ApplicationListener监听器并注册到广播器中</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">//初始化所有剩下的单实例bean，核心方法是preInstantiateSingletons()，会调用getBean()方法创建对象；</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">//完成其他工作如清除缓存、发布BeanFactory容器刷新完成事件等，IOC容器初始化结束</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            <span class="comment">//设置active状态为false</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            <span class="comment">//清空非必要缓存如单例元数据</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="注解加载"><a href="#注解加载" class="headerlink" title="注解加载"></a>注解加载</h4><p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/spring%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="spring启动流程"></p>
<p><a href="https://blog.csdn.net/a745233700/article/details/113761271">参考链接</a></p>
<h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/ceef00b5c21677e9c0ec4bfbe400a3c5.png" alt="ceef00b5c21677e9c0ec4bfbe400a3c5"></p>
<p><a href="https://dalin.blog.csdn.net/article/details/113904400">参考链接0</a></p>
<p><a href="https://daimingzhi.blog.csdn.net/article/details/107164508">参考链接1</a></p>
<p><a href="https://www.jb51.net/article/197450.htm">参考链接2</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1497692">参考链接3</a></p>
<p><a href="https://blog.csdn.net/f641385712/article/details/92801300?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161513539016780266291183%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161513539016780266291183&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-11-92801300.first_rank_v2_pc_rank_v29&utm_term=spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98">参考链接4</a></p>
<h3 id="BeanWrapper及类型转换"><a href="#BeanWrapper及类型转换" class="headerlink" title="BeanWrapper及类型转换"></a>BeanWrapper及类型转换</h3><p>BeanWrapper其实就是一个Bean的包装器，它对Bean包装的目的是为了能操纵Bean中的属性，所以它同时需要具备获取、设置Bean中的属性能力，所以它也必须是一个属性访问器（PropertyAccessor），另外为了将各种不同类型的配置数据绑定到Bean的属性上，那么它还得具备属性转换的能力，因为它还得是一个类型转换器（TypeConverter）。</p>
<p>Spring中将类型转换的功能都委托给了一个TypeConverterDelegate，这个委托类在进行类型转换时会有两套方案：</p>
<ol>
<li><strong>PropertyEditor</strong>，这是Spring最初提供的方案，扩展了java中的PropertyEditor（java原先提供这个接口的目的更多是为了进行图形化编程）。</li>
<li>Spring后来提供的一个进行类型转换的<strong>ConversionService</strong>体系，用来取代PropertyEditor，因为PropertyEditor有很大的局限性，只能进行String-&gt;Object的转换。</li>
</ol>
<p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/20200331082247233.png" alt="20200331082247233"></p>
<p><a href="https://blog.csdn.net/qq_41907991/article/details/105214244">参考链接</a></p>
<h3 id="Spring容器加载Bean流程"><a href="#Spring容器加载Bean流程" class="headerlink" title="Spring容器加载Bean流程"></a>Spring容器加载Bean流程</h3><ol>
<li><p>ResourceLoader从配置文件中加载Spring配置信息，并使用Resource表示这个配置文件的资源。</p>
</li>
<li><p>XXXBeanDefinitionReader（XXX可以是Xml、Properties、Annotated根据不同配置类型选择），读取并解析Resource所指向的配置文件，生成BeanDefinition对象（用于存储配置元信息：创建对象所需要的必要信息）。如xml配置中一个&lt; bean &gt;&lt; /bean &gt;标签话就对应一个BeanDefinition对象。所有的BeanDefinition对象会被注册到BeanDefinitionRegistry（底层使用key-value存储，如下）。</p>
<p> <img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20210315141623519.png" alt="image-20210315141623519"></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Map of bean definition objects, keyed by bean name */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;(<span class="number">64</span>);</span><br><span class="line">	<span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractAutowireCapableBeanFactory</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ConfigurableListableBeanFactory</span>, <span class="title">BeanDefinitionRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">	<span class="comment">/** Map of bean definition objects, keyed by bean name. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接操作DefaultListableBeanFactory的方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器扫描BeanDefinitionRegistry中的BeanDefinition，利用反射识别出实现BeanFactoryPostProcessor工厂后置处理接口的Bean。并调用工厂后置处理器对BeanDefinition进行加工处理。</p>
<p> 注：<strong>BeanFactoryPostProcessor</strong>是容器启动阶段Spring提供的一个扩展点，主要负责对注册到BeanDefinationRegistry中BeanDefination进行一定程度上的修改与替换。主要完成以下两项工作：</p>
<ul>
<li><p>将配置文件中的占位符”${xx}”替换为最终配置值。</p>
</li>
<li><p>通过Java反射机制找出所有实现java.beans.PropertyEditor接口的Bean，并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）。</p>
</li>
</ul>
</li>
<li><p>Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，调用InstantiationStrategy类将其实例化。</p>
</li>
<li><p>在实例化Bean时，Spring容器会使用BeanWrapper对Bean进行封装。（BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作）</p>
</li>
<li><p>最后利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/xingxing513234072/article/details/78247480?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161572101216780274183660%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161572101216780274183660&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78247480.first_rank_v2_pc_rank_v29&utm_term=spring%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B">参考链接</a></p>
<h3 id="Bean实例化执行流程。"><a href="#Bean实例化执行流程。" class="headerlink" title="Bean实例化执行流程。"></a>Bean实例化执行流程。</h3><p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/20210222011843360.png" alt="20210222011843360"></p>
<p><a href="https://blog.csdn.net/a745233700/article/details/113840727">参考链接</a></p>
<p><a href="https://blog.csdn.net/qq_36697880/article/details/113836822">参考链接</a></p>
<h3 id="Resource与-Autowried区别"><a href="#Resource与-Autowried区别" class="headerlink" title="@Resource与@Autowried区别"></a>@Resource与@Autowried区别</h3><p><strong>相同</strong></p>
<ul>
<li>都可以标注在字段或属性的setter方法上，都可以实现对象注入。</li>
</ul>
<p><strong>不同</strong></p>
<ul>
<li>@Autowired 注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。</li>
<li>@Resource注解默认按名称装配。名称可以通过@Resource的name属性指定，如果没有指定，则默认取字段的名称作为bean名称寻找依赖对象。当注解标注在属性的setter方法上时，默认取属性名作为bean名称寻找依赖对象。 若设置了type属性则按照类型注入。</li>
<li>@Resources是JDK自带的，@Autowired是Spring提供的。</li>
</ul>
<h3 id="BeanFactory与FactoryBean区别"><a href="#BeanFactory与FactoryBean区别" class="headerlink" title="BeanFactory与FactoryBean区别"></a>BeanFactory与FactoryBean区别</h3><p>BeanFactory是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，<strong>所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的</strong>。但对FactoryBean而言，<strong>这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似</strong> 。</p>
<p>Spring中要获取FactoryBean实例的话需要在名字前面加&amp;(注：BeanFactory.FACTORY_BEAN_PREFIX = “&amp;”)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/4/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Cat.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置文件</span></span><br><span class="line"><span class="comment">//&lt;bean id = &quot;cat&quot; name=&quot;cat3,cat2&quot; class=&quot;bean.Cat&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">//&lt;bean id = &quot;factoryBean&quot; name=&quot;factoryBean1,factoryBean2&quot; class=&quot;bean.TestFactoryBean&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ClassPathXmlApplicationContext classPathXmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationConfig.xml&quot;</span>);</span><br><span class="line">System.out.println(classPathXmlApplicationContext.getBean(<span class="string">&quot;cat&quot;</span>));</span><br><span class="line">System.out.println(classPathXmlApplicationContext.getBean(<span class="string">&quot;factoryBean&quot;</span>));</span><br><span class="line"><span class="comment">//返回的是FactoryBean</span></span><br><span class="line">System.out.println(classPathXmlApplicationContext.getBean(<span class="string">&quot;&amp;factoryBean&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//bean.Cat@598067a5</span></span><br><span class="line"><span class="comment">//bean.Cat@3c0ecd4b</span></span><br><span class="line"><span class="comment">//bean.TestFactoryBean@14bf9759</span></span><br></pre></td></tr></table></figure>



<p><a href="https://www.cnblogs.com/aspirant/p/9082858.html">参考链接</a></p>
<h3 id="Spring常见面试题总结"><a href="#Spring常见面试题总结" class="headerlink" title="Spring常见面试题总结"></a><a href="https://blog.csdn.net/a745233700/article/details/80959716">Spring常见面试题总结</a></h3><p><a href="https://blog.csdn.net/qq_41907991/category_9907747.html">Spring源码解析</a></p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/660329-20190922093835529-1159443997.png" alt="img"></p>
<h3 id="参数解析绑定"><a href="#参数解析绑定" class="headerlink" title="参数解析绑定"></a>参数解析绑定</h3><ol>
<li>SpringMVC初始化时，RequestMappingHandlerAdapter类会把一些默认的参数解析器添加到argumentResolvers中。当SpringMVC接收到请求后首先根据url查找对应的HandlerMethod。</li>
<li>遍历HandlerMethod的MethodParameter数组。</li>
<li>根据MethodParameter的类型来查找确认使用哪个HandlerMethodArgumentResolver，遍历所有的argumentResolvers的supportsParameter(MethodParameter parameter)方法。如果返回true，则表示查找成功，当前MethodParameter，使用该HandlerMethodArgumentResolver。这里确认大多都是根据参数的注解以及参数的Type来确认。</li>
<li>解析参数，从request中解析出MethodParameter对应的参数，这里解析出来的结果都是String类型。</li>
<li>转换参数，把对应String转换成具体方法所需要的类型，这里就包括了基本类型、对象、List、Set、Map。</li>
</ol>
<p><a href="https://www.cnblogs.com/w-y-c-m/p/8443892.html">参考连接</a></p>
<p><a href="http://www.tianshouzhi.com/api/tutorials/spring">spring与springmvc父子容器问题</a></p>
<p><a href="https://www.cnblogs.com/myitnews/p/11565941.html">SpringMVC执行流程</a></p>
<p><a href="https://blog.csdn.net/a745233700/article/details/80963758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161216387316780264093649%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161216387316780264093649&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-3-80963758.pc_search_result_before_js&utm_term=%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187">常见面试题参考</a></p>
<p><a href="https://www.cnblogs.com/tengyunhao/p/7518481.html">工作原理</a></p>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">参考链接</a></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="Mybatis执行流程"></p>
<ol>
<li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</li>
<li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</li>
<li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li>
<li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li>
<li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li>
<li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</li>
<li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</li>
<li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li>
</ol>
<p><img src="/2021/02/26/Springboot/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/image-20210506002152431.png" alt="image-20210506002152431"></p>
<p><a href="https://blog.csdn.net/qq_38270106/article/details/93398694">参考链接</a></p>
<p><a href="https://blog.csdn.net/qq_38270106/article/details/93398694">参考链接</a></p>
<h3 id="其他知识链接"><a href="#其他知识链接" class="headerlink" title="其他知识链接"></a>其他知识链接</h3><p><a href="https://blog.csdn.net/a745233700/article/details/80977133">参考链接</a></p>
<p><a href="http://www.mybatis.cn/category/interview/">参考链接2</a></p>
<p><a href="https://www.cnblogs.com/qmillet/p/12523636.html">面试题</a></p>
<p><a href="https://thinkwon.blog.csdn.net/article/details/101292950">面试题2</a></p>
<p><a href="https://blog.csdn.net/luanlouis/category_9263284.html">深入理解</a></p>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//启动入口</span></span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用SpringApplication的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//设置资源加载器</span></span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    <span class="comment">//primarySources就是启动类class参数参数，null就抛出异常</span></span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">//推断WebApplicationType（枚举类），即当前启动环境，在classpath下搜索特定的类是否存在</span></span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 获取启动加载器</span></span><br><span class="line">    <span class="keyword">this</span>.bootstrappers = <span class="keyword">new</span> ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class));</span><br><span class="line">    <span class="comment">//设置初始化器</span></span><br><span class="line">    <span class="comment">//搜索META-INF\spring.factories文件配置的ApplicationContextInitializer的实现类</span></span><br><span class="line">    <span class="comment">//主要是通过SpringFactoriesLoader的loadSpringFactories()方法，</span></span><br><span class="line">    <span class="comment">//内部维护一个cache的Map缓存如下：</span></span><br><span class="line">    <span class="comment">//static final Map&lt;ClassLoader, Map&lt;String, List&lt;String&gt;&gt;&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//将返回集合值存入initializers中</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">//搜索META-INF\spring.factories文件配置的ApplicationListenerr的实现类</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">//推断MainApplication的Class</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>WebApplicationType.deduceFromClasspath()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> WebApplicationType <span class="title">deduceFromClasspath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过Class.forNam加载全路径类名对应的类</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; 			</span><br><span class="line">        !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="keyword">null</span>) &amp;&amp; </span><br><span class="line">        !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="keyword">null</span>)) &#123;</span><br><span class="line">	<span class="comment">//该应用程序应作为反应式Web应用程序运行，并应启动嵌入式反应式Web服务器。</span></span><br><span class="line">        <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">//该应用程序不应作为Web应用程序运行，也不应启动嵌入式Web服务器。</span></span><br><span class="line">            <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该应用程序应作为基于Servlet的Web应用程序运行，并应启动嵌入式Servlet Web服务器。</span></span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>run方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//时间监控，主要用于记录任务所用时间</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    <span class="comment">//设置开始时间，</span></span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">//创建启动上下文对象</span></span><br><span class="line">    DefaultBootstrapContext bootstrapContext = createBootstrapContext();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//置Headless属性，java.awt.headless是J2SE的一种模式用于在缺少显示屏、键盘或者鼠标时的系统配置，很多监控工具如jconsole 需要将该值设置为true，系统变量默认为true</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">//创建监视器EventPublishingRunListener并触发</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    </span><br><span class="line">    listeners.starting(bootstrapContext, <span class="keyword">this</span>.mainApplicationClass);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将输入参数转成DefaultApplicationArguments解析类</span></span><br><span class="line">        ApplicationArguments applicationArguments = </span><br><span class="line">            <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">//根据webApplicationType创建相应ConfigurableEnvironment环境配置类</span></span><br><span class="line">        <span class="comment">//并设置属性解析器的类型转换器，环境信息，发布环境准备好事件，profile信息，环境类类型转换等</span></span><br><span class="line">        ConfigurableEnvironment environment = </span><br><span class="line">            prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="comment">//设置需要忽略的bean</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">//打印Banner信息即springboot控制台启动输出（在SpringBootBanner里）</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">//创建容器，根据WebApplicationType创建相应容器</span></span><br><span class="line">        <span class="comment">//若为SERVLET则调用AnnotationConfigServletWebServerApplicationContext();</span></span><br><span class="line">        <span class="comment">//创建AnnotatedBeanDefinitionReader和ClassPathBeanDefinitionScanner</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">//给容器设置分步记录</span></span><br><span class="line">        context.setApplicationStartup(<span class="keyword">this</span>.applicationStartup);</span><br><span class="line">        <span class="comment">//准备容器，发布容器准备好事件，bootstrapContext关闭事件，开始日志记录，</span></span><br><span class="line">        <span class="comment">//往工厂注册打印器，加载资源并发布加载完成事件等等</span></span><br><span class="line">        prepareContext(bootstrapContext, context, environment, </span><br><span class="line">                       listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">//调用refresh()刷新容器，详情参考sping的启动流程</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">//刷新容器后提供的扩展接口</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 结束计时器</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="comment">//打印启动时间</span></span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发布容器启动完成事件ApplicationStartedEvent</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">//调用ApplicationRunner，CommandLineRunner的run方法</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发布容器就绪事件ApplicationReadyEvent</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_32828253/article/details/109496848?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161812240216780271575953%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161812240216780271575953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-10-109496848.first_rank_v2_pc_rank_v29&utm_term=springboor2.4%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">启动流程链接</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaNIO</title>
    <url>/2020/10/10/java/JavaNIO/</url>
    <content><![CDATA[<h2 id="Java共支持3种网络编程模型-IO模式：BIO、NIO、AIO"><a href="#Java共支持3种网络编程模型-IO模式：BIO、NIO、AIO" class="headerlink" title="Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO"></a>Java共支持3种网络编程模型/IO模式：BIO、NIO、AIO</h2><ol>
<li><p>​    Java BIO ： 同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端 有连接请求时服务器端就需要启动一个线程    进行处理，如果这个连接不做任何事情会造成 不必要的线程开销 。</p>
</li>
<li><p>​    Java NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发 送的连接请求都会注册到多路复用器上，多</p>
<p> ​    路复用器轮询到连接有I/O请求就进行处理 。</p>
</li>
<li><p>​     Java AIO(NIO.2) ： 异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简 化了程序编写，有效的请求才启动线程，</p>
<p> ​    它的特点是先由操作系统完成后才通知服务端程。</p>
</li>
</ol>
<h2 id="I-O模型-BIO、NIO、AIO适用场景分析"><a href="#I-O模型-BIO、NIO、AIO适用场景分析" class="headerlink" title="I/O模型 BIO、NIO、AIO适用场景分析"></a>I/O模型 BIO、NIO、AIO适用场景分析</h2><ol>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕 系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分 调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ol>
<h2 id="Java-BIO-基本介绍"><a href="#Java-BIO-基本介绍" class="headerlink" title="Java BIO 基本介绍"></a>Java BIO 基本介绍</h2><p>Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io.*下， BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连 接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造 成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。 </p>
<p> BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高， 并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</p>
<h3 id="BIO编程简单流程"><a href="#BIO编程简单流程" class="headerlink" title="BIO编程简单流程"></a>BIO编程简单流程</h3><ol>
<li>服务器端启动一个ServerSocket</li>
<li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li>
<li>客户端发出请求后, 先咨询服务器 是否有线程响应，如果没有则会等待，或者被拒绝</li>
<li>如果有响应，客户端线程会等待请求结束后，在继续执行</li>
</ol>
<h4 id="Java-BIO-问题分析"><a href="#Java-BIO-问题分析" class="headerlink" title="Java BIO 问题分析"></a>Java BIO 问题分析</h4><ol>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</li>
</ol>
<h2 id="Java-NIO-基本介绍"><a href="#Java-NIO-基本介绍" class="headerlink" title="Java NIO 基本介绍"></a>Java NIO 基本介绍</h2><ol>
<li>Java NIO 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出 的新特性，被统称为 NIO(即 New IO)，是同步非阻塞的。</li>
<li>NIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。</li>
<li>NIO 有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器) NIO是面向缓冲区 ，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li>
<li>Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得 到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线 程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞 写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这 个线程同时可以去做别的事情。</li>
<li>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来, 根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。</li>
<li>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li>
</ol>
<h3 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h3><ol>
<li>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多 。</li>
<li>BIO 是阻塞的，NIO 则是非阻塞的。</li>
<li>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 </li>
</ol>
<h3 id="NIO-三大核心关系"><a href="#NIO-三大核心关系" class="headerlink" title="NIO 三大核心关系"></a>NIO 三大核心关系</h3><p>​    <strong>Selector 、 Channel 和 Buffer</strong></p>
<ol>
<li><p>每个channel 都会对应一个Buffer。</p>
</li>
<li><p>Selector 对应一个线程， 一个线程对应多个channel(连接) 。</p>
</li>
<li><p>程序切换到哪个channel 是由事件决定的, Event 就是一个重要的概念 。</p>
</li>
<li><p>Selector 会根据不同的事件，在各个通道上切换 。</p>
</li>
<li><p>Buffer 就是一个内存块 ， 底层是有一个数组 。</p>
</li>
<li><p>数据的读取写入是通过Buffer（BIO 中要么是输入流，或者是输出流, 不能双向），NIO的Buffer 是可以读也可以写, 需要 flip 方法切换 。</p>
</li>
<li><p>channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统通道就是双向的。</p>
</li>
</ol>
<h3 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区(Buffer)"></a>缓冲区(Buffer)</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个 容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道 (Channel)是双向的，可以读操作，也可以写操作。</li>
<li>Channel在NIO中是一个接口 public interface Channel extends Closeable{} 。</li>
<li>常用的 Channel 类有：FileChannel、 DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li>
<li>FileChannel 用于文件的数据读写， DatagramChannel 用于 UDP 的数据读写， ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</li>
<li>NIO的通道类似于流，但有些区别如下：</li>
</ol>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写。</li>
<li>通道可以实现异步读写数据。</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲。</li>
</ul>
<h3 id="关于Buffer-和-Channel的注意事项和细节"><a href="#关于Buffer-和-Channel的注意事项和细节" class="headerlink" title="关于Buffer 和 Channel的注意事项和细节"></a>关于Buffer 和 Channel的注意事项和细节</h3><ol>
<li>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常。</li>
<li>可以将一个普通Buffer 转成只读Buffer 。</li>
<li>NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进行修改， 而如何同步到文件由NIO 来完成。</li>
<li>前面我们讲的读写操作，都是通过一个Buffer 完成的，NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</li>
</ol>
<h3 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a>Selector(选择器)</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol>
<li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)。</li>
<li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以 事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</li>
<li>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少 了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 4) 避免了多线程之间的上下文切换导致的开销。</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p>NIO中的 ServerSocketChannel功能类似ServerSocket，SocketChannel功能类 似Socket。</p>
</li>
<li><p>注册进Select的Channel必须是非阻塞的，所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socketchannel可以正常使用。</p>
</li>
<li><p>selector 相关方法说明：</p>
<p> ​    selector.select()//阻塞 </p>
<p> ​    selector.select(1000);//阻塞1000毫秒，在1000毫秒后返回 </p>
<p> ​    selector.wakeup();//唤醒selector </p>
<p> ​    selector.selectNow();//不阻塞，立马返还</p>
</li>
</ol>
<h3 id="NIO写入文件代码示例"><a href="#NIO写入文件代码示例" class="headerlink" title="NIO写入文件代码示例"></a>NIO写入文件代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个输出流-&gt;channel</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\file.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过 fileOutputStream 获取 对应的 FileChannel</span></span><br><span class="line">        <span class="comment">//这个 fileChannel 真实 类型是  FileChannelImpl</span></span><br><span class="line">        FileChannel fileChannel = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个缓冲区 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 str 放入 byteBuffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对byteBuffer 进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将byteBuffer 数据写入到 fileChannel</span></span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="NIO聊天室代码示例"><a href="#NIO聊天室代码示例" class="headerlink" title="NIO聊天室代码示例"></a>NIO聊天室代码示例</h3><p>Server端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义属性</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//ServerSocketChannel</span></span><br><span class="line">            listenChannel =  ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞模式</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该listenChannel 注册到selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;监听线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;<span class="comment">//有事件处理</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//遍历得到selectionKey 集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//取出selectionkey</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//监听到accept</span></span><br><span class="line">                        <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到seletor</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot; 上线 &quot;</span>);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable()) &#123; <span class="comment">//通道发送read事件，即通道是可读的状态</span></span><br><span class="line">                            <span class="comment">//处理读 (专门写方法..)</span></span><br><span class="line"></span><br><span class="line">                            readData(key);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前的key 删除，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//发生异常处理....</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取到关联的channle</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//把缓存区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出该消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;form 客户端: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向其它的客户端转发消息(去掉自己), 专门写一个方法来处理</span></span><br><span class="line">                sendInfoToOtherClients(msg, channel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot; 离线了..&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">                e2.printStackTrace();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其它客户(通道)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self )</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息中...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发数据给客户端线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//遍历 所有注册到selector 上的 SocketChannel,并排除 self</span></span><br><span class="line">        <span class="keyword">for</span>(SelectionKey key: selector.keys()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过 key  取出对应的 SocketChannel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span>  SocketChannel &amp;&amp; targetChannel != self) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel)targetChannel;</span><br><span class="line">                <span class="comment">//将msg 存储到buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer 的数据写入 通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Client端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>; <span class="comment">// 服务器的ip</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>; <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器, 完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, PORT));</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//将channel 注册到selector</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot; is ok...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        info = username + <span class="string">&quot; 说：&quot;</span> + info;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span>(readChannels &gt; <span class="number">0</span>) &#123;<span class="comment">//有可以用的通道</span></span><br><span class="line"></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                       SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                       <span class="comment">//得到一个Buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//读取</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的缓冲区的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove(); <span class="comment">//删除当前的selectionKey, 防止重复操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有可以用的通道...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动我们客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个线程, 读取从服务器发送数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line"><span class="comment">//                    try &#123;</span></span><br><span class="line"><span class="comment">//                        Thread.currentThread().sleep(3000);</span></span><br><span class="line"><span class="comment">//                    &#125;catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Java-AIO-基本介绍"><a href="#Java-AIO-基本介绍" class="headerlink" title="Java AIO 基本介绍"></a>Java AIO 基本介绍</h2><ol>
<li>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式： Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得 到通知，进行相应的处理 。</li>
<li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作 系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时 间较长的应用。</li>
</ol>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>数据从一个存储区域拷贝到另一个存储区域，没有CPU参与，这个过程称为零拷贝。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>减少CPU占用。</li>
<li>减少用户空间（用户态操作的缓存区）与内核空间（CPU可以操作的内存缓存区域及寄存器）拷贝过程。</li>
<li>减少用户态和内核态的上下文切换</li>
</ul>
<p><a href="https://blog.csdn.net/u013096088/article/details/79122671">参考链接</a></p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><a href="https://www.cnblogs.com/IT-CPC/p/10898871.html">学习链接</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="/2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p>
<h2 id="java创建运行线程"><a href="#java创建运行线程" class="headerlink" title="java创建运行线程"></a>java创建运行线程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="comment">// 构造方法的参数是给线程指定名字，推荐</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">     <span class="comment">// run 方法内实现了要执行的任务</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//todo^</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	<span class="comment">// 要执行的任务</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三：FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</span></span><br><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字</span></span><br><span class="line"><span class="keyword">new</span> Thread(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">Integer result = task3.get();</span><br></pre></td></tr></table></figure>

<h2 id="捕获线程异常的方法"><a href="#捕获线程异常的方法" class="headerlink" title="捕获线程异常的方法"></a>捕获线程异常的方法</h2><ul>
<li>创建线程时设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableImp());</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUnchecckedExceptionhandler());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ul>
<li>直接给Thread设置默认处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUnchecckedExceptionhandler());</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Callable的Feature.get()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建线程池</span></span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//2.创建Callable，有返回值的，你也可以创建一个线程实现Callable接口。</span></span><br><span class="line"><span class="comment">//  如果你不需要返回值，这里也可以创建一个Thread即可，在第3步时submit这个thread。</span></span><br><span class="line">Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.提交待执行的线程</span></span><br><span class="line">Future&lt;Integer&gt; future = executorService.submit(callable);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Integer result = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">//4.处理捕获的线程异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Executors或直接new ThreadPoolExecutor时参数ThreadFactory中指定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool(<span class="keyword">new</span> ThreadFactory()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUnchecckedExceptionhandler());</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">exec.execute(<span class="keyword">new</span> ExceptionThread());</span><br><span class="line"><span class="comment">//注：以submit方式提交该方式失效，异常被Future.get封装在ExecutionException中重新抛出。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重写ThreadPoolExecutor的afterExecute方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建线程池</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Thread) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//处理捕获的异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FutureTask) &#123;</span><br><span class="line">            FutureTask futureTask = (FutureTask) r;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                futureTask.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                <span class="comment">//处理捕获的异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">threadPoolExecutor.execute(t1);</span><br><span class="line">Callable&lt;Integer&gt; callable = () -&gt; <span class="number">2</span> / <span class="number">0</span>;</span><br><span class="line">threadPoolExecutor.submit(callable);</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/pange1991/article/details/82115437">参考链接</a></p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞），<strong>不会释放锁</strong> 。</p>
<p>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 异常。 </p>
<p>可使用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>让出执行权，<strong>不会释放锁</strong>。</p>
<p>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程。</p>
<p>具体的实现依赖于操作系统的任务调度器。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>等待线程执行完</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"> 	sleep(<span class="number">2</span>);</span><br><span class="line">	 r1 = <span class="number">10</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"> t1.start();</span><br><span class="line"> <span class="comment">// 线程执行结束会导致 join 提前结束</span></span><br><span class="line"> t1.join(<span class="number">1500</span>);<span class="comment">//无参为阻塞等待</span></span><br><span class="line"> <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"> log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br></pre></td></tr></table></figure>

<h2 id="wait-amp-notify"><a href="#wait-amp-notify" class="headerlink" title="wait&amp;notify"></a>wait&amp;notify</h2><p>obj.wait()指令就会释放锁，进入阻塞等待（WAITING）状态。等待其他线程调用锁对象obj.notify()/notifyAll()唤醒或者执行该线程对象的interrupt()方法中断他。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasWater = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasFruits = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!hasWater) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;没水等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//让出锁</span></span><br><span class="line">                        lock.wait(); <span class="comment">//lock.wait(time); 等待time时间，0或空参为无限等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;成功拿到水&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!hasFruits) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;没水果等待&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//让出锁</span></span><br><span class="line">                        lock.wait(); <span class="comment">//lock.wait(time); 等待time时间，0或空参为无限等待</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;成功拿到水果&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        giveWater();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        giveFriuits();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;水来了&quot;</span>);</span><br><span class="line">            hasWater = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();<span class="comment">//唤醒所有释放lock锁的等待线程</span></span><br><span class="line"><span class="comment">//            lock.notify();//随机唤醒一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveFriuits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;水果来了&quot;</span>);</span><br><span class="line">            hasFruits = <span class="keyword">true</span>;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[thread1] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">19</span> - -- 没水等待</span><br><span class="line">[thread2] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">35</span> - -- 没水果等待</span><br><span class="line">[main] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">57</span> - -- 水来了</span><br><span class="line">[thread2] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">35</span> - -- 没水果等待 <span class="comment">//等待水果的也被唤醒，再次等待</span></span><br><span class="line">[thread1] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">27</span> - -- 成功拿到水</span><br><span class="line">[main] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">65</span> - -- 水果来了</span><br><span class="line">[thread2] [INFO ] com.czm.concurrent.WaitAndNotify:<span class="number">43</span> - -- 成功拿到水果</span><br></pre></td></tr></table></figure>



<h2 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park&amp;unpark"></a>park&amp;unpark</h2><p>暂停当前线程 LockSupport.park(); <strong>不会释放此前获取到锁</strong>。</p>
<p>恢复某个线程的运行 LockSupport.unpark(暂停线程对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/12/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkAndUnpark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;parking...&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(<span class="string">&quot;继续运行parking2&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            log.info(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        log.info(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;unpark2&quot;</span>);</span><br><span class="line">        LockSupport.unpark(thread1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_43767015/article/details/107207643?utm_medium=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-2.control&dist_request_id=1332049.11900.16194454457559187&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~OPENSEARCH~default-2.control">学习链接</a></p>
<h2 id="锁粗化与锁消除"><a href="#锁粗化与锁消除" class="headerlink" title="锁粗化与锁消除"></a><a href="https://blog.csdn.net/qq_26222859/article/details/80546917">锁粗化与锁消除</a></h2><h2 id="MESI协议（缓存一致性协议）"><a href="#MESI协议（缓存一致性协议）" class="headerlink" title="MESI协议（缓存一致性协议）"></a><a href="https://blog.csdn.net/xiaowenmu1/article/details/89705740">MESI协议（缓存一致性协议）</a></h2><h2 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h2><p><a href="https://blog.csdn.net/tongdanping/article/details/79647337">学习链接</a></p>
<p><a href="https://www.cnblogs.com/deltadeblog/p/9559035.html">学习连接</a></p>
<h2 id="volatile（jdk1-5及其以后版本生效）"><a href="#volatile（jdk1-5及其以后版本生效）" class="headerlink" title="volatile（jdk1.5及其以后版本生效）"></a>volatile（jdk1.5及其以后版本生效）</h2><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存，保证该变量的可见性（一个线程对变量的修改对另一个线程可见）。</p>
<p>注：线程可能从自己工作内存中的高速缓存中读取一个共享变量，没法及时知道其他线程对该变量的修改。导致对该变量的不可见现象。</p>
<h3 id="volatie保证可见性与有序性"><a href="#volatie保证可见性与有序性" class="headerlink" title="volatie保证可见性与有序性"></a>volatie保证可见性与有序性</h3><h4 id="写屏障（sfence）"><a href="#写屏障（sfence）" class="headerlink" title="写屏障（sfence）"></a>写屏障（sfence）</h4><p>保证在该屏障之前的，对共享变量的改动，都同步到主存当中（可见性），</p>
<p>会确保指令重排序（JVM的JIT优化实现指令级并行）时，不会将写屏障之前的代码排在写屏障之后（有序性）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//todo修改其他共享变量</span></span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 写屏障，在这之前的所有共享变量被修改的将会被同步到内存中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="读屏障（lfence）"><a href="#读屏障（lfence）" class="headerlink" title="读屏障（lfence）"></a>读屏障（lfence）</h4><p>保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据（可见性），</p>
<p>会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前（有序性）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//todo</span></span><br><span class="line">    <span class="comment">// 读屏障，在这之后的所有共享变量的读取都会加载内存中的值</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">     	num++;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java内存模型 JMM(Java Memory Mode)</p>
<p><a href="https://zhuanlan.zhihu.com/p/29881777">链接1</a></p>
<p><a href="https://www.jianshu.com/p/8a58d8335270">链接2</a></p>
<h2 id="jdk提供的原子类型"><a href="#jdk提供的原子类型" class="headerlink" title="jdk提供的原子类型"></a>jdk提供的原子类型</h2><p><a href="https://blog.csdn.net/qq_37989738/article/details/106053608">链接</a></p>
<h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul>
<li>AtomicReference (无法解决ABA问题)</li>
<li>AtomicMarkableReference（带版本号的原子应用，解决ABA问题，可追踪修改）</li>
<li>AtomicStampedReference （带修改标记，只辨别是否存在ABA）</li>
</ul>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul>
<li>AtomicReferenceFieldUpdater // 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
</ul>
<p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常 （java.lang.IllegalArgumentException: Must be volatile type）。</p>
<h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><ul>
<li>DoubleAccumulator</li>
<li>DoubleAdder</li>
<li>LongAccumulator</li>
<li>LongAdder</li>
</ul>
<p>在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。</p>
<p><a href="https://segmentfault.com/a/1190000015865714">链接</a></p>
<h2 id="JDK提供的线程池"><a href="#JDK提供的线程池" class="headerlink" title="JDK提供的线程池"></a>JDK提供的线程池</h2><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量。目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值。</p>
<table>
<thead>
<tr>
<th>状态名</th>
<th>高三位</th>
<th>是否执行阻塞队列任务</th>
<th>是否接收新任务</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNABLE</td>
<td>111</td>
<td>是</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>是</td>
<td>否</td>
<td>不会接收新任务，<br> 但会处理阻塞队列剩余任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>否</td>
<td>否</td>
<td>会中断正在执行的任务，<br>并抛弃阻塞队列任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>否</td>
<td>否</td>
<td>任务全执行完毕，<br>活动线程为 0 即将进入终结状态</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>否</td>
<td>否</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p><img src="/2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20210125223403356.png" alt="image-20210125223403356"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, //核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime, // 急救线程生存时间</span></span></span><br><span class="line"><span class="function"><span class="params">                         TimeUnit unit, //时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory, //创建线程的工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler //拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">                         )</span></span></span><br></pre></td></tr></table></figure>



<h3 id="Executors类中用工厂方法提供以下常用线程池"><a href="#Executors类中用工厂方法提供以下常用线程池" class="headerlink" title="Executors类中用工厂方法提供以下常用线程池"></a>Executors类中用工厂方法提供以下常用线程池</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程数固定，核心线程数 == 最大线程数（没有救急线程被创建），阻塞队列是无界的，可以放任意数量的任务.</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，全部都是救急线程（空闲60s 后可以回收），队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）适合任务数比较密集，但每个任务执行时间较短的情况。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
<p><strong>比自己创建一个线程的优势：</strong></p>
<p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一</p>
<p>个线程，保证池的正常工作。</p>
<p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改。（Executors.newFixedThreadPool(1) 初始时为1 ，可以强转ThreadPoolExecutor 对象后调用 setCorePoolSize 等方法进行修改。）</p>
<p>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因</p>
<p>此不能调用 ThreadPoolExecutor 中特有的方法。</p>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行定时/延时任务。</p>
<h2 id="ThreadPoolExecutor原理分析"><a href="#ThreadPoolExecutor原理分析" class="headerlink" title="ThreadPoolExecutor原理分析"></a>ThreadPoolExecutor原理分析</h2><p><a href="https://blog.csdn.net/z_s_z2016/article/details/81674893?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161598942116780265477107%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=161598942116780265477107&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-6-81674893.first_rank_v2_pc_rank_v29&utm_term=ThreadPoolExecutor">参考链接</a></p>
<h3 id="任务提交执行流程"><a href="#任务提交执行流程" class="headerlink" title="任务提交执行流程"></a>任务提交执行流程</h3><img src="/2020/12/26/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/20200720005430313.png" style="zoom:150%;">

<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>底层是由内部类Node组成的<strong>单向</strong>链表，虚拟头节点。内部维护两个ReentrantLock，入队出队使用不同的锁，大大提高<strong>吞吐量</strong>。初始化时可指定其容量大小，没有默认Integer.MAX_VALUE（当入队速度大于出队速度时，有OOM风险）。</p>
<p><a href="https://blog.csdn.net/tonywu1992/article/details/83419448">参考链接</a></p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>底层是一个<strong>双向</strong>链表，内部只有一个ReentrantLock。容量规则和LinkedBlockingQueue一致，但比它多了更多出队入队方法。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。<br><a href="https://blog.csdn.net/yanyan19880509/article/details/52562039">参考链接</a></p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>用数组实现的有界阻塞队列，初始化时必须指定容量。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>有优先级的阻塞队列，有个PriorityQueue优先队列的字段。添加元素必须实现Delayed接口。</p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。我们称这种节点操作为“匹配”方式。<strong>和SynchronousQueue相比，LinkedTransferQueue多了一个可以存储的队列，与LinkedBlockingQueue相比，LinkedTransferQueue多了直接传递元素，少了用锁来同步。</strong></p>
<p><a href="https://blog.csdn.net/qq_38293564/article/details/80593821">参考链接</a></p>
<h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p><code>Fork/Join</code>框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p><a href="https://blog.csdn.net/qq_33404395/article/details/88879579?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161158892316780264071188%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=161158892316780264071188&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88879579.first_rank_v2_pc_rank_v29&utm_term=Fork/Join&spm=1018.2226.3001.4187">链接1</a></p>
<h2 id="死锁产生四个条件"><a href="#死锁产生四个条件" class="headerlink" title="死锁产生四个条件"></a>死锁产生四个条件</h2><ol>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h2 id="其他重要知识链接"><a href="#其他重要知识链接" class="headerlink" title="其他重要知识链接"></a>其他重要知识链接</h2><p><a href="https://blog.csdn.net/qq_35190492/article/details/104691668?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160881941716780277881196%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160881941716780277881196&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-2-104691668.first_rank_v2_pc_rank_v29&utm_term=juc">理解乐观锁与悲观锁</a></p>
<p><a href="https://blog.csdn.net/javazejian/category_6940462.html">java并发</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html">jdk线程使用</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka入门</title>
    <url>/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Kafka是由Apache软件基金会开发的一个开源流处理平台，<strong>由Scala和Java编写</strong>。Kafka是一种高吞吐量的<strong>分布式发布订阅消息系统</strong>，主要应用于大数据实时处理领域。</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/image-20210515143843109.png" alt="image-20210515143843109"></p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>kafka集群依赖zookeeper，创建zookeeper容器，<strong>kafka集群信息需要存在zookeeper</strong>中，如topic的信息（topic有几个，分区数、副本数、leader是谁，副本在哪台机器上等），Kafka 集群中会有一个 broker 会被选举为 controller，负责管理集群 broker 的上下线，所有topic的分区副本分配和 leader选举等工作。 controller的管理工作都是依赖于 Zookeeper 的。如下图，当前当选controller的broker为brokerid为0的kafka主机。（选举原则为先到先得）</p>
<img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/image-20210516192537060.png" alt="image-20210516192537060" style="zoom:150%;">

<p>注 0.9之前版本消费者消费信息的偏移量也是存在zookeeper中，0.9及其之后的版本存在kafka集群中。（消费者可以直接连zookeeper，但会提示警告，过期）</p>
<h2 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#集群0</span></span><br><span class="line">docker run -d --name kafka0 -p 9090:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=192.168.38.128:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.38.128:9090 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -v /etc/localtime:/etc/localtime -v /usr/<span class="built_in">local</span>/docker_container_config/kafka/kafka0/config/:/opt/kafka/config/ -v  /usr/<span class="built_in">local</span>/docker_container_config/kafka/kafka0/data/:/kafka/ wurstmeister/kafka</span><br><span class="line"></span><br><span class="line"><span class="comment">#-e KAFKA_BROKER_ID=0  在kafka集群中，每个kafka都有一个BROKER_ID来区分自己</span></span><br><span class="line"><span class="comment">#-e KAFKA_ZOOKEEPER_CONNECT=192.168.155.56:2181/kafka 配置zookeeper管理kafka的路径</span></span><br><span class="line"><span class="comment">#-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.38.128:9092 把kafka的地址端口注册给zookeeper，若需要远程访问要改成外网IP</span></span><br><span class="line"><span class="comment">#-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 配置kafka的监听端口</span></span><br><span class="line"><span class="comment">#-v /etc/localtime:/etc/localtime 容器时间同步虚拟机的时间</span></span><br><span class="line"><span class="comment">#-v /usr/local/docker_container_config/kafka/kafka0/config/:/opt/kafka/config/ 配置文件</span></span><br><span class="line"><span class="comment">#-v  /usr/local/docker_container_config/kafka/kafka0/data/:/kafka/</span></span><br><span class="line"><span class="comment">#-e KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot; 内存不够时使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#集群1</span></span><br><span class="line">docker run -d --name kafka1 -p 9091:9092 -e KAFKA_BROKER_ID=1 -e KAFKA_ZOOKEEPER_CONNECT=192.168.38.128:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.38.128:9091 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -v /etc/localtime:/etc/localtime -v /usr/<span class="built_in">local</span>/docker_container_config/kafka/kafka1/config/:/opt/kafka/config/ wurstmeister/kafka</span><br><span class="line"><span class="comment">#集群2</span></span><br><span class="line">docker run -d --name kafka2 -p 9092:9092 -e KAFKA_BROKER_ID=2 -e KAFKA_ZOOKEEPER_CONNECT=192.168.38.128:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.38.128:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -v /etc/localtime:/etc/localtime -v /usr/<span class="built_in">local</span>/docker_container_config/kafka/kafka2/config/:/opt/kafka/config/ wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<h2 id="kafka管理工具kafka-manager"><a href="#kafka管理工具kafka-manager" class="headerlink" title="kafka管理工具kafka-manager"></a>kafka管理工具kafka-manager</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name kafka-manager  -p 9000:9000  --env ZK_HOSTS=192.168.38.128:2181 sheepkiller/kafka-manager</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/image-20210516164410776.png" alt="image-20210516164410776"></p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>主题信息存在zookeeper中，所以直连zookeeper。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#因为集群依赖于zookeeper，我的的操作几乎直接对zookeeper操作</span></span><br><span class="line"><span class="comment">#查看主题列表</span></span><br><span class="line">kafka-topics.sh --zookeeper zkip:zkport[/要具体到zookeeper上的节点] --list </span><br><span class="line"></span><br><span class="line"><span class="comment">#创建主题</span></span><br><span class="line">kafka-topics.sh --zookeeper zkip:zkport --create --topic 主题名 --partitions 分区数量 --replication-factor 副本数量 </span><br><span class="line"><span class="comment">#./kafka-topics.sh --zookeeper 192.168.38.128:2181/kafka --topic topic1 --create --partitions 3 --replication-factor 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改分区数</span></span><br><span class="line">kafka-topics.sh --zookeeper zkip:zkport --alter --topic 主题名 --partitions 分区数</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除主题</span></span><br><span class="line">kafka-topics.sh --zookeeper zkip:zkport --delete --topic 主题名</span><br><span class="line"></span><br><span class="line"><span class="comment">#主题描述（详情）</span></span><br><span class="line">kafka-topics.sh --zookeeper zkip:zkport --describe --topic 主题名</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/image-20210515031033422.png" alt="image-20210515031033422"></p>
<h2 id="consumer-offsets"><a href="#consumer-offsets" class="headerlink" title="__consumer_offsets"></a>__consumer_offsets</h2><p>__consumer_offsets是默认的主题（<strong>位移主题</strong>，一般第一个consumer程序启动时会创建该主题），主要的作用是保存consumer的位移信息。存储的消息体格式可以想象成一个 KV 格式的消息，key 就是一个三元组：<code>group.id+topic+分区号</code>，而 value 就是 offset 的值。其存放机制是用<strong>消费组id的hash值对分区数取模</strong>得到。（消息体还保存了位移提交的一些其他元数据，如时间戳和用户自定义的数据等。为了 Kafka 执行各种各样后续的操作，比如删除过期位移消息等）kafka 默认为该 topic 创建了<strong>50个分区以降低多个consumer同时更新位移的读写压力</strong>。</p>
<h2 id="partition分区"><a href="#partition分区" class="headerlink" title="partition分区"></a>partition分区</h2><p>kafka会为每个partition创建一个log文件，该log文件中存储的就是生产者发布的数据。生产者的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己 消费到了哪个 offset，以便出错恢复时，从上次的位置继续消费。</p>
<p>由于生产者生产的消息会不断追加到 log 文件末尾，为防止 log 文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制，每个 partition可分为多个segment。每个segment 对应两个文件——“.index”文件和“.log”文件。这些文件位于一个分区文件夹下，该文件夹的命名 规则为：topic 名称+分区序号（如下图的topic-0和topic-2）。“.log”文件存储数据。“.index”文件存储索引信息指向对应数据文件中message的物理偏移地址。（定位时使用的是二分查找算法）</p>
<p><img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/image-20210515230453552.png" alt="log.dirs配置路径下"></p>
<h3 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h3><ol>
<li>RoundRobin</li>
<li>Range</li>
</ol>
<h2 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h2><p>kafka使用<strong>Compact 策略</strong>来删除位移主题中的过期消息，<strong>后台线程``Log Cleaner`定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据</strong>。</p>
<p><img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/compact.jpg" alt="compact"></p>
<h2 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h2><p>partition分区中会有一个leader，若干个follower，Leader维护了一个动态的 in-syncreplicaset (ISR)，意为和 leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader 就会给 follower 发送 ack。如果 follower 长时间（默认10秒）未向leader同步数据 ，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms 参数设定。<strong>leader 发生故障之后，就会从 ISR 中选举新的 leader。</strong></p>
<p>注：<strong>Unclean leader选举</strong>：由于ISR 是动态变化的，当ISR列表只有leader，且此时leader挂了，即此时ISR为空，此时Kafka就要重新选举出新的 leader。但ISR为空，Kafka 把不在 ISR 列表中的存活副本称为“非同步副本”，这些副本中的消息远远落后于 leader，如果选举这种副本作为 leader 的话就<strong>可能造成数据丢失</strong>。0.11版开始，Kafka提供了一个参数 unclean.leader.election.enable，用于控制是否允许非同步副本参与 leader 选举；如果开启，则当 ISR 为空时就会从这些副本中选举新的leader，这个过程称为 Unclean leader 选举。</p>
<p>0.9版本之前replica.lag.max.messages和replica.lag.time.max.ms两个参数用于判断副本是否需要被剔除。</p>
<p>0.9及其之后把replica.lag.max.messages剔除。<a href="http://kafka.apache.org/090/documentation.html#upgrade_9_breaking">详情见官网</a></p>
<p><a href="https://www.orchome.com/22">Kafka的leader选举与副本</a></p>
<h2 id="ack-应答-副本同步机制"><a href="#ack-应答-副本同步机制" class="headerlink" title="ack 应答/副本同步机制"></a>ack 应答/副本同步机制</h2><p>为保证 producer 发送的数据可靠送到指定的topic，topic的每个 partition收到producer发送的数据后，都需要向 producer 回复ack，如果 producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<p>Kafka 为用户提供了三种可靠性级别ack应答机制。</p>
<p>0：producer 不等待 broker 的 ack，最低的延迟，broker 一接收到还没有写入磁盘就已经返回，当broker故障时有可能丢失数据。</p>
<p>1：producer 等待 broker 的 ack，partition的leader 落盘成功后返回 ack，如果在 follower同步成功之前 leader故障，那么将会丢失数据；</p>
<p>-1：producer 等待 broker 的 ack，partition的leader和follower（ISP中的follower，注：leader一定在ISR中）全部落盘成功后才返回ack。但是如果在 follower 同步完成后，broker 发送 ack 之前，leader 发生故障，那么会 造成数据重复。</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p><code>LEO</code>（Log End Offset）：指的是每个副本最大的 offset； <code>HW</code>（High Watermark）：指的是消费者能见到的最大的 offset，ISR 队列中最小的 LEO。 </p>
<p>（1）follower 故障 follower 发生故障后会被临时踢出 ISR，待该 follower 恢复后，follower 会读取本地磁盘 记录的上次的 HW，并将 log 文件高于 HW 的部分截取掉，从 HW 开始向 leader 进行同步。 等该 follower 的 LEO 大于等于该 Partition 的 HW，即 follower 追上 leader 之后，就可以重 新加入 ISR 了。 </p>
<p>（2）leader 故障 leader 发生故障之后，会从 ISR 中选出一个新的 leader，之后，为保证多个副本之间的 其余的 follower 会先将各自的 log 文件高于 HW 的部分截掉，然后从新的 leader 同步数据。 注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</p>
<h2 id="Kafka高效的原因"><a href="#Kafka高效的原因" class="headerlink" title="Kafka高效的原因"></a>Kafka高效的原因</h2><ol>
<li>数据分区存储：方便集群扩展且以区为单位读写提高并发读写能力。</li>
<li>磁盘顺序写：数据写入log文件以追加的形式写入，省去磁针寻道时间。</li>
<li>零拷贝技术：省去数据从内核态到用户态之间的互相拷贝。</li>
</ol>
<h2 id="生产消费者"><a href="#生产消费者" class="headerlink" title="生产消费者"></a>生产消费者</h2><p>Kafka中消息是以 topic 进行分类的(一个主题类似一个队列)，生产者生产消息，消费者消费消息，都是面向 topic 的。即创建生产者和消费者时都需指明topic。</p>
<p>注：Kafka2.4之前读写消息数据都是在Leader分区，Kafka2.4开始可以配置<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-392%3A+Allow+consumers+to+fetch+from+closest+replica">replica.selector.class</a>允许从副本读取数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入kafka的bin目录</span></span><br><span class="line"><span class="comment">#运行生产者</span></span><br><span class="line">./kafka-console-producer.sh --broker-list localhost:9092 --topic topic1</span><br><span class="line"><span class="comment">#后面直接输入数据即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另开窗口同样进入bin目录</span></span><br><span class="line"><span class="comment">#开启消费者监听 --from-beginning 从头开始消费</span></span><br><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic --from-beginning </span><br><span class="line"></span><br><span class="line"><span class="comment">#kafka-console-consumer.sh --zookeeper localhost:2181 --topic topic</span></span><br><span class="line"><span class="comment">#会提示过期</span></span><br><span class="line"><span class="comment">#Using the ConsoleConsumer with old consumer is deprecated and will be removed in a future major release. Consider using the new consumer by passing [bootstrap-server] instead of [zookeeper].</span></span><br></pre></td></tr></table></figure>

<img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/image-20210515231826192.png" alt="image-20210515231826192" style="zoom:150%;">

<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>注：<strong>在同一消费者组中的消费者不能同时消费同一分区</strong>。</p>
<p>修改config目录下的consumer.properties配置文件的group.id，创建消费者时带上–consumer.config 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#consumer.properties中的配置group.id=czm-group</span></span><br><span class="line"><span class="comment">#生产者</span></span><br><span class="line">./kafka-console-producer.sh --broker-list localhost:9092 --topic topic1</span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者，创建两个窗口</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server localhost:9092 --consumer.config consumer.properties（配置文件路径） --topic topic1</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Snipaste_2021-05-16_21-00-25.png"></p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>Kafka在0.11 版本中引入了一项重大特性：幂等性。指 Producer不论向 Server 发送多少次重复数据，Server 端都只会<strong>持久化</strong>一条。将Producer的参数中 enable.idompotence 设置为 true 即可开启。开启幂等性的 Producer 在初始化的时候会被分配一个PID，发往同一 Partition的消息会附带 Sequence Number。而Broker端会对做缓存，当具有相同主键的消息提交时，Broker只会持久化一条。 <span style="color:red">（注：PID重启就会变化，同时不同的 Partition 也具有不同主键，所以幂等性无法保证跨分区跨会话）</span>。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>kafka在0.11版本后引入事务，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p>
<h3 id="Producer-事务"><a href="#Producer-事务" class="headerlink" title="Producer 事务"></a>Producer 事务</h3><p>引入一个全局唯一的 Transaction ID，并将 Producer 获得的PID 和Transaction ID 绑定。这样当Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID，实现跨会话。 为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就是通过和Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。 </p>
<h3 id="Consumer-事务"><a href="#Consumer-事务" class="headerlink" title="Consumer 事务"></a>Consumer 事务</h3><p>Consume 的事务保证就会相对较弱，尤其时无法保证 commit 的信息被精确消费。这是由于 Consumer可以通过offset访问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况(默认保存一周)。</p>
<p><a href="https://blog.csdn.net/u013256816/article/details/89135417">其他参考链接</a></p>
<h2 id="Java-API使用"><a href="#Java-API使用" class="headerlink" title="Java API使用"></a>Java API使用</h2><h3 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.kafka.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String topic = <span class="string">&quot;topic1&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//kafka集群，broker-list</span></span><br><span class="line">        properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;czm.com:9090,czm.com:9091,czm.com:9092&quot;</span>);</span><br><span class="line">        <span class="comment">//配置ack级别0，1,-1（all）</span></span><br><span class="line">        properties.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        <span class="comment">//重试次数</span></span><br><span class="line">        properties.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//批次大小</span></span><br><span class="line">        properties.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        properties.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">        properties.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//序列化类</span></span><br><span class="line">        properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine()) &#123;</span><br><span class="line">            String value = in.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, value);</span><br><span class="line">            producer.send(producerRecord, (RecordMetadata metadata, Exception exception) -&gt;&#123;</span><br><span class="line">                log.info(<span class="string">&quot;发送成功主题&#123;&#125;， 分区：&#123;&#125;，偏移量：&#123;&#125;&quot;</span>, metadata.topic(), metadata.partition(), metadata.offset());</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        producer.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.kafka.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.czm.kafka.producer.MyProducer;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.TopicPartition;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/5/19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;czm.com:9090,czm.com:9091,czm.com:9092&quot;</span>);</span><br><span class="line">        <span class="comment">//消费者组</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;czm-group&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭自动提交</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="comment">//自动提交时间间隔（ms）</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        <span class="comment">//反序列化类</span></span><br><span class="line">        properties.setProperty(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        properties.setProperty(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(properties))&#123;</span><br><span class="line">            <span class="comment">//订阅主题</span></span><br><span class="line">            consumer.subscribe(Arrays.asList(MyProducer.topic));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ConsumerRecords&lt;String, String&gt; message = consumer.poll(Duration.ofSeconds(<span class="number">5</span>));</span><br><span class="line">                message.forEach((e)-&gt;log.info(<span class="string">&quot;消息：topic: &#123;&#125;, partition:&#123;&#125;, offset:&#123;&#125;, value:&#123;&#125;&quot;</span>,e.topic(),  e.partition(), e.offset(), e.value()));</span><br><span class="line">                <span class="comment">//同步提交</span></span><br><span class="line">                <span class="comment">//consumer.commitAsync();</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//异步提交</span></span><br><span class="line">                consumer.commitAsync((Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, Exception exception) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;消息提交失败：&#123;&#125;&quot;</span>, offsets);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">&quot;接收异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><a href="https://blog.csdn.net/yanshu2012/article/details/54894629">leader选举</a></p>
<p><a href="https://blog.csdn.net/u013256816/article/details/89135417">时间轮（TimingWheel）</a></p>
<h2 id="Kafka-Stream（可用于实时计算）"><a href="#Kafka-Stream（可用于实时计算）" class="headerlink" title="Kafka Stream（可用于实时计算）"></a>Kafka Stream（可用于实时计算）</h2><p><a href="https://blog.csdn.net/qq_36807862/article/details/81283491">基础学习链接</a></p>
<p><a href="https://blog.csdn.net/ransom0512/article/details/52105379">原理学习链接</a></p>
<p><a href="https://blog.csdn.net/weixin_38910645/article/details/107252855">简单示例</a></p>
<h3 id="流和状态"><a href="#流和状态" class="headerlink" title="流和状态"></a>流和状态</h3><p><a href="https://blog.csdn.net/gangchengzhong/article/details/84997568">学习链接</a></p>
<h3 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a>时间窗口</h3><p><a href="https://blog.csdn.net/u012364631/article/details/94019707">学习链接</a></p>
<h3 id="Kafka-connect"><a href="#Kafka-connect" class="headerlink" title="Kafka connect"></a>Kafka connect</h3><p><a href="https://www.cnblogs.com/linchenguang/p/14081296.html">学习链接</a></p>
<h2 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h2><p><a href="https://blog.csdn.net/qq_28900249/article/details/90346599">参考链接</a></p>
<p><a href="https://www.jianshu.com/p/511962462e58">参考链接</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ入门</title>
    <url>/2020/09/25/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitMq/</url>
    <content><![CDATA[<h2 id="消息中间件（MQ）"><a href="#消息中间件（MQ）" class="headerlink" title="消息中间件（MQ）"></a>消息中间件（MQ）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​    消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。——百度百科</p>
<p>​    MQ全称为Message Queue，消息队列是程序和程序之间的通信方法。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>实现项目通讯与解耦   </li>
</ul>
<p>MQ相当于一个中介，消息生产方将消息发给MQ，消息消费方接收消息并进行相应逻辑处理，它将两应用程序进行解耦合。</p>
<ul>
<li>处理异步任务</li>
</ul>
<p>​        在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p>
<ul>
<li>   削峰填谷</li>
</ul>
<p>  如订单抢票系统，开始抢票瞬间高请求，高并发，若此时都操作数据库，需要大量IO操作，消耗系统性能，系统很可能崩溃，我们可以先将订单存消息队列里，然后系统就可以避开高峰期再按照自己的消费能力消费消息队列里的消息。</p>
<h2 id="主流实现方式"><a href="#主流实现方式" class="headerlink" title="主流实现方式"></a>主流实现方式</h2><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>​    AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF/1619218">消息</a>队列协议，是<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788">应用层</a>协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BB%B6/452240">中间件</a>不同产品，不同的开发语言等条件的限制。<a href="https://baike.baidu.com/item/Erlang">Erlang</a>中的实现有<a href="https://baike.baidu.com/item/RabbitMQ">RabbitMQ</a>等。                                                                                                                               ——百度百科</p>
<p>AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>​    JMS即Java消息服务（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java%E5%B9%B3%E5%8F%B0">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/5899771">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中发送消息，进行<a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/2273903">异步通信</a>。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。                                                                                                                                                                                                    ——百度百科</p>
<h3 id="AMQP-与-JMS-区别"><a href="#AMQP-与-JMS-区别" class="headerlink" title="AMQP 与 JMS 区别"></a>AMQP 与 JMS 区别</h3><ul>
<li>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</li>
<li>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS规定了两种消息模式；而AMQP的消息模式更加丰富</li>
</ul>
<h3 id="常见的消息队列"><a href="#常见的消息队列" class="headerlink" title="常见的消息队列"></a>常见的消息队列</h3><ul>
<li><p>ActiveMQ：基于JMS</p>
</li>
<li><p>ZeroMQ：基于C语言开发</p>
</li>
<li><p>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</p>
</li>
<li><p>RocketMQ：基于JMS，阿里巴巴产品</p>
</li>
<li><p>Kafka：类似MQ的产品；分布式消息系统，高吞吐量</p>
<p>  <a href="https://blog.csdn.net/qq_35246620/article/details/107175767">优缺点</a></p>
</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><a href="http://www.rabbitmq.com/">官网</a></p>
<h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>​        <strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E7%94%B5%E4%BF%A1%E5%B9%B3%E5%8F%B0">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/%E5%BA%93">库</a>。        ——百度百科</p>
<h3 id="6种模式"><a href="#6种模式" class="headerlink" title="6种模式"></a>6种模式</h3><ul>
<li><p>简单模式：一个生产者发送消息到队列,一个消费者接收，不需要设置交换机（使用默认的交换机）</p>
</li>
<li><p>work工作队列模式，一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者竞争同一个队列的消息</p>
</li>
<li><p>Publish/Subscribe发布与订阅模式：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者</p>
</li>
<li><p>Routing路由模式（direct模式）：生产者发送消息到交换机并且要指定路由key，消费者将队列绑定到交换机时需要指定路由key</p>
</li>
<li><p>Topics通配符模式:  生产者发送消息到交换机，交换机类型设置topic，交换机根据绑定队列的routing key的值进行通配符匹配，</p>
<p>  “#”：匹配零个或者多个词topic.# 可以匹配topic，topic.text，topic.test.queue</p>
<p>  “<em>“：匹配l零个或一个词，topic.</em> 可以匹配topic，topic.text或topic.queue</p>
</li>
<li><p>RPC远程调用模式：功能如名，调用远程项目的功能并等待结果。</p>
</li>
</ul>
<h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><h4 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a><strong>maven坐标</strong></h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="java代码示例"><a href="#java代码示例" class="headerlink" title="java代码示例"></a>java代码示例</h4><p>注：这里以direct模式示例，其他模式类似</p>
<h5 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">//设置Rabbitmq主机地址,默认localhost</span></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//设置端口,默认5672</span></span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line"><span class="comment">//设置虚拟主机，默认 /</span></span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"><span class="comment">//连接用户名；默认为guest</span></span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line"><span class="comment">//连接密码；默认为guest</span></span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//通过连接工厂创建连接</span></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"><span class="comment">// 通过connection创建一个Channel通道</span></span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的信息</span></span><br><span class="line">String message = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">				.deliveryMode(<span class="number">2</span>)<span class="comment">//2消息持久化；1重启消息丢失</span></span><br><span class="line">				.contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">				.expiration(<span class="string">&quot;10000&quot;</span>)<span class="comment">//十秒失效</span></span><br><span class="line">				.headers(headers)</span><br><span class="line">				.build();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：交换机名称，如果没有指定则使用默认Default Exchage</span></span><br><span class="line"><span class="comment">* 参数2：路由key,简单模式可以传递队列名称</span></span><br><span class="line"><span class="comment">* 参数3：消息其它属性</span></span><br><span class="line"><span class="comment">* 参数4：消息内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;test_direct_exchange&quot;</span>, <span class="string">&quot;test.direct&quot;</span>, properties, message.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>

<h5 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory() ;  </span><br><span class="line"></span><br><span class="line">connectionFactory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">connectionFactory.setPort(<span class="number">5672</span>);</span><br><span class="line">connectionFactory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">connectionFactory.setUsername(<span class="string">&quot;czm&quot;</span>);</span><br><span class="line">connectionFactory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="comment">//自动恢复连接</span></span><br><span class="line">connectionFactory.setAutomaticRecoveryEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//自动恢复在尝试重新连接之前要等待多长时间，默认5000ms</span></span><br><span class="line">connectionFactory.setNetworkRecoveryInterval(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line"></span><br><span class="line">Channel channel = connection.createChannel();  </span><br><span class="line"><span class="comment">//4 声明</span></span><br><span class="line">String exchangeName = <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line">String exchangeType = <span class="string">&quot;direct&quot;</span>;</span><br><span class="line">String queueName = <span class="string">&quot;test_direct_queue&quot;</span>;</span><br><span class="line">String routingKey = <span class="string">&quot;test.direct&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示声明了一个交换机</span></span><br><span class="line">channel.exchangeDeclare(exchangeName, exchangeType, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 声明（创建）队列</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数1：队列名称</span></span><br><span class="line"><span class="comment">* 参数2：是否持久化队列</span></span><br><span class="line"><span class="comment">* 参数3：是否独占连接</span></span><br><span class="line"><span class="comment">* 参数4：是否在不使用的时候自动删除队列</span></span><br><span class="line"><span class="comment">* 参数5：队列其它参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//建立一个绑定关系:</span></span><br><span class="line">channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line"><span class="comment">//durable 是否持久化消息</span></span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"><span class="comment">//参数：队列名称、是否自动ACK、Consumer</span></span><br><span class="line">channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"><span class="comment">//循环获取消息  </span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">    <span class="comment">//获取消息，如果没有消息，这一步将会一直阻塞  </span></span><br><span class="line">    Delivery delivery = consumer.nextDelivery();  </span><br><span class="line">    String msg = <span class="keyword">new</span> String(delivery.getBody());    </span><br><span class="line">    System.out.println(<span class="string">&quot;收到消息：&quot;</span> + msg);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="用xml配置方式与spring整合"><a href="#用xml配置方式与spring整合" class="headerlink" title="用xml配置方式与spring整合"></a>用xml配置方式与spring整合</h3><h4 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h4><h5 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h5><p>注：以下配置rabbitMQ可靠性投递用到，消息的延迟投递，做二次确认，回调检查</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:rabbit</span>=<span class="string">&quot;http://www.springframework.org/schema/rabbit&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/rabbit</span></span></span><br><span class="line"><span class="tag"><span class="string">                http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--引入spring配置文件 ，便于下方配置变量引用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:application.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 创建连接类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;rabbitmqConnectionFactory&quot;  class=&quot;org.springframework.amqp.rabbit.connection.CachingConnectionFactory&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg value=&quot;localhost&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的账户,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;username&quot; value=&quot;$&#123;rmq.manager.user&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- username,访问RabbitMQ服务器的密码,默认是guest --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;password&quot; value=&quot;$&#123;rmq.manager.password&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- host,RabbitMQ服务器地址，默认值&quot;localhost&quot; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;host&quot; value=&quot;$&#123;rmq.ip&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- port，RabbitMQ服务端口，默认值为5672 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;port&quot; value=&quot;$&#123;rmq.port&#125;&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- channel-cache-size，channel的缓存数量，默认值为25 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;channel-cache-size&quot; value=&quot;50&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--cache-mode，缓存连接模式，默认值为CHANNEL(单个connection连接，连接之后关闭，自动销毁) --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;cache-mode&quot; value=&quot;CHANNEL&quot; /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--或者这样配置，connection-factory元素实际就是注册一个org.springframework.amqp.rabbit.connection.CachingConnectionFactory实例--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:connection-factory</span> <span class="attr">id</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">host</span>=<span class="string">&quot;$&#123;rmq.ip&#125;&quot;</span> <span class="attr">port</span>=<span class="string">&quot;$&#123;rmq.port&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    							<span class="attr">virtual-host</span>=<span class="string">&quot;$&#123;rmq.manager.virtual&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">username</span>=<span class="string">&quot;$&#123;rmq.manager.user&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">password</span>=<span class="string">&quot;$&#123;rmq.manager.password&#125;&quot;</span> </span></span><br><span class="line"><span class="tag">                               <span class="attr">publisher-confirms</span>=<span class="string">&quot;true&quot;</span> <span class="attr">publisher-returns</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--注：publisher-confirms=&quot;true&quot; publisher-returns=&quot;true&quot;用于开启消息投递的回调监听，若想使用必须配置--&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:admin</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产者部分 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 发送消息的producer类，也就是生产者 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;RabbitmqProduct&quot;</span> <span class="attr">class</span>=<span class="string">&quot;生产者类路径&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--routingKey的 value中的值就是producer中的的routingKey，它与上面的rabbit:bindings标签中的key必须相同 -&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;exchange&quot; value=&quot;$&#123;rmq.manager.exchange&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;routingKey&quot; value=&quot;$&#123;rmq.manager.routingKey&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;delayKey&quot; value=&quot;$&#123;rmq.manager.key_delay&#125;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        &lt;property name=&quot;rabbitTemplate&quot; ref=&quot;rabbitTemplate&quot;/&gt;</span></span><br><span class="line"><span class="comment">    &lt;/bean&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;!-- spring amqp默认的是jackson 的一个插件,目的将生产者生产的数据转换为json存入消息队列，由于fastjson的速度快于jackson,这里替换为fastjson的一个实现 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;jsonMessageConverter&quot; class=&quot;com.jy.utils.FastJsonMessageConverter&quot;&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 或者配置jackson --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jsonMessageConverter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.amqp.support.converter.Jackson2JsonMessageConverter&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--消息成功投递后回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--消息找不到对应交换机或routingkey，投递失败回调类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">class</span>=<span class="string">&quot;回调类路径&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--exchange=&quot;Anyview_exchange&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:template</span>  <span class="attr">id</span>=<span class="string">&quot;rabbitTemplate&quot;</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">message-converter</span>=<span class="string">&quot;jsonMessageConverter&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">confirm-callback</span>=<span class="string">&quot;confirmCallBackListener&quot;</span> <span class="attr">return-callback</span>=<span class="string">&quot;returnCallBackListener&quot;</span> <span class="attr">mandatory</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费者部分 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义消息队列,durable:是否持久化，</span></span><br><span class="line"><span class="comment">    如果想在RabbitMQ退出或崩溃的时候，不会失去所有的queue和消息，需要同时标志队列(queue)和交换机(exchange)是持久化的，	即rabbit:queue标签和rabbit:direct-exchange中的durable=true,而消息(message)默认是持久化的可以看类			org.springframework.amqp.core.MessageProperties中的属性</span></span><br><span class="line"><span class="comment">	public static final MessageDeliveryMode DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT;</span></span><br><span class="line"><span class="comment">    exclusive: 仅创建者可以使用的私有队列，断开后自动删除；</span></span><br><span class="line"><span class="comment">    auto_delete: 当所有消费客户端连接断开后，是否自动删除队列 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--延时队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">id</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_delay&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  队列过期时间 10秒--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-message-ttl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">value-type</span>=<span class="string">&quot;java.lang.Long&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 过期后消息将通过以下交换机和routingkey发送到死信队列--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-exchange&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;x-dead-letter-routing-key&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:queue-arguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:queue</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--绑定队列,</span></span><br><span class="line"><span class="comment">rabbitmq的exchangeType常用的三种模式：direct，fanout，topic三种,</span></span><br><span class="line"><span class="comment">我们用direct模式，即rabbit:direct-exchange标签，Direct交换器很简单，</span></span><br><span class="line"><span class="comment">如果是Direct类型，就会将消息中的RoutingKey与该Exchange关联的所有Binding中的BindingKey进行比较，</span></span><br><span class="line"><span class="comment">如果相等，则发送到该Binding对应的Queue中。有一个需要注意的地方：如果找不到指定的exchange，就会报错。</span></span><br><span class="line"><span class="comment">但routing key找不到的话，不会报错，这条消息会直接丢失，所以此处要小心,</span></span><br><span class="line"><span class="comment">auto-delete:自动删除，如果为Yes，则该交换机所有队列queue删除后，自动删除交换机，默认为false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;rabbitQueue&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.routingKey&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDelay&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_delay&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--死信队列--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:queue</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span> <span class="attr">exclusive</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:direct-exchange</span> <span class="attr">id</span>=<span class="string">&quot;exchange_dead&quot;</span> <span class="attr">name</span>=<span class="string">&quot;$&#123;rmq.manager.exchange_dead&#125;&quot;</span> <span class="attr">durable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">auto-delete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">rabbit:binding</span> <span class="attr">queue</span>=<span class="string">&quot;queueDead&quot;</span> <span class="attr">key</span>=<span class="string">&quot;$&#123;rmq.manager.key_dead&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rabbit:binding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rabbit:bindings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:direct-exchange</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用于消息的监听的代理类MessageListenerAdapter --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id=&quot;testQueueListenerAdapter&quot; class=&quot;org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter&quot; &gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 类名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;constructor-arg ref=&quot;Handler&quot; /&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 方法名 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;defaultListenerMethod&quot; value=&quot;handlerTest&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;messageConverter&quot; ref=&quot;jsonMessageConverter&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;rabbit:direct-exchange id=&quot;$&#123;rmq.manager.exchange&#125;&quot; name=&quot;$&#123;rmq.manager.exchange&#125;&quot;  durable=&quot;false&quot; auto-delete=&quot;false&quot; &gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;/rabbit:direct-exchange&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义接口类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;Handler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;消息类路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置监听acknowledeg=&quot;manual&quot;设置手动应答，它能够保证即使在一个worker处理消息的时候用CTRL+C来杀掉这个		worker，或者一个consumer挂了(channel关闭了、connection关闭了或者TCP连接断了)，也不会丢失消息。</span></span><br><span class="line"><span class="comment">    因为RabbitMQ知道没发送ack确认消息导致这个消息没有被完全处理，将会对这条消息做re-queue处理。</span></span><br><span class="line"><span class="comment">    如果此时有另一个consumer连接，消息会被重新发送至另一个consumer会一直重发,直到消息处理成功,</span></span><br><span class="line"><span class="comment">    监听容器acknowledge=&quot;auto&quot; concurrency=&quot;30&quot;设置发送次数,最多发送30次 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--concurrency=&quot;20&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rabbit:listener-container</span> <span class="attr">connection-factory</span>=<span class="string">&quot;rabbitmqConnectionFactory&quot;</span> <span class="attr">acknowledge</span>=<span class="string">&quot;manual&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rabbit:listener</span> <span class="attr">queues</span>=<span class="string">&quot;$&#123;rmq.manager.queue_dead&#125;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Handler&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rabbit:listener-container</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="keyword">private</span> String routingKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String delayKey;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*此服务用于将消息持久化</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"> 	<span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rabbitmq发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socketMsg 消息实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isFirst 是否第一次发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(SocketMsg socketMsg, <span class="keyword">boolean</span> isFirst)</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次发送前先持久化</span></span><br><span class="line">        <span class="keyword">if</span>(isFirst)&#123;</span><br><span class="line">            socketMsgService.insert(socketMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CorrelationData消息唯一ID</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object jsonSocketMsg = JSON.toJSON(socketMsg);</span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,routingKey, jsonSocketMsg, </span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()));</span><br><span class="line">            <span class="comment">//发送到延时队列</span></span><br><span class="line">            rabbitTemplate.convertAndSend(exchange,delayKey, jsonSocketMsg,</span><br><span class="line">                                          <span class="keyword">new</span> CorrelationData(socketMsg.getId().toString()+<span class="string">&quot;delay&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExchange</span><span class="params">(String exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoutingKey</span><span class="params">(String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.routingKey = routingKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRabbitTemplate</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayKey</span><span class="params">(String delayKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayKey = delayKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="延时队列消费者代码"><a href="#延时队列消费者代码" class="headerlink" title="延时队列消费者代码"></a>延时队列消费者代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">ChannelAwareMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    RabbitmqProduct rabbitmqProduct;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        Object parse = JSONObject.parse(message.getBody());</span><br><span class="line">        log.info(parse.toString());</span><br><span class="line">        SocketMsg socketMsg = JSONObject.parseObject(message.getBody(), SocketMsg.class);</span><br><span class="line">        log.info(socketMsg.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消息未成功投递</span></span><br><span class="line">        <span class="keyword">if</span>(socketMsgService.findById(socketMsg.getId()).getStatus() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//未超过重试次数</span></span><br><span class="line">            <span class="keyword">if</span> (socketMsgService.getTryCountById(socketMsg.getId()) &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//添加重试次数</span></span><br><span class="line">                socketMsgService.addTryCountById(socketMsg.getId());</span><br><span class="line">                rabbitmqProduct.sendMessage(socketMsg, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="投递成功回调类"><a href="#投递成功回调类" class="headerlink" title="投递成功回调类"></a>投递成功回调类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service(&quot;confirmCallBackListener&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmCallBackListener</span> <span class="keyword">implements</span> <span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    SocketMsgService socketMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;################发送到exchange成功:&quot;</span>+correlationData);</span><br><span class="line">            <span class="comment">//非延时队列的消息确认</span></span><br><span class="line">            <span class="keyword">if</span> (!correlationData.getId().endsWith(<span class="string">&quot;delay&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//将数据库消息标志置为成功发送</span></span><br><span class="line">                socketMsgService.succeedSendById(Long.parseLong(correlationData.getId()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;#########发送失败:&quot;</span>+correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="投递失败回调类"><a href="#投递失败回调类" class="headerlink" title="投递失败回调类"></a>投递失败回调类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020/7/31 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnCallBackListener</span> <span class="keyword">implements</span> <span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, </span></span></span><br><span class="line"><span class="function"><span class="params">                                String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;无对应key队列，发送失败了&quot;</span>+message);</span><br><span class="line">        log.info(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h4><h5 id="配置与上面延时队列的消息接收方类似，此处不再累赘"><a href="#配置与上面延时队列的消息接收方类似，此处不再累赘" class="headerlink" title="配置与上面延时队列的消息接收方类似，此处不再累赘"></a>配置与上面延时队列的消息接收方类似，此处不再累赘</h5><p><a href="https://blog.csdn.net/Design407/article/details/103636161?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328602.14831.16149505641775423&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">常问问题1</a></p>
<p><a href="https://blog.csdn.net/thinkwon/article/details/104588612/">常问问题2</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity初探</title>
    <url>/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="工作流（Work-flow）"><a href="#工作流（Work-flow）" class="headerlink" title="工作流（Work flow）"></a>工作流（Work flow）</h2><p>是指是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。</p>
<p>示例（请假申请）：</p>
<p>创造假期申请——》部门主管审批——》经理审批——》财务审批——》流程结束.</p>
<p>还有订单、报价处理、合同审核、供应链管理等众多适用场景。</p>
<h2 id="BPMN2-0规范"><a href="#BPMN2-0规范" class="headerlink" title="BPMN2.0规范"></a>BPMN2.0规范</h2><p>BPMN（Business Process Model Notation——业务流程建模符号）是由BPMI(The Business Process Management Initiative)开发的一套标准的业务流程建模符号。使用BPMN提供的符号可创建所需的业务流程。——<a href="https://baike.baidu.com/item/BPMN/9818373?fr=aladdin">百度百科</a></p>
<p><a href="http://www.mossle.com/docs/jbpm4devguide/html/bpmn2.html">中文版链接</a></p>
<h1 id="Activiti-7-0"><a href="#Activiti-7-0" class="headerlink" title="Activiti 7.0"></a>Activiti 7.0</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Activiti是领先的轻量级、以 Java 为中心的开源 BPMN 引擎，支持现实世界的流程自动化需求。即是一个工作流引擎， Activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由Activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Alfresco软件在2010年5月17日宣布Activiti业务流程管理（BPM）开源项目的正式启动，其首席架构师由业务流程管理BPM的专家 Tom Baeyens担任，Tom Baeyens就是原来jbpm的架构师，而jbpm是一个非常有名的工作流引擎。</p>
<h2 id="流程使用步骤"><a href="#流程使用步骤" class="headerlink" title="流程使用步骤"></a>流程使用步骤</h2><ol>
<li>搭建Activiti部署环境：引入相应jar包，简单配置后使用Activiti的API在数据库创建表结构。</li>
<li>流程定义：使用流程建模工具定义业务流程（存储文件后缀.bpmn）。</li>
<li>流程定义部署:  使用Activiti提供的API把流程定义内容存储到数据库相关表中，后续操作Activiti可直接查询业务流程。</li>
<li>启动一个流程实例：即一次业务流程的运行。</li>
<li>完成用户任务：完成一个任务节点。</li>
<li>流程结束：当任务办理完成后没有下一个任务结点时，该流程结束。</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="下载actiBPM插件"><a href="#下载actiBPM插件" class="headerlink" title="下载actiBPM插件"></a>下载actiBPM插件</h3><p>用于流程定义，新版IDEA找不到可直接去<a href="https://plugins.jetbrains.com/plugin/download?rel=true&updateId=17789">官网插件下载</a>。装成功后新建会有BPMN File选项。</p>
<p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210613014101946.png" alt="image-20210613014101946"></p>
<h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p>Activiti运行需要有数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中。支持的数据库有：h2, MySQL, oracle, postgres, mssql, db2。这里使用MySQL。</p>
<h3 id="Activiti数据表介绍"><a href="#Activiti数据表介绍" class="headerlink" title="Activiti数据表介绍"></a>Activiti数据表介绍</h3><table>
<thead>
<tr>
<th><strong>表分类</strong></th>
<th><strong>表名</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一般数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_GE_BYTEARRAY]</td>
<td>通用的流程定义和流程资源</td>
</tr>
<tr>
<td></td>
<td>[ACT_GE_PROPERTY]</td>
<td>系统相关属性</td>
</tr>
<tr>
<td>流程历史记录</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_ACTINST]</td>
<td>流程实例执行的历史信息<br>（任务+事件（如：startEvent、endEvent））</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_ATTACHMENT]</td>
<td>历史的流程附件</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_COMMENT]</td>
<td>历史的说明性信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_DETAIL]</td>
<td>历史的流程运行中的细节信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_IDENTITYLINK]</td>
<td>历史的流程运行过程中用户关系</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_PROCINST]</td>
<td>历史的流程实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_TASKINST]</td>
<td>历史的流程任务实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_VARINST]</td>
<td>历史的流程运行中的变量信息</td>
</tr>
<tr>
<td>流程定义表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_DEPLOYMENT]</td>
<td>部署单元信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_MODEL]</td>
<td>模型信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_PROCDEF]</td>
<td>已部署的流程定义</td>
</tr>
<tr>
<td>运行实例表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_EVENT_SUBSCR]</td>
<td>运行时事件</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_EXECUTION]</td>
<td>运行时流程执行实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_IDENTITYLINK]</td>
<td>运行时用户关系信息，存储任务节点与参与者的相关信息<br>(如：组管理中任务候选人信息)</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_JOB]</td>
<td>运行时作业</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_TASK]</td>
<td>运行时任务</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_VARIABLE]</td>
<td>运行时变量表</td>
</tr>
</tbody></table>
<h2 id="工作流程引擎（ProcessEngine）创建"><a href="#工作流程引擎（ProcessEngine）创建" class="headerlink" title="工作流程引擎（ProcessEngine）创建"></a>工作流程引擎（ProcessEngine）创建</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> activiti <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8;<span class="comment">--数据库名随意</span></span><br></pre></td></tr></table></figure>

<h3 id="引入maven依赖"><a href="#引入maven依赖" class="headerlink" title="引入maven依赖"></a>引入maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--activiti-engine中有依赖spring，会自动引入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建流程引擎的配置类（ProcessEngineConfiguration）"><a href="#创建流程引擎的配置类（ProcessEngineConfiguration）" class="headerlink" title="创建流程引擎的配置类（ProcessEngineConfiguration）"></a>创建流程引擎的配置类（ProcessEngineConfiguration）</h3><p>可通过<code>StandaloneProcessEngineConfiguration</code>（默认）或<code>SpringProcessEngineConfiguration</code>与Spring整合两种方式创建<code>ProcessEngineConfiguration</code>。通过<code>ProcessEngineConfiguration</code>可以创建工作流引擎<code>ProceccEngine</code>,</p>
<ul>
<li>默认方式（配置文件名不可修改）</li>
</ul>
<ol>
<li>在resourse目录下创建activiti.cfg.xml配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认id对应的值 为processEngineConfiguration 不可改--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- processEngine Activiti的流程引擎 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- activiti数据库表处理策略 已有表直接更新--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcDriver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///activiti?serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUsername&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcPassword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--也可引入连接池</span></span><br><span class="line"><span class="comment">        	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activiti?serverTimezone=Asia/Shanghai&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建流程引擎</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateTables</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用classpath下的activiti.cfg.xml中的配置创建processEngine</span></span><br><span class="line">        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<span class="comment">//会创建表结构</span></span><br><span class="line">        System.out.println(processEngine);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与spring结合（可自定义配置文件名）</li>
</ul>
<ol>
<li>maven依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--     spring集成   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.activiti<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activiti-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在资源目录下创建配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop/spring-aop-3.1.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx-3.1.xsd &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 工作流引擎配置bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用spring事务管理器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库策略 </span></span><br><span class="line"><span class="comment">            drop-create：在创建流程引擎时创建模式，并在关闭流程引擎时删除模式。</span></span><br><span class="line"><span class="comment">            false：在创建流程引擎时根据库检查数据库模式的版本，如果版本不匹配则抛出异常。</span></span><br><span class="line"><span class="comment">            true：在构建流程引擎时，将执行检查并在必要时执行模式更新。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 流程引擎 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 资源服务service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;repositoryService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-method</span>=<span class="string">&quot;getRepositoryService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 流程运行service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;runtimeService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-method</span>=<span class="string">&quot;getRuntimeService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 任务管理service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;taskService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">factory-method</span>=<span class="string">&quot;getTaskService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 历史管理service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;historyService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getHistoryService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引擎管理service --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;managementService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getManagementService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/activiti?serverTimezone=Asia/Shanghai&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxActive&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 传播行为 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义在service包和所有子包里的任意类的任意方法的执行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span>  <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.czm.service..*.*(..))&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建流程引擎</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateTables</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先构建ProcessEngineConfiguration, processEngineConfiguration名字与配置文件相对应，可自定义</span></span><br><span class="line">        ProcessEngineConfiguration configuration = ProcessEngineConfiguration</span><br><span class="line">                .createProcessEngineConfigurationFromResource</span><br><span class="line">            (<span class="string">&quot;MyActivitiConfig.xml&quot;</span>,<span class="string">&quot;processEngineConfiguration&quot;</span>);</span><br><span class="line">        <span class="comment">//通过ProcessEngineConfiguration创建ProcessEngine，此时会创建数据库</span></span><br><span class="line">        ProcessEngine processEngine = configuration.buildProcessEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程定义"><a href="#流程定义" class="headerlink" title="流程定义"></a>流程定义</h2><ol>
<li>创建bpmn文件，设置流程定义Key为vacation,指定任务代理人（审批人）assignee。</li>
</ol>
<p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210613150221903.png" alt="image-20210613150221903"></p>
<ol start="2">
<li><p>生成png流程图：</p>
<p> 将bpmn文件后缀改为xml，右键选择Diagrams生成并导出png图片，再将原来文件后缀改回bpmn。</p>
</li>
</ol>
<p><strong>注：</strong></p>
<p><strong>Activiti支持使用EL表达式对每个任务的assignee进行设置，在开启流程实例时可通过Map集合将流程变量传入，存储在ACT_RU_VARIABLE表中。也可用监听器的形式设置任务负责人——下面介绍。</strong></p>
<h3 id="可能遇到问题："><a href="#可能遇到问题：" class="headerlink" title="可能遇到问题："></a>可能遇到问题：</h3><ol>
<li>中文乱码：在IDEA的bin目录下的idea64.exe.vmoptions和idea.exe.vmoptions文件丽添加配置<code>-Dfile.encoding=UTF-8</code>。</li>
<li>生产流程png文件时右键xml文件无Diagrams选项。再装个<code>JBoss jBPM</code>插件。</li>
<li>点击bpmn文件BPMN Editor未显示，修改idea主题为Light，再次点击即可显示。</li>
</ol>
<p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210613014438125.png" alt="image-20210613014438125"></p>
<h2 id="Service服务接口"><a href="#Service服务接口" class="headerlink" title="Service服务接口"></a>Service服务接口</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表</p>
<h3 id="Service总览"><a href="#Service总览" class="headerlink" title="Service总览"></a>Service总览</h3><table>
<thead>
<tr>
<th>service名称</th>
<th>service作用</th>
</tr>
</thead>
<tbody><tr>
<td>RepositoryService</td>
<td>Activiti的资源管理类,可管理和控制流程发布包和流程定义</td>
</tr>
<tr>
<td>RuntimeService</td>
<td>Activiti的流程运行管理类，可获取很多关于流程执行相关的信息</td>
</tr>
<tr>
<td>TaskService</td>
<td>Activiti的任务管理类，可获取任务的信息。</td>
</tr>
<tr>
<td>HistoryService</td>
<td>Activiti的历史管理类，查询历史信息，比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径等。</td>
</tr>
<tr>
<td>ManagerService</td>
<td>Activiti的引擎管理类，对 Activiti 流程引擎的管理和维护，主要用于 Activiti 系统的日常维护。</td>
</tr>
</tbody></table>
<h2 id="流程部署"><a href="#流程部署" class="headerlink" title="流程部署"></a>流程部署</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ProcessEngine processEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProcessEngine</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        ProcessEngineConfiguration configuration = ProcessEngineConfiguration</span><br><span class="line">                .createProcessEngineConfigurationFromResource</span><br><span class="line">                        (<span class="string">&quot;MyActivitiConfig.xml&quot;</span>,<span class="string">&quot;processEngineConfiguration&quot;</span>);</span><br><span class="line">        <span class="comment">//通过ProcessEngineConfiguration创建ProcessEngine，此时会创建数据库</span></span><br><span class="line">        <span class="keyword">this</span>.processEngine = configuration.buildProcessEngine();</span><br><span class="line">       <span class="comment">// this.processEngine = ProcessEngines.getDefaultProcessEngine();</span></span><br><span class="line">        log.info(<span class="string">&quot;执行引擎processEngine：&#123;&#125;&quot;</span>, processEngine);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单独部署</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeployment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获得 RepositoryService实例</span></span><br><span class="line">        RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">        <span class="comment">//使用RepositoryService进行部署</span></span><br><span class="line">        Deployment deployment = repositoryService.createDeployment()</span><br><span class="line">                .addClasspathResource(<span class="string">&quot;bpmn/vacation.bpmn&quot;</span>) <span class="comment">// 添加bpmn资源</span></span><br><span class="line">                .addClasspathResource(<span class="string">&quot;bpmn/vacation.png&quot;</span>)  <span class="comment">// 添加png资源</span></span><br><span class="line">                .name(<span class="string">&quot;请假申请流程&quot;</span>)</span><br><span class="line">                .deploy();</span><br><span class="line">        log.info(<span class="string">&quot;流程部署id：&quot;</span> + deployment.getId());</span><br><span class="line">        log.info(<span class="string">&quot;流程部署名称：&quot;</span> + deployment.getName());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zip压缩包批量部署</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deployProcessByZip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义zip输入流</span></span><br><span class="line">        InputStream inputStream = <span class="keyword">this</span></span><br><span class="line">                .getClass()</span><br><span class="line">                .getClassLoader()</span><br><span class="line">                .getResourceAsStream(</span><br><span class="line">                        <span class="string">&quot;bpmn/bpmn.zip&quot;</span>);</span><br><span class="line">        ZipInputStream zipInputStream = <span class="keyword">new</span> ZipInputStream(inputStream);</span><br><span class="line">        <span class="comment">// 获取repositoryService</span></span><br><span class="line">        RepositoryService repositoryService = processEngine</span><br><span class="line">                .getRepositoryService();</span><br><span class="line">        <span class="comment">// 流程部署</span></span><br><span class="line">        Deployment deployment = repositoryService.createDeployment()</span><br><span class="line">                .addZipInputStream(zipInputStream)</span><br><span class="line">                .deploy();</span><br><span class="line">        log.info(<span class="string">&quot;流程部署id：&quot;</span> + deployment.getId());</span><br><span class="line">        log.info(<span class="string">&quot;流程部署名称：&quot;</span> + deployment.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除流程部署</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDeployment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过流程引擎获取repositoryService</span></span><br><span class="line">        RepositoryService repositoryService = processEngine</span><br><span class="line">                .getRepositoryService();</span><br><span class="line">        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()</span><br><span class="line">                .processDefinitionKey(<span class="string">&quot;vacation&quot;</span>)</span><br><span class="line">                .singleResult();</span><br><span class="line">        <span class="comment">//删除流程定义，如果该流程定义已有流程实例启动则删除时出错</span></span><br><span class="line">        repositoryService.deleteDeployment(processDefinition.getDeploymentId());</span><br><span class="line">        <span class="comment">//设置true 级联删除流程定义，即使该流程有流程实例启动也可以删除，设置为false非级联级别删除方式（默认）</span></span><br><span class="line">        <span class="comment">//repositoryService.deleteDeployment(deploymentId, true);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ACT_RE_PROCDEF表中可看到压缩包里的两个流程</p>
<p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210613155448631.png" alt="image-20210613155448631"></p>
<h2 id="流程实例"><a href="#流程实例" class="headerlink" title="流程实例"></a>流程实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 启动流程实例</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStartProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//        根据流程定义的id启动流程</span></span><br><span class="line">    ProcessInstance instance = runtimeService.startProcessInstanceByKey(<span class="string">&quot;vacation&quot;</span>);</span><br><span class="line">    <span class="comment">//businessKey与我们实际业务想关联，存在act_ru_execution表中, map存储的是要传递的变量，存储在ACT_RU_VARIABLE表中，可用EL表达式取出设置任务assignee</span></span><br><span class="line"><span class="comment">//        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span></span><br><span class="line"><span class="comment">//        map.put(&quot;assignee&quot;, &quot;王五&quot;);</span></span><br><span class="line"><span class="comment">//        runtimeService.startProcessInstanceByKey(&quot;vacation&quot;, &quot;businessKey&quot;, map);</span></span><br><span class="line">    <span class="comment">//        4、输出内容</span></span><br><span class="line">    log.info(<span class="string">&quot;流程定义ID：&#123;&#125;&quot;</span>,instance.getProcessDefinitionId());</span><br><span class="line">    log.info(<span class="string">&quot;流程实例ID：&#123;&#125;&quot;</span>,instance.getId());</span><br><span class="line">    log.info(<span class="string">&quot;当前活动的ID：&#123;&#125;&quot;</span>,instance.getActivityId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成个人任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line"></span><br><span class="line">    Task task = taskService.createTaskQuery()</span><br><span class="line">        .processDefinitionKey(<span class="string">&quot;vacation&quot;</span>)</span><br><span class="line">        .taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">        <span class="comment">//.list() 多个时使用</span></span><br><span class="line">        .singleResult();</span><br><span class="line">    <span class="comment">//        //完成jack的任务</span></span><br><span class="line">    <span class="comment">//        Task task2 = taskService.createTaskQuery()</span></span><br><span class="line">    <span class="comment">//                .processDefinitionKey(&quot;vacation&quot;)</span></span><br><span class="line">    <span class="comment">//                .taskAssignee(&quot;李四&quot;)</span></span><br><span class="line">    <span class="comment">//                .singleResult();</span></span><br><span class="line">    <span class="comment">//       // 完成rose的任务</span></span><br><span class="line">    <span class="comment">//        Task task3 = taskService.createTaskQuery()</span></span><br><span class="line">    <span class="comment">//                .processDefinitionKey(&quot;vacation&quot;)</span></span><br><span class="line">    <span class="comment">//                .taskAssignee(&quot;王五&quot;)</span></span><br><span class="line">    <span class="comment">//                .singleResult();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;流程实例id=&#123;&#125;&quot;</span>,task.getProcessInstanceId());</span><br><span class="line">    log.info(<span class="string">&quot;任务Id=&#123;&#125;&quot;</span>,task.getId());</span><br><span class="line">    log.info(<span class="string">&quot;任务负责人=&#123;&#125;&quot;</span>,task.getAssignee());</span><br><span class="line">    log.info(<span class="string">&quot;任务名称=&#123;&#125;&quot;</span>,task.getName());</span><br><span class="line">    <span class="comment">//        完成的任务</span></span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询个人待执行的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindPersonalTaskList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//        获取taskService</span></span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//        根据流程key 和 任务的负责人 查询任务</span></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">        .processDefinitionKey(<span class="string">&quot;vacation&quot;</span>) <span class="comment">//流程Key</span></span><br><span class="line">        .taskAssignee(<span class="string">&quot;张三&quot;</span>)  <span class="comment">//要查询的负责人</span></span><br><span class="line">        .list();</span><br><span class="line">    <span class="keyword">for</span> (Task task : taskList) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;流程实例id=&#123;&#125;&quot;</span>,task.getProcessInstanceId());</span><br><span class="line">        log.info(<span class="string">&quot;任务Id=&#123;&#125;&quot;</span>,task.getId());</span><br><span class="line">        log.info(<span class="string">&quot;任务负责人=&#123;&#125;&quot;</span>,task.getAssignee());</span><br><span class="line">        log.info(<span class="string">&quot;任务名称=&#123;&#125;&quot;</span>,task.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="历史信息"><a href="#历史信息" class="headerlink" title="历史信息"></a>历史信息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查看历史信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findHistoryInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HistoryService historyService = processEngine.getHistoryService();</span><br><span class="line">    <span class="comment">//        获取 actinst表的查询对象</span></span><br><span class="line">    HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();</span><br><span class="line">    <span class="comment">//        查询 actinst表，添加条件</span></span><br><span class="line">    instanceQuery.processDefinitionId(processEngine.getRepositoryService().createProcessDefinitionQuery().processDefinitionKey(<span class="string">&quot;vacation&quot;</span>).singleResult().getId());</span><br><span class="line">    <span class="comment">//        增加排序操作,orderByHistoricActivityInstanceStartTime 根据开始时间排序 asc 升序</span></span><br><span class="line">    instanceQuery.orderByHistoricActivityInstanceStartTime().asc();</span><br><span class="line">    <span class="comment">//        查询所有内容</span></span><br><span class="line">    List&lt;HistoricActivityInstance&gt; activityInstanceList = instanceQuery.list();</span><br><span class="line">    <span class="comment">//        输出</span></span><br><span class="line">    <span class="keyword">for</span> (HistoricActivityInstance hi : activityInstanceList) &#123;</span><br><span class="line">        log.info(hi.getActivityId());</span><br><span class="line">        log.info(hi.getActivityName());</span><br><span class="line">        log.info(hi.getProcessDefinitionId());</span><br><span class="line">        log.info(hi.getProcessInstanceId());</span><br><span class="line">        log.info(<span class="string">&quot;&lt;==========================&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载 资源文件</span></span><br><span class="line"><span class="comment">     * 方案1： 使用Activiti提供的api，来下载资源文件,保存到文件目录</span></span><br><span class="line"><span class="comment">     * 方案2： 自己写代码从数据库中下载文件，使用jdbc对blob 类型，clob类型数据读取出来，保存到文件目录</span></span><br><span class="line"><span class="comment">     * 解决Io操作：commons-io.jar</span></span><br><span class="line"><span class="comment">     * 这里我们使用方案1，Activiti提供的api：RespositoryService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDeployment</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//      获取查询对象 ProcessDefinitionQuery查询流程定义信息</span></span><br><span class="line">    ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()</span><br><span class="line">        .processDefinitionKey(<span class="string">&quot;vacation&quot;</span>)</span><br><span class="line">        .singleResult();</span><br><span class="line">    <span class="comment">//        通过流程定义信息，获取部署ID</span></span><br><span class="line">    String deploymentId = processDefinition.getDeploymentId();</span><br><span class="line">    <span class="comment">//        通过RepositoryService ，传递部署id参数，读取资源信息（png 和 bpmn）</span></span><br><span class="line">    <span class="comment">//         获取png图片的流</span></span><br><span class="line">    <span class="comment">//        从流程定义表中，获取png图片的目录和名字</span></span><br><span class="line">    String pngName = processDefinition.getDiagramResourceName();</span><br><span class="line">    <span class="comment">//        通过 部署id和 文件名字来获取图片的资源</span></span><br><span class="line">    InputStream pngInput = repositoryService.getResourceAsStream(deploymentId, pngName);</span><br><span class="line">    <span class="comment">//         获取bpmn的流</span></span><br><span class="line">    String bpmnName = processDefinition.getResourceName();</span><br><span class="line">    InputStream bpmnInput = repositoryService.getResourceAsStream(deploymentId, bpmnName);</span><br><span class="line">    <span class="comment">//        构造OutputStream流</span></span><br><span class="line">    File pngFile = <span class="keyword">new</span> File(<span class="string">&quot;d:/vacation.png&quot;</span>);</span><br><span class="line">    File bpmnFile = <span class="keyword">new</span> File(<span class="string">&quot;d:/vacation.bpmn&quot;</span>);</span><br><span class="line">    FileOutputStream pngOutStream = <span class="keyword">new</span> FileOutputStream(pngFile);</span><br><span class="line">    FileOutputStream bpmnOutStream = <span class="keyword">new</span> FileOutputStream(bpmnFile);</span><br><span class="line">    <span class="comment">//        输入流，输出流的转换</span></span><br><span class="line">    IOUtils.copy(pngInput,pngOutStream);</span><br><span class="line">    IOUtils.copy(bpmnInput,bpmnOutStream);</span><br><span class="line">    <span class="comment">//        关闭流</span></span><br><span class="line">    pngOutStream.close();</span><br><span class="line">    bpmnOutStream.close();</span><br><span class="line">    pngInput.close();</span><br><span class="line">    bpmnInput.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流程负责人设置（三种方式）"><a href="#流程负责人设置（三种方式）" class="headerlink" title="流程负责人设置（三种方式）"></a>流程负责人设置（三种方式）</h2><ol>
<li><h3 id="固定方式：前面已有。"><a href="#固定方式：前面已有。" class="headerlink" title="固定方式：前面已有。"></a>固定方式：前面已有。</h3></li>
<li><h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3></li>
</ol>
<p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210613234130451.png" alt="image-20210613234130451"></p>
<ol start="3">
<li><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.czm.listener;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.DelegateTask;</span><br><span class="line"><span class="keyword">import</span> org.activiti.engine.delegate.TaskListener;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> CZM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021/6/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAssigneeListener</span> <span class="keyword">implements</span> <span class="title">TaskListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(DelegateTask delegateTask)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;delegateTask:&#123;&#125;&quot;</span>, Objects.toString(delegateTask));</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;testListener&quot;</span>.equals(delegateTask.getName()) &amp;&amp; <span class="string">&quot;create&quot;</span>.equals(delegateTask.getEventName())) &#123;</span><br><span class="line">                delegateTask.setAssignee(<span class="string">&quot;通过listener设置&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>idea插件不知为啥设置不了，只能编辑文件配置监视器。</strong></p>
<p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210613234513819.png" alt="image-20210613234513819"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试设置任务负责人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAssagnee</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获得 RepositoryService实例</span></span><br><span class="line">    RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//使用RepositoryService进行部署</span></span><br><span class="line">    Deployment deployment = repositoryService.createDeployment()</span><br><span class="line">        .addClasspathResource(<span class="string">&quot;bpmn/testListener.bpmn&quot;</span>) <span class="comment">// 添加bpmn资源</span></span><br><span class="line">        .name(<span class="string">&quot;测试设置负责人&quot;</span>)</span><br><span class="line">        .deploy();</span><br><span class="line">    log.info(<span class="string">&quot;流程部署id：&quot;</span> + deployment.getId());</span><br><span class="line">    log.info(<span class="string">&quot;流程部署名称：&quot;</span> + deployment.getName());</span><br><span class="line">    RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//        根据流程定义的id启动流程</span></span><br><span class="line">    <span class="comment">//businessKey与我们实际业务想关联, map存储的是要传递的变量，存储在ACT_RU_VARIABLE表中，可用EL表达式取出设置任务assignee</span></span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;assigneeEL&quot;</span>, <span class="string">&quot;通过EL设置&quot;</span>);</span><br><span class="line">    ProcessInstance instance = runtimeService.startProcessInstanceByKey(<span class="string">&quot;testListener&quot;</span>, <span class="string">&quot;businessKey&quot;</span>, variables);</span><br><span class="line">    <span class="comment">//        4、输出内容</span></span><br><span class="line">    log.info(<span class="string">&quot;流程定义ID：&#123;&#125;&quot;</span>,instance.getProcessDefinitionId());</span><br><span class="line">    log.info(<span class="string">&quot;流程实例ID：&#123;&#125;&quot;</span>,instance.getId());</span><br><span class="line">    log.info(<span class="string">&quot;当前活动的ID：&#123;&#125;&quot;</span>,instance.getActivityId());</span><br><span class="line"></span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line"></span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery().processInstanceId(instance.getId()).list();</span><br><span class="line">    <span class="keyword">for</span> (Task task : taskList) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;流程实例id=&#123;&#125;&quot;</span>,task.getProcessInstanceId());</span><br><span class="line">        log.info(<span class="string">&quot;任务Id=&#123;&#125;&quot;</span>,task.getId());</span><br><span class="line">        log.info(<span class="string">&quot;任务负责人=&#123;&#125;&quot;</span>,task.getAssignee());</span><br><span class="line">        log.info(<span class="string">&quot;任务名称=&#123;&#125;&quot;</span>,task.getName());</span><br><span class="line">        taskService.complete(task.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p><img src="/2021/06/13/%E5%85%B6%E4%BB%96/Activiti%E5%88%9D%E6%8E%A2/image-20210614172501904.png" alt="image-20210614172501904"></p>
<h3 id="作用：用来控制流程走向。"><a href="#作用：用来控制流程走向。" class="headerlink" title="作用：用来控制流程走向。"></a>作用：用来控制流程走向。</h3><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>排他网关（<code>ExclusiveGateway</code>）：只会选择条件为true的分支执行，若有多条true分支，选择id较小的执行。若都为false，则系统抛出异常。</li>
<li>并行网关（<code>ParallelGateway</code>）：将流程分成多条分支，也可以把多条分支汇聚到一起，再执行下一任务。<strong>注：并行网关不会解析条件。即使顺序流中定义了条件，也会被忽略。</strong></li>
<li>事件网关（<code>EventGateway</code>）：网关的每个外出顺序流都要连接到一个中间捕获事件。根据它所连接的中间Catching事件来决定流程的走向。</li>
<li>包含网关（<code>InclusiveGateway</code>）：排他和并行网关的结和，只执行条件为true的分支（与排他的区别是可以执行多条分支）。多条true分支汇聚到一起，再会执行下一任务。</li>
</ul>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <tags>
        <tag>工作流</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/2021/02/07/%E9%83%A8%E7%BD%B2/docker/</url>
    <content><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查看容器的挂载目录"><a href="#查看容器的挂载目录" class="headerlink" title="查看容器的挂载目录"></a>查看容器的挂载目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名 | grep Mounts -A 20</span><br><span class="line"><span class="comment"># -A 20（显示Mounts往下20行）</span></span><br><span class="line"><span class="comment"># docker inspect 获取容器/镜像的元数据</span></span><br></pre></td></tr></table></figure>

<h2 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h2 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it  容器名或id /bin/bash</span><br><span class="line"><span class="comment"># 退出 CTRL+Q+P 或直接输入exit</span></span><br></pre></td></tr></table></figure>

<h2 id="重命名容器"><a href="#重命名容器" class="headerlink" title="重命名容器"></a>重命名容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rename 原容器名  新容器名</span><br></pre></td></tr></table></figure>

<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 容器名（返回回key/value json格式数据）</span><br><span class="line">docker inspect -f &#123;&#123;类似EL表达式&#125;&#125; 容器名 <span class="comment">#返回具体参数</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20210514202601652.png" alt="image-20210514202601652"></p>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20210514203047822.png" alt="image-20210514203047822"></p>
<h2 id="拷贝容器里的文件到宿主机"><a href="#拷贝容器里的文件到宿主机" class="headerlink" title="拷贝容器里的文件到宿主机"></a>拷贝容器里的文件到宿主机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp 容器名：容器里文件路径 宿主机路径</span><br></pre></td></tr></table></figure>

<h2 id="镜像搜索"><a href="#镜像搜索" class="headerlink" title="镜像搜索"></a>镜像搜索</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --<span class="built_in">limit</span> int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output：# 描述信息栏不会被截断，会显示完整的描述信息。</span></span><br><span class="line"><span class="string">如：</span></span><br><span class="line"><span class="string"># 只搜索官方镜像</span></span><br><span class="line"><span class="string">docker search --filter &quot;is-official=true&quot; mysql</span></span><br><span class="line"><span class="string">docker search -f &quot;is-official=true&quot; mysql</span></span><br><span class="line"><span class="string"># 只搜索starts不小于100的2个镜像</span></span><br><span class="line"><span class="string">docker search -f stars=100 --limit 2 mysql</span></span><br><span class="line"><span class="string">docker search --filter stars=100  --limit 2 mysql</span></span><br><span class="line"><span class="string"># 只搜索自动化构建镜像</span></span><br><span class="line"><span class="string">docker search -f &quot;is-automated=true&quot; mysql</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 格式化输出</span></span><br><span class="line"><span class="string"># Placeholder	Description</span></span><br><span class="line"><span class="string">#.Name			镜像名称</span></span><br><span class="line"><span class="string">#.Description	镜像描述</span></span><br><span class="line"><span class="string">#.StarCount	stars 数量</span></span><br><span class="line"><span class="string">#.IsOfficial	如果是官方镜像，显示 “OK”</span></span><br><span class="line"><span class="string">#.IsAutomated	如果是自动化构建，显示“OK”</span></span><br><span class="line"><span class="string">docker search --format &quot;&#123;&#123;.Name&#125;&#125;: &#123;&#123;.StarCount&#125;&#125;&quot; mysql --limit  3</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211122145913167.png" alt="image-20211122145913167"></p>
<ul>
<li>STARS：星级（星级越高，代表镜像质量越高）</li>
<li>OFFICIAL：是否官方</li>
<li>AUTOMATED：是否为docker自动化构建</li>
</ul>
<h2 id="查看容器ip"><a href="#查看容器ip" class="headerlink" title="查看容器ip"></a>查看容器ip</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> 容器id</span><br></pre></td></tr></table></figure>

<h2 id="镜像拉取"><a href="#镜像拉取" class="headerlink" title="镜像拉取"></a>镜像拉取</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default <span class="literal">true</span>)</span><br><span class="line">      --platform string         Set platform <span class="keyword">if</span> server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure>

<h2 id="镜像上传"><a href="#镜像上传" class="headerlink" title="镜像上传"></a>镜像上传</h2><p>注：执行push前需要执行login进行用户身份认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br><span class="line">Push an image or a repository to a registry</span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Push all tagged images <span class="keyword">in</span> the repository</span><br><span class="line">      --disable-content-trust   Skip image signing (default <span class="literal">true</span>)</span><br><span class="line">  -q, --quiet                   Suppress verbose output <span class="comment"># 抑制详细输出</span></span><br></pre></td></tr></table></figure>



<h2 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h2><h3 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a>私有仓库搭建与配置</h3><ol>
<li>拉取私有仓库镜像。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>启动私有仓库容器。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>打开浏览器 输入地址<code>ip:5000/v2/_catalog</code>看到<code>&#123;&quot;repositories&quot;:[]&#125;</code> 表示私有仓库搭建成功并且内容为空。</li>
<li>修改daemon.json。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加私有仓库地址，让 docker信任私有仓库地址，保存退出。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;ip:5000&quot;</span>]&#125; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启docker 服务。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h3><ol>
<li>标记镜像为私有仓库的镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag 镜像 ip:5000/镜像tag</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>再次启动私服容器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上传标记的镜像</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push ip:5000/镜像tag</span><br></pre></td></tr></table></figure>



<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="创建并运行MySQL容器"><a href="#创建并运行MySQL容器" class="headerlink" title="创建并运行MySQL容器"></a>创建并运行MySQL容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run </span><br><span class="line">-p 3307:3306 <span class="comment">#端口映射</span></span><br><span class="line">--name mysql-master1 <span class="comment"># 容器名</span></span><br><span class="line"><span class="comment">#挂载路径</span></span><br><span class="line">-v /usr/<span class="built_in">local</span>/mysql_cluster/master1/conf/my.cnf:/etc/mysql/my.cnf <span class="comment">#配置文件</span></span><br><span class="line">-v /usr/<span class="built_in">local</span>/mysql_cluster/master1/data/:/var/lib/mysql  <span class="comment">#数据库数据</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD= root用户密码</span><br><span class="line">-d <span class="comment">#后台运行</span></span><br><span class="line">mysql <span class="comment">#镜像名</span></span><br></pre></td></tr></table></figure>

<h2 id="创建zookeeper容器"><a href="#创建zookeeper容器" class="headerlink" title="创建zookeeper容器"></a>创建zookeeper容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name zookeeper --restart always -d -v /usr/<span class="built_in">local</span>/docker_container_config/zookeeper/conf/:/conf/ -p 2181:2181 zookeeper</span><br><span class="line"></span><br><span class="line"><span class="comment">#--restart always指docker重启时该容器也重启</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#docker container update --restart=always 容器名字</span></span><br></pre></td></tr></table></figure>

<h2 id="创建kafka容器"><a href="#创建kafka容器" class="headerlink" title="创建kafka容器"></a>创建kafka容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=192.168.38.128:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.38.128:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -v /etc/localtime:/etc/localtime -v /usr/<span class="built_in">local</span>/docker_container_config/kafka/config/server.properties:/opt/kafka/config/server.properties wurstmeister/kafka</span><br><span class="line"></span><br><span class="line"><span class="comment">#-e KAFKA_BROKER_ID=0  在kafka集群中，每个kafka都有一个BROKER_ID来区分自己</span></span><br><span class="line"><span class="comment">#-e KAFKA_ZOOKEEPER_CONNECT=192.168.155.56:2181/kafka 配置zookeeper管理kafka的路径192.168.38.128:2181/kafka</span></span><br><span class="line"><span class="comment">#-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.38.128:9092  把kafka的地址端口注册给zookeeper</span></span><br><span class="line"><span class="comment">#-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 配置kafka的监听端口</span></span><br><span class="line"><span class="comment">#-v /etc/localtime:/etc/localtime 容器时间同步虚拟机的时间</span></span><br></pre></td></tr></table></figure>

<h1 id="组件工具"><a href="#组件工具" class="headerlink" title="组件工具"></a>组件工具</h1><ul>
<li><strong>docker-Machine</strong></li>
</ul>
<blockquote>
<p>负责实现对 Docker 运行环境进行安装和管理，特别在管理多个 Docker 环境时，使用 Machine 要比手动管理高效得多。</p>
</blockquote>
<ul>
<li><strong>docker-swarm</strong></li>
</ul>
<blockquote>
<p>提供 Docker 容器集群服务，是docker官方对容器云生态进行支持的核心方案。使用它，用户可以将多个 Docker 主机抽象为大规模的虚拟 Docker 服务，快速打造一套容器云平台。</p>
</blockquote>
<ul>
<li><strong>docker-compose</strong></li>
</ul>
<blockquote>
<p>主要用于docker容器在集群中快速部署。负责实现对基于 Docker器的多应用服务的快速编排，利用docker-compose，从用户可以自定义哪个容器运行在哪个应用。与此同时，docker-compose也支持热部署，而且可以根据负载情况随时扩展。</p>
</blockquote>
<h1 id="DockerfFile"><a href="#DockerfFile" class="headerlink" title="DockerfFile"></a>DockerfFile</h1><p>​    Dockerfile是一个文本文件，存储Docker可以读懂的脚本指令，在这个脚本文件中记录着用户“创建”镜像过程当中需要执行的所有命令。当Docker 读取并执行Dockerfile 中所定义的命令时，这些命令将会产生一些临时文件层（<strong>AUFS</strong>所使用的文件层）。当Dockerfile所有命令都成功执行完之后，Docker 会记录执行过程中所用到的所有文件层，并且会用一个名称来标记这一组文件层。这一组文件层，就被称之为<strong>镜像</strong>（镜像指的是一组特定的文件层）。Docker中镜像的构建过程，就是 Docker 执行Dockerfile中所定义命令而形成这组文件层的过程。Docker中所有的容器都是基于镜像而创建的，而所有的镜像又都是通过Dockerfile而形成的。</p>
<blockquote>
<p>内置命令</p>
</blockquote>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211122165728898.png" alt="image-20211122165728898"></p>
<h3 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM buildpack-deps:wheezy-scm</span><br><span class="line"><span class="comment"># gcc for cgo</span></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get instal1 -y</span><br><span class="line">gcc libc6-dev make l</span><br><span class="line">--no-instal1-recommends N&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ENV GOLANGVERSION 1.5</span><br><span class="line">ENV GOLANG_DOWNLOAD_URL https://golang.org/dl/go<span class="variable">$GOLANG_VERSION</span>.1inux-amd64.tar.gz</span><br><span class="line">ENV GOLANG _DOWNLOAD_SHA1 5817fa4b2252afdbe2e11e8b9dc1d9173ef3bd5a</span><br><span class="line">RUN cur1 -fsSL“<span class="variable">$GOLANG_DOWNLOAD_URL</span><span class="string">&quot; -o golang.tar.gz </span></span><br><span class="line"><span class="string"> &amp;&amp; echo &quot;</span><span class="variable">$GOLANG_DOWNLOAD_SHA1</span> golang.tar.gz<span class="string">&quot; | sha1sum -c - </span></span><br><span class="line"><span class="string"> &amp;&amp; tar-C /usr/local -xzf golang.tar.gzN &amp;&amp; rm golang.tar.gz</span></span><br><span class="line"><span class="string">ENV GOPATH /go</span></span><br><span class="line"><span class="string">ENV PATH <span class="variable">$GOPATH</span>/bin :/usr/local/go/bin:<span class="variable">$PATH</span></span></span><br><span class="line"><span class="string">RUN mkdir -p&quot;</span><span class="variable">$GOPATH</span>/src<span class="string">&quot; &quot;</span><span class="variable">$GOPATH</span>/bin<span class="string">&quot; &amp;&amp; chmod -R 777 &quot;</span> <span class="variable">$GOPATH</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">WORKDIR <span class="variable">$GOPATH</span></span></span><br><span class="line"><span class="string">COPY go-wrapper /usr/local/bin/</span></span><br></pre></td></tr></table></figure>

<h2 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h2><p>AUFS（Advanced Multi Layered Unification Filesystem 高级多层次统一文件系统）是一个堆栈式联合文件系统。它可以将不同地方的目录挂载到同一个虚拟文件系统之中，并且形成“文件层”。在将不同目录挂载到同一文件系统下时，还可以给不同目录设定<strong>只读、只写和写出</strong>三种权限。AUFS在挂载目录时，会严格按照先基础目录(父文件层）再增量目录(子文件层）的顺序进行挂载。（docker通过AUFS实现镜像文件层、数据共享）所有目录都挂载完之后，AUFS 会再挂载一个可读可写的目录，而以后所有的写操作都会体现在此目录中（docker容器的修改操作都在这一层）。</p>
<h1 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h1><h2 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h2><p>​    <strong>LXC</strong>(Linux container)是整个Docker运行的基础。众所周知，CPU、内存、IO、网络等都称之为系统资源，而Linux内核有一套机制来管理其所拥有的这些资源，这套机制的核心被称之为CGroups和Namespaces。</p>
<h3 id="CGroups（Controller-Groups）"><a href="#CGroups（Controller-Groups）" class="headerlink" title="CGroups（Controller Groups）"></a><strong>CGroups</strong>（Controller Groups）</h3><p>为资源管理提供了一个统一框架，可以把系统任务及其子任务整合（或分隔）到按资源等级而划分的不同任务组内，并且对这些任务组实施不同的资源分配方案。可以限制、记录、调整进程组所使用的物理资源（包括CPU、memory、I/O等)。如:使用CGroups可以给某项进程组多分配一些CPU使用周期。同样也可以通过CGroups限制某项进程组可使用的内存上限。同时CGroups 也具有记录物理资源使用情况的功能，比如 CGroups调用 <code>cpuacct</code>子系统就可以记录每个进程所使用的<strong>内存数量、CPU时间等数据</strong>。正因为Linux有了CGroups资源管理机制，内核虚拟化才变成了可能。</p>
<blockquote>
<ul>
<li>CGroups机制中有四个重要概念。<br> 任务（ task)。一个任务对应宿主机环境当中的一个进程。</li>
<li>子系统（subsystem)。每一个子系统是对某一项具体物理资源的控制器。例如，cpu子系统就是对CPU资源的控制，内存子系统就是对内存资源的控制。</li>
<li>控制组(control group)。cgroups当中最基本的控制单元。一个group包含若干个任务(对应宿主环境的进程)，并且此 group也会包含若干子系统，用来控制group 内的仕务仕指疋丁系统上面的资源使用。</li>
<li>层级树(hierarchy)。cgroups的调度单位，由一个或多个group组成的树状结构。每个hierarchy通过绑定对应的子系统进行资源调度，同时子节点继承父节点的属性。整个系统可以有多个hierarchy。</li>
</ul>
<p><strong>cgroups共有10个子系统</strong>:（执行<code>ls /sys/fs/cgroup/</code>命令查看）</p>
<ol>
<li>blkio:为块设备（比如磁盘，固态硬盘，USB等）设定IO限制。</li>
<li>cpu: 对CPU资源的控制。</li>
<li>cpuacct:为cgroup中任务生成CPU 资源使用报告。</li>
<li>cpuset:在多CPU系统中，为cgroup中的任务分配独立CPU和内存节点。</li>
<li>devices:设置任务对物理设备的访问权限。</li>
<li>freezer:挂起或者恢复cgroup 中的任务。</li>
<li>memory:设定cgroup中任务使用的内存限制，同时生成任务的内存资源使用报告。</li>
<li>net_cls:使用等级识别符（classid)标记网络数据包，同时使用Linux流量控制程序(tc)识别从具体cgroup 中生成的数据包。</li>
<li>net_prio:对应用程序设置网络传输优先级，类似于socket选项的SO_PRIORITY。</li>
<li>HugeTLB:HugeTLB页的资源控制功能。</li>
</ol>
</blockquote>
<h3 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a><strong>Namespaces</strong></h3><p>一个重要的资源隔离机制。Namespaces 将进程、进程组、IPC（Inter-Process Communication，进程间通信资源：管道、消息队列……）、网络、内存等资源都变得不再是全局性资源，而是将这些资源从内核层面属于某个特定的Namespace。在不同的Namespace之间，这些资源是相互透明、不可见的。比如说，A用户登录系统后，可以查看到B用户的进程PID。虽说A用户不能杀死B用户的进程，但A和B却能相互感知。但假如A用户在Namespace-A中，B用户在Namespace-B中，虽然A和B仍然共存于同一个Linux操作系统当中，但A却无法感知到B。在这种情况下，Linux内核不但将Namespace相互隔离，而且将所分配的资源牢牢固定在各自空间之中。</p>
<p><strong>IPC Namespace</strong></p>
<blockquote>
<p>Linux系统进程间通讯主要包括：信号量、消息队列和共享内存，对于一个资源隔离的容器来说，容器内的进程只能访问主机分配给它的资源，IPC Namespace允许容器内所有进程通过全局唯一的32位标识符访问共享资源。使容器内部的进程通信，对于宿主机来说，就是相同PID的进程通信。</p>
</blockquote>
<p><strong>PID Namespace</strong></p>
<blockquote>
<p>容器之间的进程树相互不可见。通过PID Namespace，为容器创建了独立的进程资源，每个容器中都会有一个进程号计数器，容器内所有的进程号都会重新编号。宿主机的内核会维护各个容器中的进程树，在树最顶端的进程亏变为l，也就定Init进柱。此进程会作为容器内其他所有进程的父进程来执行容器环境的初始化工作。但此Init进程毕竟不是实际操作系统中的 Init进程，在宿主机环境中，只是个普通进程。所以容器中的Init进程其实是一个伪 Init进程，它无法像真正的 Init 进程那样“守护”整个容器操作环境。当Init进程下面所有的子进程都退出后，它也就无可避免地需要退出。而这也就是每个容器启动时都需要指定一个<strong>不可退出的进程作为CMD的原因</strong>。同时Init进程作为容器中所有进程的父进程，还肩负着关闭和销毁容器的责任。因为借助于PID Namespace在容器中所产生的进程树，处于树顶点的 Init进程可以看到容器中所有的子进程，并且可以通过信号量来影响子进程的行为。所以 Docker CLI 中的Stop或者Kill 命令的本质，就是向容器中的Init进程发送SIGSTOP信号或者SIGKILL信号。一旦容器处于顶点的Init进程被销毁，那么和其处于同一个 PID Namespace的所有进程都将会接收到内核发送的SIGSTOP或者SIGKILL信号而被销毁。</p>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211123011325510.png" alt="image-20211123011325510"></p>
</blockquote>
<p><strong>UTS Namespace</strong></p>
<blockquote>
<p>PID Namespace使容器拥有独立进程树，仅仅只能在宿主环境层面可以被视为独立节点。UTS Namespace使容器在网络层面被设为一个独立节点。它为每个容器设置了容器主机名和容器域名，因为这两个属性在每个容器当中都是独立且唯一的，因此每个容器在网络中都可被设为单独节点，拥有了独立主机名和域名资源，而非宿主机环境中的单独进程。</p>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211123011245309.png" alt="image-20211123011245309"></p>
</blockquote>
<p><strong>Network Namespace</strong></p>
<blockquote>
<p><strong>为每个容器隔离网络资源</strong>。在 Linux系统中一个物理设备最多只能被包括在一个Network Namespace中，但我们所创建的容器却不止一个。Docker为每个容器的Network创建一对虚拟网络设备，一个名为eth0，放置到容器当中;另外一个名为vethN，放置到宿主机环境当中。这样从一个设备中流入数据，就可以从相对应的另外一个设备中读取到数据。虽然从宿主机内核层面来看，其<strong>实这两个网卡只是管道的两端</strong>;但从容器中来看，这就是两块实际的网卡。通过这种方式，可以达到容器和内核之间数据流通的目的。但为了达到<strong>不同容器可以作为网络单独节点进行数据交互</strong>的目标，Docker在Network Namespace中还为<strong>每个容器设置了IP路由表</strong>。宿主机环境此时就充当了路由器的角色，因此毫不相干的两个容器就可以通过其内部的”网卡”互通数据。</p>
</blockquote>
<p><strong>User Namespace</strong></p>
<blockquote>
<p>docker通过User Namespace隔离了所有与用户相关的资源，包括用户ID、用户组ID、用户权限。但无论容器中的用户怎么变，始终对应的是宿主机环境中所创建容器的用户，而且这种关联关系通过/proc/[pid]/uid_map和/proc/[pid]/gid_map这两个文件予以保存。</p>
</blockquote>
<p><strong>Mount Namespace</strong></p>
<blockquote>
<p>docker通过 Mount namespace为每个容器分配了独立的文件系统。因为在 Mount Namespace当中，可以通过隔离文件挂载点的方式提供隔离的文件系统，因此，Docker为每个容器创建一个其独有的目录，并且将此容器所依赖的镜像文件层按照先父后子的顺序，逐层挂载到此目录当中。隔离完成之后，不同的Mount Namespace之间的数据互不影响。同时，Docker 会将当前目录设置为read-only模式，对此目录所做出的所有写操作都将体现到另外一个目录，而这个目录也就是writable文件层。</p>
</blockquote>
<p>而LXC就是基于Linux内核通过调用CGroups 和Namespaces，来实现容器轻量级虚拟化的一项技术，与此同时，LXC也是一组面向Linux内核容器的用户态API接口。用户通过LXC提供的资源限制和隔离功能，可以创建一套完整并且相互隔离的虚拟应用运行环境。Docker就是采用LXC技术来创建容器的工具, 因此LXC是Docker运行的基础，而 <strong>docker则是LXC的杀手级应用</strong>。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul>
<li><strong>Docker Daemon</strong>：负责维护 Docker运行的守护进程，担负看资源官理、仕务调度等多项功能。</li>
<li><strong>Docker Image</strong>（镜像)：属于静态文件系统</li>
<li><strong>Docker Container</strong>（容器)：基于Image真正提供应用服务的计算单元。</li>
</ul>
<p>三者关系: Container 基于Image被 Daemon创建和管理，来实现提供服务的功能。因为Container负责提供服务，所以处于核心位置。因而当我们谈论到Docker生命周期时，更多的指的是Docker Container的生命周期。</p>
<blockquote>
<p>Docker Container的生命周期</p>
</blockquote>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211122210958992.png" alt="image-20211122210958992"></p>
<h2 id="Docker-Daemon主要任务"><a href="#Docker-Daemon主要任务" class="headerlink" title="Docker Daemon主要任务"></a>Docker Daemon主要任务</h2><ul>
<li>负责任务调度，它需要将客户端传来的命令请求转化为特定的任务。</li>
<li>负责维护镜像数据。一个完整的镜像由许多的子文件层组成，而这个镜像的依赖关系就是由 Daemon来维护的。</li>
<li>负责容器虚拟化。虚拟化是一个较大的概念，具体来说就是资源分配和资源隔离。</li>
<li>负责容器生命周期。Daemon需要根据用户指令和容器自身状态来维护容器的生命周期。</li>
</ul>
<blockquote>
<p>四项任务关系图</p>
</blockquote>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211122212748209.png" alt="image-20211122212748209"></p>
<p>Engine模块用来监听来自客户端的Restful API请求，Engine既可以通过unix:/来监听本地 socket 文件（默认是Docker.sock)，也可以通过tcp:/l的方式来监听某一个端口。当然也可以选择两种方式同时监听。</p>
<p>Engine模块会将接收到的命令请求转化为具体的Job，而转化的依据就是存放在Daemon当中的API路由表。每一个API都有唯一与之相对应的Handler函数，在此Handler函数中，会有一系列的逻辑来处理客户端请求。而负责处理请求的逻辑函数，在 Docker Daemon当中就以Job的形式运行。</p>
<p>Router、Handler和Job这三项共同组成了JobServer。而Engine每接收到一次来自于客户端的处理请求，就会生出一个 JobServer。当Job完成作业，并将数据返回给客户端之后，此JobServer也会随之销毁。</p>
<p>在Docker Daemon中，只有两种Job类型:Image Job和 Container Job。Image Job重点在于通过 AUFS 文件系统来维护镜像数据，而 Container Job则侧重于管理资源。</p>
<blockquote>
<p>Docker Daemon通过LXC管理资源的过程</p>
</blockquote>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211122213212201.png" alt="image-20211122213212201"></p>
<p>Daemon并不参与资源分配和隔离的工作，这些工作都是由虚拟化驱动来完成的。充当虚拟化驱动的有LXC、Libcontainer、Libvirt和 nspawn。（Libcontainer是Docker自行开发用于管理资源的驱动库，Docker最初使用LXC，后面替换为libcontainer。）Daemon通过驱动库来管理Cgroups、namespaces、SELinux等各个组件，然后再基于所创建的资源使用方案产生一个可用的容器。</p>
<p><a href="http://dockone.io/article/1513">Docker五种存储驱动原理及应用场景和性能测试对比</a></p>
<blockquote>
<p>docker<strong>客户端</strong>与<strong>服务端</strong>交互大致流程</p>
</blockquote>
<p><img src="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/image-20211122220713188.png" alt="image-20211122220713188"></p>
<p>每一个 Docker CLI都必须通过<strong>Rest API</strong>的方式调用Docker Daemon完成某项特定的工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>书：《Docker全攻略》</p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ深入学习</title>
    <url>/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RocketMQ是一款分布式、队列模型的消息中间件。基于发布订阅模式，有Push和Pull两种消费方式，支持严格的消息顺序，亿级别的堆积能力，支持消息回溯和多个维度的消息查询。</p>
<p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">RocketMQ官方文档</a></p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="架构设计"></p>
<h3 id="主要组成成分"><a href="#主要组成成分" class="headerlink" title="主要组成成分"></a>主要组成成分</h3><ul>
<li><p>NameServer：简单的注册中心，用户broker（主机）的动态注册与发现。保存Broker集群的注册信息（路由信息），并有心跳机制(每10s一次检测Broker是否存活)。<strong>NameServer集群之间不进行信息通讯</strong>，是一个几乎无状态节点，每个实例都保存完整的路由信息。</p>
</li>
<li><p>Broker： MQ服务器，负责消息队列主体功能，有主从两种身份，通过配置文件brokerId=0（master）或非0（slave）指定。每个Broker与NameServer集群<strong>所有节点</strong>建立连接，<strong>每隔30s</strong>注册Topic信息到NameServer所有节点。注：Master与Slave的关系是一对多，但只有BrokerId=1的从服务器才会参与消息的读负载。</p>
<p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rocketmq_architecture_2.png"></p>
</li>
</ul>
<p>  Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</p>
<p>  Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</p>
<p>  Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</p>
<p>  HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p>
<p>  Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</p>
<ul>
<li><p>Producer: 消息生产者，随机选择NameServer建立长连接并定期（<strong>每隔30s</strong>）获取Topic路由信息。与master建立长连接，保持心跳。</p>
</li>
<li><p>Consumer：消息消费者，随机选择NameServer建立长连接并定期获取Topic路由信息。与master、slave建立长连接，保持心跳。支持推（<strong>实时性好，但需注意消费者消费能力</strong>）、拉两种消费模式，集群消费与广播消费两种消费方式。</p>
</li>
</ul>
<h3 id="其他重要概念"><a href="#其他重要概念" class="headerlink" title="其他重要概念"></a>其他重要概念</h3><ul>
<li>Topic：主题用于表示一类消息的集合，<strong>每条消息只能属于一个主题</strong>，是RocketMQ进行消息订阅的基本单位。生产消费者与toipc都是1对n关系，Topic是一个上逻辑概念。消息存储不会按Topic分开。</li>
<li>Group：组区分，标识一类应用，分生产者组和消费者组，属于同一组的生产/消费者生产/消费同一类消息且处理逻辑一致。组的区分使消费者实现负载均衡和容错的目标或广播变得非常容易。<strong>发送分布式事务消息时，如果Producer中途意外宕机，Broker会主动回调同一组内的任意一台Producer机器来确认事务状态。</strong></li>
<li>Message：消息载体，生产和消费数据的最小单位，可通过唯一MeaasgeID或业务标识key查询消息。MessageId的长度总共有<strong>16字</strong>节，其中包含了消息<strong>存储主机地址</strong>（IP地址和端口），消息Commit Log <strong>offset</strong>。</li>
<li>Tag：标签，用于同一主题区分不同消息，消费者可以根据Tag实现对不同子主题的不同消费逻辑，<strong>可用于消息过滤</strong>，如：consumer.subscribe(topic, “tag1 || tag2”)订阅消费topic主题tag1或tag2的消息。*<em>传入 null,””,”</em>“都是表示订阅全部的作用**。</li>
<li>Queue: Topic与queue是一对多关系，主要用于负载均衡。</li>
<li>Offset: 存储消息时会为每个topic下的每个Queue生成一个消息的索引文件，每个queue都对应一个offset记录当前queue中消息条数。存储消息数据的log文件是顺序存储的，通过二分查找定位数据，时间复杂度可降到logN。</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>启动NameServer监听端口，等待Broker、Producer、Consumer连接。</li>
<li>启动Broker与所有NameServer保持长连接，定时发送心跳包。心跳包中包含当前<strong>Broker信息(IP+端口等)以及存储所有Topic信息</strong>。注册成功后，<strong>NameServer集群中就有Topic跟Broker的映射关系。</strong> (下面源码分析RouteInfoManager有介绍)</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><ul>
<li><p>全局顺序</p>
<p>对于指定topic，全部消息都按照严格的先入先出（FIFO）的顺序进行发布和消费。 <strong>（性能低）</strong></p>
</li>
<li><p>局部顺序</p>
<p>通过是实现MessageQueueSelector重写select方法，对于业务要求顺便的的消息发送到到相同分区（局部顺序性）。</p>
</li>
</ul>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>服务端过滤</p>
<p>tag：大多数业务使用场景</p>
<p>bySql：部分业务线使用，支持<strong>SQL92</strong>语法，通过MessageSelector.bySql(“sql语句”)编写。</p>
<p>优点：减少了对于Consumer无用消息的网络传输。</p>
<p>缺点：增加了Broker的负担、而且实现相对复杂。</p>
<h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><p>延时等级（从1开始，小于0不重试，直接存入死信队列，18个level，通过msg.setDelayLevel(level)设置）：“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”</p>
<p>原理：定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/message.png"></p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>1.  CommitLog</strong>: 消息主体以及元数据储存主体，默认大小为1G。文件名以20位数字组成（右边为起偏移量，左边补0）如：00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong>顺序写</strong>入日志文件，当文件满了，写入下一个文件。</p>
<p><strong>2. ConsumeQueue：</strong>消费者队列（逻辑消费队列）作为消费消息的<strong>索引</strong>，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。<strong>引入的目的主要是提高消息消费的性能</strong>。consumequeue文件采取定长设计，<strong>每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode</strong>，单个文件由30W个条目组成，可以像<strong>数组一样随机访问每一个条目</strong>，每个ConsumeQueue文件大小约5.72M。</p>
<p>结构如下：</p>
<p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rocketmq_design_7.png" alt="img"></p>
<p><strong>3. IndexFile：</strong> 索引文件，<strong>用于通过key或msgId来查询消息</strong>。单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，底层存储设计为在文件系统中实现<strong>HashMap</strong>结构<strong>即hash索引。</strong>RocketMQ的混合型存储结构(统一broker的多个Topic的消息实体内容都存储于一个CommitLog中)，当消费者无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待<strong>30s</strong>的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。<img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/indexFile.png"></p>
<h3 id="数据存取优化"><a href="#数据存取优化" class="headerlink" title="数据存取优化"></a>数据存取优化</h3><h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>RocketMQ通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（减少了内核缓冲区和用户缓冲区之间数据拷贝），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（<strong>正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存</strong>）</p>
<h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。OS访问物理磁盘上文件时，会顺序对其他相邻块的数据文件进行预读取。<strong>涉及局部性原理</strong>。对于数据的<strong>顺序</strong>写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，读取性能几乎接近内存，CommitLog文件会有较多的<strong>随机访问</strong>，所以才应生出index用于加速查找。</p>
<h2 id="消息过滤-1"><a href="#消息过滤-1" class="headerlink" title="消息过滤"></a>消息过滤</h2><h3 id="Tag过滤方式"><a href="#Tag过滤方式" class="headerlink" title="Tag过滤方式"></a>Tag过滤方式</h3><p>Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash（后8字节）值去做过滤，由于在<strong>服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤</strong>，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p>
<p>思考：在服务端实现精准过滤会增加服务端压力，不过滤直接交给客户端又有网络传输浪费，hash过滤是中间的权衡。</p>
<h3 id="SQL92的过滤方式"><a href="#SQL92的过滤方式" class="headerlink" title="SQL92的过滤方式"></a>SQL92的过滤方式</h3><p>这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的 SQL expression 的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了<strong>BloomFilter</strong>避免了每次都去执行。SQL92的表达式上下文为消息的属性。</p>
<p>注：过滤相关类：org.apache.rocketmq.store.MessageFilter</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><p>发送端先通过topic找到对应路由信息：TopicPublishInfo，再调用selectOneMessageQueue()方法选择具体队列MessageQueue发送消息。</p>
<h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>负载均衡的核心—RebalanceImpl类的rebalanceByTopic方法。</p>
<p><strong>Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，</strong>而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。（org.apache.rocketmq.client.impl.consumer.RebalanceImpl#dispatchPullRequest）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">     <span class="comment">//广播模式</span></span><br><span class="line">    <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">          log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                   consumerGroup,</span><br><span class="line">                   topic,</span><br><span class="line">                   mqSet,</span><br><span class="line">                   mqSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">      <span class="comment">//获取该topic下的所有MessageQueue</span></span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="comment">//向Broker获取该消费组下消费者Id列表（通过org.apache.rocketmq.remoting.netty.NettyRemotingClient#invokeSync</span></span><br><span class="line">      <span class="comment">//发送rpc请求，Broker端基于Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</span></span><br><span class="line">      List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        mqAll.addAll(mqSet);</span><br><span class="line">				</span><br><span class="line">       	<span class="comment">//排序</span></span><br><span class="line">        Collections.sort(mqAll);</span><br><span class="line">        Collections.sort(cidAll);</span><br><span class="line">				<span class="comment">//消息队列分配策略算法（默认为：消息队列的平均分配算法AllocateMessageQueueAveragely），计算出待拉取的消息队列。</span></span><br><span class="line">        <span class="comment">// 这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，</span></span><br><span class="line">        <span class="comment">// 并求出每一页需要包含的平均size和每个页面记录的范围range，</span></span><br><span class="line">        <span class="comment">// 最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</span></span><br><span class="line">        AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(),</span><br><span class="line">                    e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">          allocateResultSet.addAll(allocateResult);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</span></span><br><span class="line">        <span class="comment">//该方法最后会执行dispatchPullRequest()方法，</span></span><br><span class="line">        <span class="comment">//push模式会将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。</span></span><br><span class="line">        <span class="comment">//pull模式为空实现</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          log.info(</span><br><span class="line">            <span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>,</span><br><span class="line">            strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">            allocateResultSet.size(), allocateResultSet);</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认分配策略:org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely#allocate</p>
<p><strong>同一组的消费者数量大于队列数，会有消费者无法消费到数据！注释说明</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="keyword">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="keyword">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="keyword">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;&quot;</span>,</span><br><span class="line">                consumerGroup,</span><br><span class="line">                currentCID,</span><br><span class="line">                cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line">        <span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line">  			<span class="comment">//计算消费队列数</span></span><br><span class="line">        <span class="keyword">int</span> averageSize =</span><br><span class="line">            mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">                + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">        <span class="comment">//开始索引，注意！！！若消费者队列数小于同一组的消费者数，并且索引大于mod(此时等于队列数)</span></span><br><span class="line">  			<span class="comment">//index * averageSize + mod 会 大于mqAll.size()，</span></span><br><span class="line">  			<span class="comment">//下面range会小于0，所以没有分配到队列，会无法消费到消息</span></span><br><span class="line">  			<span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;	</span><br><span class="line">        <span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">            result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡执行过程简要描述："><a href="#负载均衡执行过程简要描述：" class="headerlink" title="负载均衡执行过程简要描述："></a>负载均衡执行过程简要描述：</h3><p>RebalanceService线程run方法（默认20秒执行一次）最终会调用org.apache.rocketmq.client.impl.consumer.RebalanceImpl#rebalanceByTopic，在updateProcessQueueTableInRebalance方法中会为新分配的MessageQueue 会创建一个 PullRequest 对象，然后通过 dispatchPullRequest方法（pull模式为空实现）调用defaultMQPushConsumerImpl的executePullRequestImmediately方法 将 PullRequest放入到 PullMessageService 线程的 LinkedBlockingQueue, 进而唤醒 queue.take()方法，然后执行 DefaultMQPushConsumerImpl 的 pullMessage, 通过网络从broker端拉取消息，一次最多拉取的消息条数可配置，默认为32条，然后然后将拉取的消息，执行过滤等，然后封装成任务（ConsumeRequest）, 提交到消费者的线程池去执行，每次消费消息后，又将该 PullRequest 放入到 PullMessageService中，（DefaultMQPushConsumerImpl)的延迟的机制就是pullInterval 为 0；</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt="事务消息"></p>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></p>
<h2 id="主要目录简介"><a href="#主要目录简介" class="headerlink" title="主要目录简介"></a>主要目录简介</h2><ul>
<li>acl 权限模块</li>
<li>broker broker模块，核心任务就是持久化消息</li>
<li>client 消息客户端，包括生产与消费者</li>
<li>common 公共依赖包，通用的常量枚举、基类方法或者数据结构。</li>
<li>dev 开发者信息（就一个py文件）</li>
<li>distribution 部署脚本、配置模块</li>
<li>docs 开发者文档</li>
<li>example 示例模块</li>
<li>filter 消息过滤器</li>
<li>namesrv NameServer模块</li>
<li>openmessaging 消息开放标准</li>
<li>remoting 远程通信模块</li>
<li>serutil 服务工具类</li>
<li>store 消息存储模块</li>
</ul>
<h2 id="主要模块类功能分析"><a href="#主要模块类功能分析" class="headerlink" title="主要模块类功能分析"></a>主要模块类功能分析</h2><p>版本：4.9.1-SNAPSHOT</p>
<h3 id="namesrv模块"><a href="#namesrv模块" class="headerlink" title="namesrv模块"></a>namesrv模块</h3><p>NamesrvStartup：启动类，主要是调用NamesrvController的初始化及开始方法。</p>
<p>NamesrvController：核心控制类。</p>
<p>核心初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">  <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化负责处理Netty网络交互数据的线程池，</span></span><br><span class="line">  <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">    Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册负责处理Netty网络交互数据的DefaultRequestProcessor，客户端请求会由这个Processor来处理</span></span><br><span class="line">  <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">  <span class="comment">//        每10s扫描存活的Broker</span></span><br><span class="line">  <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//通过比较最近心跳时间距今时间是否超过两分钟决定</span></span><br><span class="line">      NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">  <span class="comment">//         每10分钟打印kv配置</span></span><br><span class="line">  <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">  <span class="comment">//注册tls文件变更的监听器</span></span><br><span class="line">  <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">    <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fileWatchService = <span class="keyword">new</span> FileWatchService(</span><br><span class="line">        <span class="keyword">new</span> String[] &#123;</span><br><span class="line">          TlsSystemConfig.tlsServerCertPath,</span><br><span class="line">          TlsSystemConfig.tlsServerKeyPath,</span><br><span class="line">          TlsSystemConfig.tlsServerTrustCertPath</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">          <span class="keyword">boolean</span> certChanged, keyChanged = <span class="keyword">false</span>;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) &#123;</span><br><span class="line">              log.info(<span class="string">&quot;The trust certificate changed, reload the ssl context&quot;</span>);</span><br><span class="line">              reloadServerSslContext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerCertPath)) &#123;</span><br><span class="line">              certChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerKeyPath)) &#123;</span><br><span class="line">              keyChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (certChanged &amp;&amp; keyChanged) &#123;</span><br><span class="line">              log.info(<span class="string">&quot;The certificate and private key changed, reload the ssl context&quot;</span>);</span><br><span class="line">              certChanged = keyChanged = <span class="keyword">false</span>;</span><br><span class="line">              reloadServerSslContext();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reloadServerSslContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ((NettyRemotingServer) remotingServer).loadSslContext();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;FileWatchService created error, can&#x27;t load the certificate dynamically&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    NamesrvConfig：NameServer相关属性配置类，如配置文件路径。</p>
<p>​    NettyServerConfig、RemotingServer 、ExecutorService：网络通讯类与Netty密切相关，相关配置如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NettyServerConfig默认字段配置</span></span><br><span class="line"><span class="comment">//NamesrvStartup#createNamesrvController将该值设置为9876</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//单向请求的信号量（并发度），一般用在发送心跳包场景下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>; </span><br><span class="line"><span class="comment">//异步调用的信号量（并发度）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 通道空闲时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</span><br></pre></td></tr></table></figure>

<p>KVConfigManager ：读取或变更NameServer的配置属性，load方法加载 NamesrvConfig 中配置的配置文件到内存。</p>
<p>请求处理核心逻辑：org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor#processRequest</p>
<p>RouteInfoManager : 用HashMap保存/管理Broker、Topic等信息。内部使用ReadWriteLock保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空闲时长，超过两分钟没收到Broker的心跳包则，断开连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> BROKER_CHANNEL_EXPIRED_TIME = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"><span class="comment">//路由信息保存在org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager的以下字段里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//主题与队列关系，记录分布在哪些Broker上，Broker上存在该主题的队列个数,QueueData队列描述信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="comment">//BrokerData信息描述每一个 broker信息（所属集群，broker名，还有以brokerId为key地址为value的map集合）（broker主从集合）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">//集群包含的brokerName</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="comment">//当前存活的broker，NameServer10秒扫描一次，非实时有误差</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="comment">//过滤服务列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure>

<p>BrokerHousekeepingService：实现ChannelEventListener接口，处理与Broker连接通道关闭，异常，空闲的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelClose</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelException</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelIdle</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileWatchService : 监控tls文件的改动。使用MessageDigest类，用MD5加密算法提取概要信息存ArrayList集合fileCurrentHash里,WATCH_INTERVAL = <strong>500毫秒</strong>查询校验一次。（为啥频率这么高？？？）</p>
<h3 id="broker模块"><a href="#broker模块" class="headerlink" title="broker模块"></a><strong>broker模块</strong></h3><p>broker也有与namesrv一样相应的BrokerStartup与BrokerController作用类似。</p>
<p>消息执行器：org.apache.rocketmq.broker.processor.SendMessageProcessor。</p>
<p><strong>存储配置类</strong>：org.apache.rocketmq.store.config.MessageStoreConfig，部分配置字段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置Broker的存储根目录，默认为 $Broker_Home/store。</span></span><br><span class="line"><span class="keyword">private</span> String storePathRootDir = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;store&quot;</span>;</span><br><span class="line"><span class="comment">//设置commitlog的存储目录，默认为$Broker_Home/store/commitlog。</span></span><br><span class="line"><span class="keyword">private</span> String storePathCommitLog = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;store&quot;</span></span><br><span class="line">  + File.separator + <span class="string">&quot;commitlog&quot;</span>;</span><br><span class="line"><span class="comment">// CommitLog文件大小默认 1G</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mappedFileSizeCommitLog = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// ConsumeQueue 存放的是定长的信息（20个字节，偏移量、size、tagscode） 默认是 30W * 20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mappedFileSizeConsumeQueue = <span class="number">300000</span> * ConsumeQueue.CQ_STORE_UNIT_SIZE;</span><br><span class="line"><span class="comment">// 是否开启 consumeQueueExt,默认为 false,就是如果消费端消息消费速度跟不上，是否创建一个扩展的 ConsumeQueue文件，如果不开启，应该会阻塞从 commitlog 文件中获取消息。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableConsumeQueueExt = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 扩展consume文件的大小，默认为48M。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mappedFileSizeConsumeQueueExt = <span class="number">48</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// Bit count of filter bit map.</span></span><br><span class="line"><span class="comment">// this will be set by pipe of calculate filter bit map.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> bitMapLengthConsumeQueueExt = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷写 CommitLog 的间隔时间，RocketMQ 后台会启动一个线程，将消息刷写到磁盘，</span></span><br><span class="line"><span class="comment">// 这个也就是该线程每次运行后等待的时间，默认为500毫秒。flush 操作，调用文件通道的force()方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flushIntervalCommitLog = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//提交消息到 CommitLog 对应的文件通道的间隔时间，原理与上面类似；</span></span><br><span class="line"><span class="comment">// 将消息写入到文件通道（调用FileChannel.write方法）得到最新的写指针，默认为200毫秒。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> commitIntervalCommitLog = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p><strong>存储核心类</strong>：DefaultMessageStore,存储消息的入口方法为：putMessage，核心步骤如下：</p>
<ol>
<li><p>检查状态：checkStoreStatus() </p>
<ol>
<li>检查当前节点是否已shutdown。</li>
<li>是否是SLAVE节点（SLAVE只读）。</li>
<li>是否可写。</li>
<li>操作系统页写入是否繁忙：isOSPageCacheBusy()。</li>
</ol>
</li>
<li><p>检查消息checkMessage(msg)：检查topic与propertiesString长度。</p>
</li>
<li><p>将日志写入CommitLog 文件：this.commitLog.putMessage(msg)。</p>
</li>
<li><p>统计写入耗时信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);</span><br></pre></td></tr></table></figure>
</li>
<li><p>记录写commitlog 失败次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>消息写入</strong>：org.apache.rocketmq.store.CommitLog#putMessage，核心步骤如下：</p>
<ol>
<li><p>获取消息类型（事务消息，非事务消息，Commit消息。</p>
</li>
<li><p>获取一个 MappedFile 对象，内存映射的具体实现。</p>
</li>
<li><p>追加消息需要加锁PutMessageLock(两种实现PutMessageReentrantLock（内部就个ReentrantLock）和PutMessageSpinLock（默认）（内部含有AtomicBoolean，使用do-while，cas加锁）。</p>
</li>
<li><p>验证 MappedFile 对象，获取一个可用的 MappedFile (如果没有，则创建一个)。</p>
</li>
<li><p>通过MappedFile对象写入文件。result = mappedFile.appendMessage(msg, this.appendMessageCallback);</p>
</li>
<li><p>根据刷盘策略刷盘：handleDiskFlush(result, putMessageResult, msg);</p>
</li>
<li><p>主从同步：handleHA(result, putMessageResult, msg);</p>
</li>
</ol>
<p>**消息长度计算: **org.apache.rocketmq.store.CommitLog#calMsgLength</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMsgLength</span><span class="params">(<span class="keyword">int</span> sysFlag, <span class="keyword">int</span> bodyLength, <span class="keyword">int</span> topicLength, <span class="keyword">int</span> propertiesLength)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bornhostLength = (sysFlag &amp; MessageSysFlag.BORNHOST_V6_FLAG) == <span class="number">0</span> ? <span class="number">8</span> : <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> storehostAddressLength = (sysFlag &amp; MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == <span class="number">0</span> ? <span class="number">8</span> : <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//单位：字节</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = <span class="number">4</span> <span class="comment">//TOTALSIZE 消息总长度</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//MAGICCODE   模数</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//BODYCRC     数据校验CR</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//QUEUEID     消息队列id</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//FLAG        标记位</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//QUEUEOFFSET 消息队列偏移量</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET 物理偏移量</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//SYSFLAG      系统标记</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP  bornt存储时间戳</span></span><br><span class="line">      + bornhostLength <span class="comment">//BORNHOST  Broken地址、端口</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//STORETIMESTAMP 时间戳</span></span><br><span class="line">      + storehostAddressLength <span class="comment">//STOREHOSTADDRESS  存储地址端口</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//RECONSUMETIMES 消息重试次数</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset </span></span><br><span class="line">      + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY 4字节的body长度+具体消息长度</span></span><br><span class="line">      + <span class="number">1</span> + topicLength <span class="comment">//TOPIC 一字节的topic长度与topic内容长度</span></span><br><span class="line">      + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength 消息属性长度</span></span><br><span class="line">      + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> msgLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全局唯一msgId</strong>生成代码位置：org.apache.rocketmq.common.message.MessageDecoder#createMessageId(java.nio.ByteBuffer, java.nio.ByteBuffer, long) <strong>由ip+port+commitLog偏移地址组成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createMessageId</span><span class="params">(<span class="keyword">final</span> ByteBuffer input, <span class="keyword">final</span> ByteBuffer addr, <span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">  input.flip();</span><br><span class="line">  <span class="keyword">int</span> msgIDLength = addr.limit() == <span class="number">8</span> ? <span class="number">16</span> : <span class="number">28</span>;</span><br><span class="line">  input.limit(msgIDLength);</span><br><span class="line"></span><br><span class="line">  input.put(addr);</span><br><span class="line">  input.putLong(offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> UtilAll.bytes2string(input.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**消息刷盘 **:  org.apache.rocketmq.store.CommitLog#handleDiskFlush</p>
<p>具体刷盘org.apache.rocketmq.store.MappedFile#flush：就是调用 FileChannel 或 MappedByteBuffer 的force 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同步刷写</span></span><br><span class="line">  <span class="comment">// Synchronization flush</span></span><br><span class="line">  <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">    <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line">    <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123; <span class="comment">//是否一定要收到存储MSG信息，才返回，默认为true。如果要等待存储结果。</span></span><br><span class="line">      GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">      service.putRequest(request);</span><br><span class="line">      CompletableFuture&lt;PutMessageStatus&gt; flushOkFuture = request.future();</span><br><span class="line">      PutMessageStatus flushStatus = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        flushStatus = flushOkFuture.get(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">//flushOK=false;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;do groupcommit, wait for flush failed, topic: &quot;</span> + messageExt.getTopic() + <span class="string">&quot; tags: &quot;</span> + messageExt.getTags()</span><br><span class="line">                  + <span class="string">&quot; client address: &quot;</span> + messageExt.getBornHostString());</span><br><span class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      service.wakeup(); <span class="comment">//唤醒同步刷盘线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Asynchronous flush //异步刷盘机制</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">      flushCommitLogService.wakeup();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      commitLogService.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>消息存储过程</strong></p>
<p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RocketMQ%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="client模块"><a href="#client模块" class="headerlink" title="client模块"></a>client模块</h3><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>默认发送方法org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendDefaultImpl</p>
<h4 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h4><ol>
<li><p>消息（group、topic、body等）校验：Validators.checkMessage(msg, this.defaultMQProducer);</p>
</li>
<li><p>获取topic的路由信息：TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</p>
</li>
<li><p>根据topic负载均衡算法选择一个MessageQueue。可实现MessageQueueSelector自定义。</p>
<p>默认org.apache.rocketmq.client.latency.MQFaultStrategy#selectOneMessageQueue方法有ThreadLocalIndex sendWhichQueue保存上次发送队列下标，使用轮询获取发送队列下标，对开启失败延迟的话还会对队列进行判断验证。</p>
</li>
<li><p>向 MessageQueue 发送消息。</p>
</li>
<li><p>更新失败策略,主要用于规避发生故障的 broker。</p>
</li>
<li><p>如果是同步调用方式(SYNC),则执行失败重试策略，默认重试两次, 异步消息发送的重试是在回调时。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? </span><br><span class="line">  <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="延迟类MQFaultStrategy"><a href="#延迟类MQFaultStrategy" class="headerlink" title="延迟类MQFaultStrategy"></a>延迟类MQFaultStrategy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//latencyMax：最大延迟时间数值，在消息发送之前，先记录当前时间（start），然后消息发送成功或失败时记录当前时间（end），(end-start)代表一次消息延迟时间，发送错误时</span></span><br><span class="line"><span class="comment">//对之前失败的，按一定的时间做退避，下面通过索引相对应，如上次请求的latency超过550Lms，就退避3000Lms；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="校验配置类"><a href="#校验配置类" class="headerlink" title="校验配置类"></a>校验配置类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validators</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALID_PATTERN_STR = <span class="string">&quot;^[%|a-zA-Z0-9_-]+$&quot;</span>;</span><br><span class="line">  	<span class="comment">//分组与topic的命名符号限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN = Pattern.compile(VALID_PATTERN_STR);</span><br><span class="line">    <span class="comment">//group长度限制</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHARACTER_MAX_LENGTH = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">//topic长度限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOPIC_MAX_LENGTH = <span class="number">127</span>;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他限制：默认超时时间3s（org.apache.rocketmq.client.producer.DefaultMQProducer#sendMsgTimeout），消息body最大4M（org.apache.rocketmq.client.producer.DefaultMQProducer#maxMessageSize）。</p>
<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><h4 id="主要类简介："><a href="#主要类简介：" class="headerlink" title="主要类简介："></a><strong>主要类简介</strong>：</h4><p>DefaultMQPushConsumerImpl ：消息消息者默认实现类，应用程序中直接用该类的实例完成消息的消费，并回调业务方法。</p>
<p>RebalanceImpl 消费端消费者与消息队列的重新分布。</p>
<p>MQClientInstance 消息客户端实例，负载与MQ服务器（Broker,Nameserver)交互的网络实现。</p>
<p>NettyRemotingClient ：管理连接ChannelWrapper（channel的包装类）</p>
<p>PullAPIWrapper pull与Push在RocketMQ中，其实就只有Pull模式，所以Push其实就是用pull封装一下。</p>
<p>MessageListenerInner 消费消费回调类，当消息分配给消费者消费时，执行的业务代码入口。</p>
<p>OffsetStore 消息消费进度保存。</p>
<p>ConsumeMessageService 消息消费逻辑。</p>
<h4 id="核心类关系梳理"><a href="#核心类关系梳理" class="headerlink" title="核心类关系梳理"></a>核心类关系梳理</h4><p><span style="color:red;">一个客户端对应一个MQClientInstance</span>，在org.apache.rocketmq.client.impl.MQClientManager#factoryTable维持关系，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConcurrentMap&lt;String<span class="comment">/* clientId */</span>, MQClientInstance&gt; factoryTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, MQClientInstance&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端id生成规则</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.ClientConfig#buildMQClientId</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buildMQClientId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="keyword">this</span>.getClientIP());</span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">    <span class="comment">//private String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;);</span></span><br><span class="line">  	sb.append(<span class="keyword">this</span>.getInstanceName()); </span><br><span class="line">    <span class="keyword">if</span> (!UtilAll.isBlank(<span class="keyword">this</span>.unitName)) &#123;</span><br><span class="line">      sb.append(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">      sb.append(<span class="keyword">this</span>.unitName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red;">一个应用程序（消费端）同一个IP:端口，一个消费组对应一个DefaultMQPushConsumerImpl，DefaultMQPushConsumerImpl持有有一个MQClientInstance(从MQClientManage获取)，一个MQClientInstance中持有一个PullMessageServive实例。</span></p>
<p><span style="color:red;">结论：同一个应用程序中，如果存在多个消费组，那么就有多个DefaultMQPushConsumerImpl ，所有相同clientId的DefaultMQPushConsumerImpl 都需要依靠同一个PullMessageServive拉取消息。</span></p>
<h4 id="启动核心："><a href="#启动核心：" class="headerlink" title="启动核心："></a><strong>启动核心</strong>：</h4><p>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#start</p>
<p><strong>核心步骤如下：</strong></p>
<ol>
<li><p>checkConfig,检查配置信息，主要检查消费者组（consumeGroup）、消息消费方式（messageModel）、消息消费开始偏移量（consumeFromWhere）、消息队列分配算法（AllocateMessageQueueStrategy）、订阅消息主题（Map&lt;String /* topic */, String /* sub expression */&gt; subscription）, 消息回调监听器(MessageListener)等。</p>
</li>
<li><p>copySubscription 加工订阅信息，将 Map&lt;String /* topic*/, String／＊ｓｕｂｅｘｔｅｎｄｓ＊／＞转换为Map&lt;String,SubscriptionData&gt;,如果messageListenerInner为空，则设置为defaultMQPushConsumer的MessageListener</p>
<p>同时，如果消息消费模式为集群模式，还需要为该消费组对应一个重试主题。</p>
</li>
<li><p>如果消息消费模式为集群模式，并且当前的实例名为 DEFAULT，替换为当前客户端进程的PID + “#” + System.nanoTime()。</p>
</li>
<li><p>负载均衡相关实现。rebalanceImpl</p>
</li>
<li><p>创建pullAPIWrapper，消息拉取API封装类。</p>
</li>
<li><p>消费进度存储，如果是集群模式，使用远程存储 RemoteBrokerOffsetStore，如果是广播模式，则使用本地存储LocalFileOffsetStore，后文重点关注。</p>
</li>
<li><p>加载消息消费进度。</p>
</li>
<li><p>消息消费服务并启动。this.consumeMessageService.start();</p>
</li>
<li><p>向远程 Broker 服务器注册消费者。</p>
</li>
<li><p>更新订阅信息。this.updateTopicSubscribeInfoWhenSubscriptionChanged();</p>
</li>
<li><p>检测broker状态。this.mQClientFactory.checkClientInBroker();</p>
</li>
<li><p>发送心跳包。this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</p>
</li>
<li><p>重新负载。this.mQClientFactory.rebalanceImmediately();</p>
<p>最终调用org.apache.rocketmq.client.impl.consumer.RebalanceImpl#doRebalance</p>
</li>
</ol>
<h4 id="客户端定时任务"><a href="#客户端定时任务" class="headerlink" title="客户端定时任务"></a>客户端定时任务</h4><p>org.apache.rocketmq.client.impl.factory.MQClientInstance#startScheduledTask</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//每2分钟获取NameServer地址，内部使用http的get请求获取默认3秒超时</span></span><br><span class="line">                        MQClientInstance.<span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;ScheduledTask fetchNameServerAddr exception&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//每30秒更新topic信息</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每30S 进行Broker心跳检测</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.cleanOfflineBroker();</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask sendHeartbeatToAllBroker exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//默认每隔5秒持久化ConsumeOffset</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask persistAllConsumerOffset exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	 <span class="comment">//每分钟调整一次线程</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask adjustThreadPool exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息拉取服务-org-apache-rocketmq-client-impl-consumer-PullMessageService"><a href="#消息拉取服务-org-apache-rocketmq-client-impl-consumer-PullMessageService" class="headerlink" title="消息拉取服务 org.apache.rocketmq.client.impl.consumer.PullMessageService"></a>消息拉取服务 org.apache.rocketmq.client.impl.consumer.PullMessageService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从LinkedBlockingQueue&lt;PullRequest&gt;中获取request拉取消息</span></span><br><span class="line">        PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">        <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Pull Message Service Run Method exception&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        <span class="comment">//调用的是DefaultMQPushConsumerImpl的pullMessage</span></span><br><span class="line">        impl.pullMessage(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	log.warn(<span class="string">&quot;No matched consumer for the PullRequest &#123;&#125;, drop it&quot;</span>, pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正拉取消息：</p>
<p>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#pullMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">  <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;the pull request[&#123;&#125;] is dropped.&quot;</span>, pullRequest.toString());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//检查当前状态是否running</span></span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;pullMessage exception, consumer state not ok&quot;</span>, e);</span><br><span class="line">    <span class="comment">//延后3秒再执行，其实就是延后3秒后再把pullRequest放入org.apache.rocketmq.client.impl.consumer.PullMessageService.pullRequestQueue队列里</span></span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暂停状态延后1秒</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;&quot;</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//流量控制</span></span><br><span class="line">  <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">  <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">  <span class="comment">//缓存消息数量大于1000</span></span><br><span class="line">  <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">    <span class="comment">//延后50毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      log.warn(</span><br><span class="line">        <span class="string">&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//缓存消息大小超过100MB</span></span><br><span class="line">  <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">    <span class="comment">//延后50毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      log.warn(</span><br><span class="line">        <span class="string">&quot;the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123; <span class="comment">//非顺序消息</span></span><br><span class="line">    <span class="comment">//消费队列所存范围lastqueueOffset-firstqueueOffset &gt; 2000</span></span><br><span class="line">    <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">      <span class="comment">//延后50毫秒</span></span><br><span class="line">      <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">      <span class="keyword">if</span> ((queueMaxSpanFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">          <span class="string">&quot;the queue&#x27;s messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">          processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line">          pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (processQueue.isLocked()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pullRequest.isPreviouslyLocked()) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = -<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          offset = <span class="keyword">this</span>.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">          log.error(<span class="string">&quot;Failed to compute pull offset, pullResult: &#123;&#125;&quot;</span>, pullRequest, e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> brokerBusy = offset &lt; pullRequest.getNextOffset();</span><br><span class="line">        log.info(<span class="string">&quot;the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;&quot;</span>,</span><br><span class="line">                 pullRequest, offset, brokerBusy);</span><br><span class="line">        <span class="keyword">if</span> (brokerBusy) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                   pullRequest, offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pullRequest.setPreviouslyLocked(<span class="keyword">true</span>);</span><br><span class="line">        pullRequest.setNextOffset(offset);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">      log.info(<span class="string">&quot;pull message later because not locked in broker, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过topic获取订阅信息</span></span><br><span class="line">  <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    log.warn(<span class="string">&quot;find the consumer&#x27;s subscription failed, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//拉取消息回调</span></span><br><span class="line">  PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//对消息体解码成并执行消息过滤</span></span><br><span class="line">        pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                                                                                     subscriptionData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">          <span class="keyword">case</span> FOUND:</span><br><span class="line">            <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">            <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                                                                               pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                                                                  pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">              <span class="comment">//将拉取到的消息放入消费队列中：就是将拉取的消息，放入到ProcessQueue的msgTreeMap容器中。</span></span><br><span class="line">              <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">              <span class="comment">//消费消息服务提交，提交消息会被ConsumeRequest包装提交到消费端消费线程池消费</span></span><br><span class="line">              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                pullResult.getMsgFoundList(),</span><br><span class="line">                processQueue,</span><br><span class="line">                pullRequest.getMessageQueue(),</span><br><span class="line">                dispatchToConsume);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                                                       DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">              log.warn(</span><br><span class="line">                <span class="string">&quot;[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                pullResult.getNextBeginOffset(),</span><br><span class="line">                firstMsgOffset,</span><br><span class="line">                prevRequestOffset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">          <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">            log.warn(<span class="string">&quot;the pull request offset illegal, &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                     pullRequest.toString(), pullResult.toString());</span><br><span class="line">            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">            pullRequest.getProcessQueue().setDropped(<span class="keyword">true</span>);</span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executeTaskLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span><br><span class="line">                                                                          pullRequest.getNextOffset(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                  log.warn(<span class="string">&quot;fix the pull request offset, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.error(<span class="string">&quot;executeTaskLater Exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;execute the pull request exception&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> commitOffsetEnable = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">long</span> commitOffsetValue = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">if</span> (MessageModel.CLUSTERING == <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">    <span class="comment">//如果是集群消费模式，从内存中获取MessageQueue的commitlog偏移量。</span></span><br><span class="line">    commitOffsetValue = <span class="keyword">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">    <span class="keyword">if</span> (commitOffsetValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      commitOffsetEnable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String subExpression = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> classFilter = <span class="keyword">false</span>;</span><br><span class="line">  SubscriptionData sd = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">  <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</span><br><span class="line">      subExpression = sd.getSubString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classFilter = sd.isClassFilterMode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构建拉取消息系统Flag: 是否支持comitOffset,suspend,subExpression,classFilter</span></span><br><span class="line">  <span class="keyword">int</span> sysFlag = PullSysFlag.buildSysFlag(</span><br><span class="line">    commitOffsetEnable, <span class="comment">// commitOffset</span></span><br><span class="line">    <span class="keyword">true</span>, <span class="comment">// suspend</span></span><br><span class="line">    subExpression != <span class="keyword">null</span>, <span class="comment">// subscription</span></span><br><span class="line">    classFilter <span class="comment">// class filter</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//消息拉取核心api执行</span></span><br><span class="line">    <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">      pullRequest.getMessageQueue(), <span class="comment">//消息消费队列</span></span><br><span class="line">      subExpression, <span class="comment">//tag过滤表达式</span></span><br><span class="line">      subscriptionData.getExpressionType(), <span class="comment">//tag</span></span><br><span class="line">      subscriptionData.getSubVersion(), <span class="comment">//版本其实就是时间戳</span></span><br><span class="line">      pullRequest.getNextOffset(),</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(), <span class="comment">//批量拉取大小，32</span></span><br><span class="line">      sysFlag, <span class="comment">// 系统标记</span></span><br><span class="line">      commitOffsetValue,<span class="comment">//当前消息队列的MessageQueue的commitlog偏移量</span></span><br><span class="line">      BROKER_SUSPEND_MAX_TIME_MILLIS, <span class="comment">//允许broker暂停时间，15s</span></span><br><span class="line">      CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, <span class="comment">//超时时间，30s</span></span><br><span class="line">      CommunicationMode.ASYNC, <span class="comment">// 异步</span></span><br><span class="line">      pullCallback <span class="comment">//pull消息回调</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;pullKernelImpl exception&quot;</span>, e);</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消费端消费线程池"><a href="#消费端消费线程池" class="headerlink" title="消费端消费线程池"></a>消费端消费线程池</h4><p>非顺序：org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#consumeExecutor</p>
<p>顺序：org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService#consumeExecutor</p>
<h4 id="消费任务类"><a href="#消费任务类" class="headerlink" title="消费任务类:"></a>消费任务类:</h4><p>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.ConsumeRequest</p>
<p>org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService.ConsumeRequest</p>
<p><strong>ConsumeRequest的run方法会调用我们注册的自定义consumeMessage方法。</strong></p>
<h4 id="顺序消费实现原理"><a href="#顺序消费实现原理" class="headerlink" title="顺序消费实现原理"></a>顺序消费实现原理</h4><p>ConsumeMessageOrderlyService.ConsumeRequest的run方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;run, the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//以消息队列为粒度获取锁对象，也就是说同一时间每个消费队列只能由一个线程执行，保证同一消费队列消息的有序性</span></span><br><span class="line">  <span class="comment">//如果要使用全局顺序消费，那么对应主题只能允许存在一个队列（不建议使用！！！无法发挥多线程优势，并发处理能力降低）</span></span><br><span class="line">  <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">  <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">   			<span class="comment">//……</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MessageQueueLock内部就个map存储消息队列与锁对象关系。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, Object&gt; mqLockTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;MessageQueue, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fetchLockObject</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        Object objLock = <span class="keyword">this</span>.mqLockTable.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == objLock) &#123;</span><br><span class="line">            objLock = <span class="keyword">new</span> Object();</span><br><span class="line">            Object prevLock = <span class="keyword">this</span>.mqLockTable.putIfAbsent(mq, objLock);</span><br><span class="line">            <span class="keyword">if</span> (prevLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                objLock = prevLock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> objLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消费重试核心"><a href="#消费重试核心" class="headerlink" title="消费重试核心"></a>消费重试核心</h4><p>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#processConsumeResult</p>
<p>根据消费结果，设置ackIndex 的值，成功：ackIndex = consumeRequest.getMsgs().size() - 1; 失败：ackIndex = -1<br>如果是消费失败，根据消费模式（集群消费还是广播消费），广播模式，就遍历打印日志，集群模式调用 sendMessageBack。<br>发送成功，重试机制由 broker 处理。发送发失败的，客户端会进行重试：调用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">    consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">    <span class="comment">//重新提交发送消费失败的延后5s消费</span></span><br><span class="line">    <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), 					             consumeRequest.getMessageQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageBack</strong>：发送的RequestCode为CONSUMER_SEND_MSG_BACK=36</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap topic with namespace before sending back message.</span></span><br><span class="line">    msg.setTopic(<span class="keyword">this</span>.defaultMQPushConsumer.withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;sendMessageBack exception, group: &quot;</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">&quot; msg: &quot;</span> + msg.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>broker处理核心代码位置：org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncConsumerSendMsgBack</p>
<p>延迟级别设置：<strong>如果消息的延迟级别为0,则 3 + 消息重试的次数。即第一次重试的延时时间为10s</strong>,如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes （=<span class="number">16</span>）</span><br><span class="line">      || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果消息次数超过最大限制或延迟级别小于0，设置消息的主题为 DLQ（死信队列） + 消费组名称</span></span><br><span class="line"></span><br><span class="line">    newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">    queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">    topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">                                                                                                   DLQ_NUMS_PER_GROUP,</span><br><span class="line">                                                                                                   PermName.PERM_WRITE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">      response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">      response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> CompletableFuture.completedFuture(response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">      <span class="comment">//如果消息的延迟级别为0,则 3 + 消息重试的次数。即第一次重试的延时时间为10s</span></span><br><span class="line">      delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">    &#125;</span><br><span class="line">    msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：对于需要延迟执行的消息，在存入 commitlog 之前，会将主题修改为SCHEDULE_TOPIC_XXXX，会被延迟任务 ScheduleMessageService 延迟拉取。ScheduleMessageService 在执行过程中，会再次存入 commitlog 文件中放入之前，会清空延迟等级，并恢复主题与队列，这样，就能被消费者所消费，因为消费者在启动时就订阅了该消费组的重试主题（org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#copySubscription）</p>
<p><strong>延迟等级与时间关系加载</strong>：org.apache.rocketmq.store.schedule.ScheduleMessageService#parseDelayLevel </p>
<h3 id="集群模式消费者offset偏移量维护"><a href="#集群模式消费者offset偏移量维护" class="headerlink" title="集群模式消费者offset偏移量维护"></a>集群模式消费者offset偏移量维护</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//treemap保存当前还在处理队列中的消息</span></span><br><span class="line"><span class="comment">//移除已经处理的批处理消息：org.apache.rocketmq.client.impl.consumer.ProcessQueue#removeMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.treeMapLock.writeLock().lockInterruptibly();</span><br><span class="line">      <span class="keyword">this</span>.lastConsumeTimestamp = now;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//该处理队列最大的偏移量+1</span></span><br><span class="line">          result = <span class="keyword">this</span>.queueOffsetMax + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> removedCnt = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">              removedCnt--;</span><br><span class="line">              msgSize.addAndGet(<span class="number">0</span> - msg.getBody().length);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          msgCount.addAndGet(removedCnt);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//还有消息在处理队列中，返回处理队列中最小的偏移量，优点：防止消息丢失（也就是没有消费到）缺点：会造成消息重复消费。</span></span><br><span class="line">            result = msgTreeMap.firstKey();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.treeMapLock.writeLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;removeMessage exception&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/prestigeding/article/details/78888290?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162601099216780274159744%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162601099216780274159744&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-10-78888290.first_rank_v2_pc_rank_v29&utm_term=rocketmq%E6%BA%90%E7%A0%81&spm=1018.2226.3001.4187">源码分析RocketMQ</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
</search>
