<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>RocketMQ深入学习 | 菜鸟明De博客</title><meta name="description" content="简介RocketMQ是一款分布式、队列模型的消息中间件。基于发布订阅模式，有Push和Pull两种消费方式，支持严格的消息顺序，亿级别的堆积能力，支持消息回溯和多个维度的消息查询。 RocketMQ官方文档 架构设计 主要组成成分 NameServer：简单的注册中心，用户broker（主机）的动态注册与发现。保存Broker集群的注册信息（路由信息），并有心跳机制(每10s一次检测Broker是"><meta name="keywords" content="消息中间件"><meta name="author" content="CZM,2723081630@qq.com"><meta name="copyright" content="CZM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://czmderepository.gitee.io/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="RocketMQ深入学习"><meta property="og:url" content="https://czmderepository.gitee.io/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="菜鸟明De博客"><meta property="og:description" content="简介RocketMQ是一款分布式、队列模型的消息中间件。基于发布订阅模式，有Push和Pull两种消费方式，支持严格的消息顺序，亿级别的堆积能力，支持消息回溯和多个维度的消息查询。 RocketMQ官方文档 架构设计 主要组成成分 NameServer：简单的注册中心，用户broker（主机）的动态注册与发现。保存Broker集群的注册信息（路由信息），并有心跳机制(每10s一次检测Broker是"><meta property="og:image" content="https://s3.ax1x.com/2020/12/01/D4plnJ.jpg"><meta property="article:published_time" content="2021-07-26T12:32:13.000Z"><meta property="article:modified_time" content="2021-11-14T16:36:36.000Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: {"text":"小帅哥,爱你,过浪险,欢迎您,过压贴,光临本园,加油,努力,酷炫低调奢华,拼搏,forever,爱你","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-11-15 00:36:36'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/09/17/wRG4fS.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">57</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E6%88%90%E5%88%86"><span class="toc-number">2.1.</span> <span class="toc-text">主要组成成分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">其他重要概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">3.1.</span> <span class="toc-text">顺序消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">消息过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">3.3.</span> <span class="toc-text">定时消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">4.</span> <span class="toc-text">消息存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">数据存取优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.2.</span> <span class="toc-text">页缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4-1"><span class="toc-number">5.</span> <span class="toc-text">消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tag%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">Tag过滤方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL92%E7%9A%84%E8%BF%87%E6%BB%A4%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">SQL92的过滤方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">6.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#producer"><span class="toc-number">6.1.</span> <span class="toc-text">producer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer"><span class="toc-number">6.2.</span> <span class="toc-text">consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">负载均衡执行过程简要描述：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">7.</span> <span class="toc-text">事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%9C%B0%E5%9D%80"><span class="toc-number">8.</span> <span class="toc-text">源码地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B"><span class="toc-number">9.</span> <span class="toc-text">主要目录简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">主要模块类功能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#namesrv%E6%A8%A1%E5%9D%97"><span class="toc-number">10.1.</span> <span class="toc-text">namesrv模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#broker%E6%A8%A1%E5%9D%97"><span class="toc-number">10.2.</span> <span class="toc-text">broker模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#client%E6%A8%A1%E5%9D%97"><span class="toc-number">10.3.</span> <span class="toc-text">client模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">10.4.</span> <span class="toc-text">发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.4.1.</span> <span class="toc-text">核心步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%B1%BBMQFaultStrategy"><span class="toc-number">10.4.2.</span> <span class="toc-text">延迟类MQFaultStrategy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">10.4.3.</span> <span class="toc-text">校验配置类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">10.5.</span> <span class="toc-text">消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">10.5.1.</span> <span class="toc-text">主要类简介：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86"><span class="toc-number">10.5.2.</span> <span class="toc-text">核心类关系梳理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%A0%B8%E5%BF%83%EF%BC%9A"><span class="toc-number">10.5.3.</span> <span class="toc-text">启动核心：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.5.4.</span> <span class="toc-text">客户端定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E6%9C%8D%E5%8A%A1-org-apache-rocketmq-client-impl-consumer-PullMessageService"><span class="toc-number">10.5.5.</span> <span class="toc-text">消息拉取服务 org.apache.rocketmq.client.impl.consumer.PullMessageService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E6%B6%88%E8%B4%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.5.6.</span> <span class="toc-text">消费端消费线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E4%BB%BB%E5%8A%A1%E7%B1%BB"><span class="toc-number">10.5.7.</span> <span class="toc-text">消费任务类:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.5.8.</span> <span class="toc-text">顺序消费实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%A0%B8%E5%BF%83"><span class="toc-number">10.5.9.</span> <span class="toc-text">消费重试核心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%B6%88%E8%B4%B9%E8%80%85offset%E5%81%8F%E7%A7%BB%E9%87%8F%E7%BB%B4%E6%8A%A4"><span class="toc-number">10.6.</span> <span class="toc-text">集群模式消费者offset偏移量维护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">11.</span> <span class="toc-text">参考链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#END"><span class="toc-number">12.</span> <span class="toc-text">END</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://s3.ax1x.com/2020/12/01/D4plnJ.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">菜鸟明De博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">RocketMQ深入学习</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-26T12:32:13.000Z" title="发表于 2021-07-26 20:32:13">2021-07-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-14T16:36:36.000Z" title="更新于 2021-11-15 00:36:36">2021-11-15</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RocketMQ是一款分布式、队列模型的消息中间件。基于发布订阅模式，有Push和Pull两种消费方式，支持严格的消息顺序，亿级别的堆积能力，支持消息回溯和多个维度的消息查询。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/tree/master/docs/cn">RocketMQ官方文档</a></p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png" alt="架构设计"></p>
<h3 id="主要组成成分"><a href="#主要组成成分" class="headerlink" title="主要组成成分"></a>主要组成成分</h3><ul>
<li><p>NameServer：简单的注册中心，用户broker（主机）的动态注册与发现。保存Broker集群的注册信息（路由信息），并有心跳机制(每10s一次检测Broker是否存活)。<strong>NameServer集群之间不进行信息通讯</strong>，是一个几乎无状态节点，每个实例都保存完整的路由信息。</p>
</li>
<li><p>Broker： MQ服务器，负责消息队列主体功能，有主从两种身份，通过配置文件brokerId=0（master）或非0（slave）指定。每个Broker与NameServer集群<strong>所有节点</strong>建立连接，<strong>每隔30s</strong>注册Topic信息到NameServer所有节点。注：Master与Slave的关系是一对多，但只有BrokerId=1的从服务器才会参与消息的读负载。</p>
<p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rocketmq_architecture_2.png"></p>
</li>
</ul>
<p>  Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</p>
<p>  Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</p>
<p>  Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</p>
<p>  HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p>
<p>  Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</p>
<ul>
<li><p>Producer: 消息生产者，随机选择NameServer建立长连接并定期（<strong>每隔30s</strong>）获取Topic路由信息。与master建立长连接，保持心跳。</p>
</li>
<li><p>Consumer：消息消费者，随机选择NameServer建立长连接并定期获取Topic路由信息。与master、slave建立长连接，保持心跳。支持推（<strong>实时性好，但需注意消费者消费能力</strong>）、拉两种消费模式，集群消费与广播消费两种消费方式。</p>
</li>
</ul>
<h3 id="其他重要概念"><a href="#其他重要概念" class="headerlink" title="其他重要概念"></a>其他重要概念</h3><ul>
<li>Topic：主题用于表示一类消息的集合，<strong>每条消息只能属于一个主题</strong>，是RocketMQ进行消息订阅的基本单位。生产消费者与toipc都是1对n关系，Topic是一个上逻辑概念。消息存储不会按Topic分开。</li>
<li>Group：组区分，标识一类应用，分生产者组和消费者组，属于同一组的生产/消费者生产/消费同一类消息且处理逻辑一致。组的区分使消费者实现负载均衡和容错的目标或广播变得非常容易。<strong>发送分布式事务消息时，如果Producer中途意外宕机，Broker会主动回调同一组内的任意一台Producer机器来确认事务状态。</strong></li>
<li>Message：消息载体，生产和消费数据的最小单位，可通过唯一MeaasgeID或业务标识key查询消息。MessageId的长度总共有<strong>16字</strong>节，其中包含了消息<strong>存储主机地址</strong>（IP地址和端口），消息Commit Log <strong>offset</strong>。</li>
<li>Tag：标签，用于同一主题区分不同消息，消费者可以根据Tag实现对不同子主题的不同消费逻辑，<strong>可用于消息过滤</strong>，如：consumer.subscribe(topic, “tag1 || tag2”)订阅消费topic主题tag1或tag2的消息。*<em>传入 null,””,”</em>“都是表示订阅全部的作用**。</li>
<li>Queue: Topic与queue是一对多关系，主要用于负载均衡。</li>
<li>Offset: 存储消息时会为每个topic下的每个Queue生成一个消息的索引文件，每个queue都对应一个offset记录当前queue中消息条数。存储消息数据的log文件是顺序存储的，通过二分查找定位数据，时间复杂度可降到logN。</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>启动NameServer监听端口，等待Broker、Producer、Consumer连接。</li>
<li>启动Broker与所有NameServer保持长连接，定时发送心跳包。心跳包中包含当前<strong>Broker信息(IP+端口等)以及存储所有Topic信息</strong>。注册成功后，<strong>NameServer集群中就有Topic跟Broker的映射关系。</strong> (下面源码分析RouteInfoManager有介绍)</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ol>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><ul>
<li><p>全局顺序</p>
<p>对于指定topic，全部消息都按照严格的先入先出（FIFO）的顺序进行发布和消费。 <strong>（性能低）</strong></p>
</li>
<li><p>局部顺序</p>
<p>通过是实现MessageQueueSelector重写select方法，对于业务要求顺便的的消息发送到到相同分区（局部顺序性）。</p>
</li>
</ul>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h3><p>服务端过滤</p>
<p>tag：大多数业务使用场景</p>
<p>bySql：部分业务线使用，支持<strong>SQL92</strong>语法，通过MessageSelector.bySql(“sql语句”)编写。</p>
<p>优点：减少了对于Consumer无用消息的网络传输。</p>
<p>缺点：增加了Broker的负担、而且实现相对复杂。</p>
<h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><p>延时等级（从1开始，小于0不重试，直接存入死信队列，18个level，通过msg.setDelayLevel(level)设置）：“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”</p>
<p>原理：定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/message.png"></p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>1.  CommitLog</strong>: 消息主体以及元数据储存主体，默认大小为1G。文件名以20位数字组成（右边为起偏移量，左边补0）如：00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong>顺序写</strong>入日志文件，当文件满了，写入下一个文件。</p>
<p><strong>2. ConsumeQueue：</strong>消费者队列（逻辑消费队列）作为消费消息的<strong>索引</strong>，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。<strong>引入的目的主要是提高消息消费的性能</strong>。consumequeue文件采取定长设计，<strong>每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode</strong>，单个文件由30W个条目组成，可以像<strong>数组一样随机访问每一个条目</strong>，每个ConsumeQueue文件大小约5.72M。</p>
<p>结构如下：</p>
<p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/rocketmq_design_7.png" alt="img"></p>
<p><strong>3. IndexFile：</strong> 索引文件，<strong>用于通过key或msgId来查询消息</strong>。单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，底层存储设计为在文件系统中实现<strong>HashMap</strong>结构<strong>即hash索引。</strong>RocketMQ的混合型存储结构(统一broker的多个Topic的消息实体内容都存储于一个CommitLog中)，当消费者无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待<strong>30s</strong>的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。<img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/indexFile.png"></p>
<h3 id="数据存取优化"><a href="#数据存取优化" class="headerlink" title="数据存取优化"></a>数据存取优化</h3><h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>RocketMQ通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（减少了内核缓冲区和用户缓冲区之间数据拷贝），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（<strong>正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存</strong>）</p>
<h4 id="页缓存"><a href="#页缓存" class="headerlink" title="页缓存"></a>页缓存</h4><p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。OS访问物理磁盘上文件时，会顺序对其他相邻块的数据文件进行预读取。<strong>涉及局部性原理</strong>。对于数据的<strong>顺序</strong>写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，读取性能几乎接近内存，CommitLog文件会有较多的<strong>随机访问</strong>，所以才应生出index用于加速查找。</p>
<h2 id="消息过滤-1"><a href="#消息过滤-1" class="headerlink" title="消息过滤"></a>消息过滤</h2><h3 id="Tag过滤方式"><a href="#Tag过滤方式" class="headerlink" title="Tag过滤方式"></a>Tag过滤方式</h3><p>Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash（后8字节）值去做过滤，由于在<strong>服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤</strong>，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p>
<p>思考：在服务端实现精准过滤会增加服务端压力，不过滤直接交给客户端又有网络传输浪费，hash过滤是中间的权衡。</p>
<h3 id="SQL92的过滤方式"><a href="#SQL92的过滤方式" class="headerlink" title="SQL92的过滤方式"></a>SQL92的过滤方式</h3><p>这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的 SQL expression 的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了<strong>BloomFilter</strong>避免了每次都去执行。SQL92的表达式上下文为消息的属性。</p>
<p>注：过滤相关类：org.apache.rocketmq.store.MessageFilter</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><p>发送端先通过topic找到对应路由信息：TopicPublishInfo，再调用selectOneMessageQueue()方法选择具体队列MessageQueue发送消息。</p>
<h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>负载均衡的核心—RebalanceImpl类的rebalanceByTopic方法。</p>
<p><strong>Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，</strong>而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。（org.apache.rocketmq.client.impl.consumer.RebalanceImpl#dispatchPullRequest）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebalanceByTopic</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (messageModel) &#123;</span><br><span class="line">     <span class="comment">//广播模式</span></span><br><span class="line">    <span class="keyword">case</span> BROADCASTING: &#123;</span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, mqSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, mqSet);</span><br><span class="line">          log.info(<span class="string">&quot;messageQueueChanged &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                   consumerGroup,</span><br><span class="line">                   topic,</span><br><span class="line">                   mqSet,</span><br><span class="line">                   mqSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> CLUSTERING: &#123;</span><br><span class="line">      <span class="comment">//获取该topic下的所有MessageQueue</span></span><br><span class="line">      Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">      <span class="comment">//向Broker获取该消费组下消费者Id列表（通过org.apache.rocketmq.remoting.netty.NettyRemotingClient#invokeSync</span></span><br><span class="line">      <span class="comment">//发送rpc请求，Broker端基于Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</span></span><br><span class="line">      List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == mqSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">          log.warn(<span class="string">&quot;doRebalance, &#123;&#125;, but the topic[&#123;&#125;] not exist.&quot;</span>, consumerGroup, topic);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == cidAll) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;doRebalance, &#123;&#125; &#123;&#125;, get consumer id list failed&quot;</span>, consumerGroup, topic);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        mqAll.addAll(mqSet);</span><br><span class="line">				</span><br><span class="line">       	<span class="comment">//排序</span></span><br><span class="line">        Collections.sort(mqAll);</span><br><span class="line">        Collections.sort(cidAll);</span><br><span class="line">				<span class="comment">//消息队列分配策略算法（默认为：消息队列的平均分配算法AllocateMessageQueueAveragely），计算出待拉取的消息队列。</span></span><br><span class="line">        <span class="comment">// 这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，</span></span><br><span class="line">        <span class="comment">// 并求出每一页需要包含的平均size和每个页面记录的范围range，</span></span><br><span class="line">        <span class="comment">// 最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</span></span><br><span class="line">        AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          allocateResult = strategy.allocate(</span><br><span class="line">            <span class="keyword">this</span>.consumerGroup,</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.getClientId(),</span><br><span class="line">            mqAll,</span><br><span class="line">            cidAll);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          log.error(<span class="string">&quot;AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;&quot;</span>, strategy.getName(),</span><br><span class="line">                    e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">          allocateResultSet.addAll(allocateResult);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</span></span><br><span class="line">        <span class="comment">//该方法最后会执行dispatchPullRequest()方法，</span></span><br><span class="line">        <span class="comment">//push模式会将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。</span></span><br><span class="line">        <span class="comment">//pull模式为空实现</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">          log.info(</span><br><span class="line">            <span class="string">&quot;rebalanced result changed. allocateMessageQueueStrategyName=&#123;&#125;, group=&#123;&#125;, topic=&#123;&#125;, clientId=&#123;&#125;, mqAllSize=&#123;&#125;, cidAllSize=&#123;&#125;, rebalanceResultSize=&#123;&#125;, rebalanceResultSet=&#123;&#125;&quot;</span>,</span><br><span class="line">            strategy.getName(), consumerGroup, topic, <span class="keyword">this</span>.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(),</span><br><span class="line">            allocateResultSet.size(), allocateResultSet);</span><br><span class="line">          <span class="keyword">this</span>.messageQueueChanged(topic, mqSet, allocateResultSet);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>默认分配策略:org.apache.rocketmq.client.consumer.rebalance.AllocateMessageQueueAveragely#allocate</p>
<p><strong>同一组的消费者数量大于队列数，会有消费者无法消费到数据！注释说明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="keyword">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;currentCID is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="keyword">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;mqAll is null or mqAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="keyword">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;cidAll is null or cidAll empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;&quot;</span>,</span><br><span class="line">                consumerGroup,</span><br><span class="line">                currentCID,</span><br><span class="line">                cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line">        <span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line">  			<span class="comment">//计算消费队列数</span></span><br><span class="line">        <span class="keyword">int</span> averageSize =</span><br><span class="line">            mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">                + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line">        <span class="comment">//开始索引，注意！！！若消费者队列数小于同一组的消费者数，并且索引大于mod(此时等于队列数)</span></span><br><span class="line">  			<span class="comment">//index * averageSize + mod 会 大于mqAll.size()，</span></span><br><span class="line">  			<span class="comment">//下面range会小于0，所以没有分配到队列，会无法消费到消息</span></span><br><span class="line">  			<span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;	</span><br><span class="line">        <span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">            result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡执行过程简要描述："><a href="#负载均衡执行过程简要描述：" class="headerlink" title="负载均衡执行过程简要描述："></a>负载均衡执行过程简要描述：</h3><p>RebalanceService线程run方法（默认20秒执行一次）最终会调用org.apache.rocketmq.client.impl.consumer.RebalanceImpl#rebalanceByTopic，在updateProcessQueueTableInRebalance方法中会为新分配的MessageQueue 会创建一个 PullRequest 对象，然后通过 dispatchPullRequest方法（pull模式为空实现）调用defaultMQPushConsumerImpl的executePullRequestImmediately方法 将 PullRequest放入到 PullMessageService 线程的 LinkedBlockingQueue, 进而唤醒 queue.take()方法，然后执行 DefaultMQPushConsumerImpl 的 pullMessage, 通过网络从broker端拉取消息，一次最多拉取的消息条数可配置，默认为32条，然后然后将拉取的消息，执行过滤等，然后封装成任务（ConsumeRequest）, 提交到消费者的线程池去执行，每次消费消息后，又将该 PullRequest 放入到 PullMessageService中，（DefaultMQPushConsumerImpl)的延迟的机制就是pullInterval 为 0；</p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" alt="事务消息"></p>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></p>
<h2 id="主要目录简介"><a href="#主要目录简介" class="headerlink" title="主要目录简介"></a>主要目录简介</h2><ul>
<li>acl 权限模块</li>
<li>broker broker模块，核心任务就是持久化消息</li>
<li>client 消息客户端，包括生产与消费者</li>
<li>common 公共依赖包，通用的常量枚举、基类方法或者数据结构。</li>
<li>dev 开发者信息（就一个py文件）</li>
<li>distribution 部署脚本、配置模块</li>
<li>docs 开发者文档</li>
<li>example 示例模块</li>
<li>filter 消息过滤器</li>
<li>namesrv NameServer模块</li>
<li>openmessaging 消息开放标准</li>
<li>remoting 远程通信模块</li>
<li>serutil 服务工具类</li>
<li>store 消息存储模块</li>
</ul>
<h2 id="主要模块类功能分析"><a href="#主要模块类功能分析" class="headerlink" title="主要模块类功能分析"></a>主要模块类功能分析</h2><p>版本：4.9.1-SNAPSHOT</p>
<h3 id="namesrv模块"><a href="#namesrv模块" class="headerlink" title="namesrv模块"></a>namesrv模块</h3><p>NamesrvStartup：启动类，主要是调用NamesrvController的初始化及开始方法。</p>
<p>NamesrvController：核心控制类。</p>
<p>核心初始化方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line">  <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化负责处理Netty网络交互数据的线程池，</span></span><br><span class="line">  <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">    Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">&quot;RemotingExecutorThread_&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册负责处理Netty网络交互数据的DefaultRequestProcessor，客户端请求会由这个Processor来处理</span></span><br><span class="line">  <span class="keyword">this</span>.registerProcessor();</span><br><span class="line">  <span class="comment">//        每10s扫描存活的Broker</span></span><br><span class="line">  <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//通过比较最近心跳时间距今时间是否超过两分钟决定</span></span><br><span class="line">      NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">  <span class="comment">//         每10分钟打印kv配置</span></span><br><span class="line">  <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">  <span class="comment">//注册tls文件变更的监听器</span></span><br><span class="line">  <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">    <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fileWatchService = <span class="keyword">new</span> FileWatchService(</span><br><span class="line">        <span class="keyword">new</span> String[] &#123;</span><br><span class="line">          TlsSystemConfig.tlsServerCertPath,</span><br><span class="line">          TlsSystemConfig.tlsServerKeyPath,</span><br><span class="line">          TlsSystemConfig.tlsServerTrustCertPath</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">          <span class="keyword">boolean</span> certChanged, keyChanged = <span class="keyword">false</span>;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) &#123;</span><br><span class="line">              log.info(<span class="string">&quot;The trust certificate changed, reload the ssl context&quot;</span>);</span><br><span class="line">              reloadServerSslContext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerCertPath)) &#123;</span><br><span class="line">              certChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerKeyPath)) &#123;</span><br><span class="line">              keyChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (certChanged &amp;&amp; keyChanged) &#123;</span><br><span class="line">              log.info(<span class="string">&quot;The certificate and private key changed, reload the ssl context&quot;</span>);</span><br><span class="line">              certChanged = keyChanged = <span class="keyword">false</span>;</span><br><span class="line">              reloadServerSslContext();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reloadServerSslContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ((NettyRemotingServer) remotingServer).loadSslContext();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.warn(<span class="string">&quot;FileWatchService created error, can&#x27;t load the certificate dynamically&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    NamesrvConfig：NameServer相关属性配置类，如配置文件路径。</p>
<p>​    NettyServerConfig、RemotingServer 、ExecutorService：网络通讯类与Netty密切相关，相关配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NettyServerConfig默认字段配置</span></span><br><span class="line"><span class="comment">//NamesrvStartup#createNamesrvController将该值设置为9876</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> listenPort = <span class="number">8888</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverWorkerThreads = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverCallbackExecutorThreads = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverSelectorThreads = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//单向请求的信号量（并发度），一般用在发送心跳包场景下</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverOnewaySemaphoreValue = <span class="number">256</span>; </span><br><span class="line"><span class="comment">//异步调用的信号量（并发度）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverAsyncSemaphoreValue = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 通道空闲时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> serverChannelMaxIdleTimeSeconds = <span class="number">120</span>;</span><br></pre></td></tr></table></figure>

<p>KVConfigManager ：读取或变更NameServer的配置属性，load方法加载 NamesrvConfig 中配置的配置文件到内存。</p>
<p>请求处理核心逻辑：org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor#processRequest</p>
<p>RouteInfoManager : 用HashMap保存/管理Broker、Topic等信息。内部使用ReadWriteLock保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空闲时长，超过两分钟没收到Broker的心跳包则，断开连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> BROKER_CHANNEL_EXPIRED_TIME = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"><span class="comment">//路由信息保存在org.apache.rocketmq.namesrv.routeinfo.RouteInfoManager的以下字段里</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//主题与队列关系，记录分布在哪些Broker上，Broker上存在该主题的队列个数,QueueData队列描述信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line"><span class="comment">//BrokerData信息描述每一个 broker信息（所属集群，broker名，还有以brokerId为key地址为value的map集合）（broker主从集合）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line"><span class="comment">//集群包含的brokerName</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line"><span class="comment">//当前存活的broker，NameServer10秒扫描一次，非实时有误差</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line"><span class="comment">//过滤服务列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure>

<p>BrokerHousekeepingService：实现ChannelEventListener接口，处理与Broker连接通道关闭，异常，空闲的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelClose</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelException</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChannelIdle</span><span class="params">(String remoteAddr, Channel channel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.namesrvController.getRouteInfoManager().onChannelDestroy(remoteAddr, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileWatchService : 监控tls文件的改动。使用MessageDigest类，用MD5加密算法提取概要信息存ArrayList集合fileCurrentHash里,WATCH_INTERVAL = <strong>500毫秒</strong>查询校验一次。（为啥频率这么高？？？）</p>
<h3 id="broker模块"><a href="#broker模块" class="headerlink" title="broker模块"></a><strong>broker模块</strong></h3><p>broker也有与namesrv一样相应的BrokerStartup与BrokerController作用类似。</p>
<p>消息执行器：org.apache.rocketmq.broker.processor.SendMessageProcessor。</p>
<p><strong>存储配置类</strong>：org.apache.rocketmq.store.config.MessageStoreConfig，部分配置字段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Broker的存储根目录，默认为 $Broker_Home/store。</span></span><br><span class="line"><span class="keyword">private</span> String storePathRootDir = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;store&quot;</span>;</span><br><span class="line"><span class="comment">//设置commitlog的存储目录，默认为$Broker_Home/store/commitlog。</span></span><br><span class="line"><span class="keyword">private</span> String storePathCommitLog = System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator + <span class="string">&quot;store&quot;</span></span><br><span class="line">  + File.separator + <span class="string">&quot;commitlog&quot;</span>;</span><br><span class="line"><span class="comment">// CommitLog文件大小默认 1G</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mappedFileSizeCommitLog = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// ConsumeQueue 存放的是定长的信息（20个字节，偏移量、size、tagscode） 默认是 30W * 20</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mappedFileSizeConsumeQueue = <span class="number">300000</span> * ConsumeQueue.CQ_STORE_UNIT_SIZE;</span><br><span class="line"><span class="comment">// 是否开启 consumeQueueExt,默认为 false,就是如果消费端消息消费速度跟不上，是否创建一个扩展的 ConsumeQueue文件，如果不开启，应该会阻塞从 commitlog 文件中获取消息。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> enableConsumeQueueExt = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 扩展consume文件的大小，默认为48M。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mappedFileSizeConsumeQueueExt = <span class="number">48</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">// Bit count of filter bit map.</span></span><br><span class="line"><span class="comment">// this will be set by pipe of calculate filter bit map.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> bitMapLengthConsumeQueueExt = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//刷写 CommitLog 的间隔时间，RocketMQ 后台会启动一个线程，将消息刷写到磁盘，</span></span><br><span class="line"><span class="comment">// 这个也就是该线程每次运行后等待的时间，默认为500毫秒。flush 操作，调用文件通道的force()方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> flushIntervalCommitLog = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//提交消息到 CommitLog 对应的文件通道的间隔时间，原理与上面类似；</span></span><br><span class="line"><span class="comment">// 将消息写入到文件通道（调用FileChannel.write方法）得到最新的写指针，默认为200毫秒。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> commitIntervalCommitLog = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p><strong>存储核心类</strong>：DefaultMessageStore,存储消息的入口方法为：putMessage，核心步骤如下：</p>
<ol>
<li><p>检查状态：checkStoreStatus() </p>
<ol>
<li>检查当前节点是否已shutdown。</li>
<li>是否是SLAVE节点（SLAVE只读）。</li>
<li>是否可写。</li>
<li>操作系统页写入是否繁忙：isOSPageCacheBusy()。</li>
</ol>
</li>
<li><p>检查消息checkMessage(msg)：检查topic与propertiesString长度。</p>
</li>
<li><p>将日志写入CommitLog 文件：this.commitLog.putMessage(msg)。</p>
</li>
<li><p>统计写入耗时信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);</span><br></pre></td></tr></table></figure>
</li>
<li><p>记录写commitlog 失败次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>消息写入</strong>：org.apache.rocketmq.store.CommitLog#putMessage，核心步骤如下：</p>
<ol>
<li><p>获取消息类型（事务消息，非事务消息，Commit消息。</p>
</li>
<li><p>获取一个 MappedFile 对象，内存映射的具体实现。</p>
</li>
<li><p>追加消息需要加锁PutMessageLock(两种实现PutMessageReentrantLock（内部就个ReentrantLock）和PutMessageSpinLock（默认）（内部含有AtomicBoolean，使用do-while，cas加锁）。</p>
</li>
<li><p>验证 MappedFile 对象，获取一个可用的 MappedFile (如果没有，则创建一个)。</p>
</li>
<li><p>通过MappedFile对象写入文件。result = mappedFile.appendMessage(msg, this.appendMessageCallback);</p>
</li>
<li><p>根据刷盘策略刷盘：handleDiskFlush(result, putMessageResult, msg);</p>
</li>
<li><p>主从同步：handleHA(result, putMessageResult, msg);</p>
</li>
</ol>
<p>**消息长度计算: **org.apache.rocketmq.store.CommitLog#calMsgLength</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calMsgLength</span><span class="params">(<span class="keyword">int</span> sysFlag, <span class="keyword">int</span> bodyLength, <span class="keyword">int</span> topicLength, <span class="keyword">int</span> propertiesLength)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bornhostLength = (sysFlag &amp; MessageSysFlag.BORNHOST_V6_FLAG) == <span class="number">0</span> ? <span class="number">8</span> : <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> storehostAddressLength = (sysFlag &amp; MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == <span class="number">0</span> ? <span class="number">8</span> : <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//单位：字节</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = <span class="number">4</span> <span class="comment">//TOTALSIZE 消息总长度</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//MAGICCODE   模数</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//BODYCRC     数据校验CR</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//QUEUEID     消息队列id</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//FLAG        标记位</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//QUEUEOFFSET 消息队列偏移量</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//PHYSICALOFFSET 物理偏移量</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//SYSFLAG      系统标记</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//BORNTIMESTAMP  bornt存储时间戳</span></span><br><span class="line">      + bornhostLength <span class="comment">//BORNHOST  Broken地址、端口</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//STORETIMESTAMP 时间戳</span></span><br><span class="line">      + storehostAddressLength <span class="comment">//STOREHOSTADDRESS  存储地址端口</span></span><br><span class="line">      + <span class="number">4</span> <span class="comment">//RECONSUMETIMES 消息重试次数</span></span><br><span class="line">      + <span class="number">8</span> <span class="comment">//Prepared Transaction Offset </span></span><br><span class="line">      + <span class="number">4</span> + (bodyLength &gt; <span class="number">0</span> ? bodyLength : <span class="number">0</span>) <span class="comment">//BODY 4字节的body长度+具体消息长度</span></span><br><span class="line">      + <span class="number">1</span> + topicLength <span class="comment">//TOPIC 一字节的topic长度与topic内容长度</span></span><br><span class="line">      + <span class="number">2</span> + (propertiesLength &gt; <span class="number">0</span> ? propertiesLength : <span class="number">0</span>) <span class="comment">//propertiesLength 消息属性长度</span></span><br><span class="line">      + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> msgLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全局唯一msgId</strong>生成代码位置：org.apache.rocketmq.common.message.MessageDecoder#createMessageId(java.nio.ByteBuffer, java.nio.ByteBuffer, long) <strong>由ip+port+commitLog偏移地址组成</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createMessageId</span><span class="params">(<span class="keyword">final</span> ByteBuffer input, <span class="keyword">final</span> ByteBuffer addr, <span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">  input.flip();</span><br><span class="line">  <span class="keyword">int</span> msgIDLength = addr.limit() == <span class="number">8</span> ? <span class="number">16</span> : <span class="number">28</span>;</span><br><span class="line">  input.limit(msgIDLength);</span><br><span class="line"></span><br><span class="line">  input.put(addr);</span><br><span class="line">  input.putLong(offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> UtilAll.bytes2string(input.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>**消息刷盘 **:  org.apache.rocketmq.store.CommitLog#handleDiskFlush</p>
<p>具体刷盘org.apache.rocketmq.store.MappedFile#flush：就是调用 FileChannel 或 MappedByteBuffer 的force 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//同步刷写</span></span><br><span class="line">  <span class="comment">// Synchronization flush</span></span><br><span class="line">  <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">    <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line">    <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123; <span class="comment">//是否一定要收到存储MSG信息，才返回，默认为true。如果要等待存储结果。</span></span><br><span class="line">      GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">      service.putRequest(request);</span><br><span class="line">      CompletableFuture&lt;PutMessageStatus&gt; flushOkFuture = request.future();</span><br><span class="line">      PutMessageStatus flushStatus = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        flushStatus = flushOkFuture.get(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">//flushOK=false;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;do groupcommit, wait for flush failed, topic: &quot;</span> + messageExt.getTopic() + <span class="string">&quot; tags: &quot;</span> + messageExt.getTags()</span><br><span class="line">                  + <span class="string">&quot; client address: &quot;</span> + messageExt.getBornHostString());</span><br><span class="line">        putMessageResult.setPutMessageStatus(PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      service.wakeup(); <span class="comment">//唤醒同步刷盘线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Asynchronous flush //异步刷盘机制</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">      flushCommitLogService.wakeup();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      commitLogService.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>消息存储过程</strong></p>
<p><img src="/2021/07/26/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/RocketMQ%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="client模块"><a href="#client模块" class="headerlink" title="client模块"></a>client模块</h3><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>默认发送方法org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#sendDefaultImpl</p>
<h4 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h4><ol>
<li><p>消息（group、topic、body等）校验：Validators.checkMessage(msg, this.defaultMQProducer);</p>
</li>
<li><p>获取topic的路由信息：TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</p>
</li>
<li><p>根据topic负载均衡算法选择一个MessageQueue。可实现MessageQueueSelector自定义。</p>
<p>默认org.apache.rocketmq.client.latency.MQFaultStrategy#selectOneMessageQueue方法有ThreadLocalIndex sendWhichQueue保存上次发送队列下标，使用轮询获取发送队列下标，对开启失败延迟的话还会对队列进行判断验证。</p>
</li>
<li><p>向 MessageQueue 发送消息。</p>
</li>
<li><p>更新失败策略,主要用于规避发生故障的 broker。</p>
</li>
<li><p>如果是同步调用方式(SYNC),则执行失败重试策略，默认重试两次, 异步消息发送的重试是在回调时。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? </span><br><span class="line">  <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="延迟类MQFaultStrategy"><a href="#延迟类MQFaultStrategy" class="headerlink" title="延迟类MQFaultStrategy"></a>延迟类MQFaultStrategy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//latencyMax：最大延迟时间数值，在消息发送之前，先记录当前时间（start），然后消息发送成功或失败时记录当前时间（end），(end-start)代表一次消息延迟时间，发送错误时</span></span><br><span class="line"><span class="comment">//对之前失败的，按一定的时间做退避，下面通过索引相对应，如上次请求的latency超过550Lms，就退避3000Lms；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="校验配置类"><a href="#校验配置类" class="headerlink" title="校验配置类"></a>校验配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Validators</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VALID_PATTERN_STR = <span class="string">&quot;^[%|a-zA-Z0-9_-]+$&quot;</span>;</span><br><span class="line">  	<span class="comment">//分组与topic的命名符号限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN = Pattern.compile(VALID_PATTERN_STR);</span><br><span class="line">    <span class="comment">//group长度限制</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHARACTER_MAX_LENGTH = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">//topic长度限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOPIC_MAX_LENGTH = <span class="number">127</span>;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他限制：默认超时时间3s（org.apache.rocketmq.client.producer.DefaultMQProducer#sendMsgTimeout），消息body最大4M（org.apache.rocketmq.client.producer.DefaultMQProducer#maxMessageSize）。</p>
<h3 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h3><h4 id="主要类简介："><a href="#主要类简介：" class="headerlink" title="主要类简介："></a><strong>主要类简介</strong>：</h4><p>DefaultMQPushConsumerImpl ：消息消息者默认实现类，应用程序中直接用该类的实例完成消息的消费，并回调业务方法。</p>
<p>RebalanceImpl 消费端消费者与消息队列的重新分布。</p>
<p>MQClientInstance 消息客户端实例，负载与MQ服务器（Broker,Nameserver)交互的网络实现。</p>
<p>NettyRemotingClient ：管理连接ChannelWrapper（channel的包装类）</p>
<p>PullAPIWrapper pull与Push在RocketMQ中，其实就只有Pull模式，所以Push其实就是用pull封装一下。</p>
<p>MessageListenerInner 消费消费回调类，当消息分配给消费者消费时，执行的业务代码入口。</p>
<p>OffsetStore 消息消费进度保存。</p>
<p>ConsumeMessageService 消息消费逻辑。</p>
<h4 id="核心类关系梳理"><a href="#核心类关系梳理" class="headerlink" title="核心类关系梳理"></a>核心类关系梳理</h4><p><span style="color:red;">一个客户端对应一个MQClientInstance</span>，在org.apache.rocketmq.client.impl.MQClientManager#factoryTable维持关系，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConcurrentMap&lt;String<span class="comment">/* clientId */</span>, MQClientInstance&gt; factoryTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, MQClientInstance&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端id生成规则</span></span><br><span class="line"><span class="comment">//org.apache.rocketmq.client.ClientConfig#buildMQClientId</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buildMQClientId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="keyword">this</span>.getClientIP());</span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">    <span class="comment">//private String instanceName = System.getProperty(&quot;rocketmq.client.name&quot;, &quot;DEFAULT&quot;);</span></span><br><span class="line">  	sb.append(<span class="keyword">this</span>.getInstanceName()); </span><br><span class="line">    <span class="keyword">if</span> (!UtilAll.isBlank(<span class="keyword">this</span>.unitName)) &#123;</span><br><span class="line">      sb.append(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">      sb.append(<span class="keyword">this</span>.unitName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span style="color:red;">一个应用程序（消费端）同一个IP:端口，一个消费组对应一个DefaultMQPushConsumerImpl，DefaultMQPushConsumerImpl持有有一个MQClientInstance(从MQClientManage获取)，一个MQClientInstance中持有一个PullMessageServive实例。</span></p>
<p><span style="color:red;">结论：同一个应用程序中，如果存在多个消费组，那么就有多个DefaultMQPushConsumerImpl ，所有相同clientId的DefaultMQPushConsumerImpl 都需要依靠同一个PullMessageServive拉取消息。</span></p>
<h4 id="启动核心："><a href="#启动核心：" class="headerlink" title="启动核心："></a><strong>启动核心</strong>：</h4><p>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#start</p>
<p><strong>核心步骤如下：</strong></p>
<ol>
<li><p>checkConfig,检查配置信息，主要检查消费者组（consumeGroup）、消息消费方式（messageModel）、消息消费开始偏移量（consumeFromWhere）、消息队列分配算法（AllocateMessageQueueStrategy）、订阅消息主题（Map&lt;String /* topic */, String /* sub expression */&gt; subscription）, 消息回调监听器(MessageListener)等。</p>
</li>
<li><p>copySubscription 加工订阅信息，将 Map&lt;String /* topic*/, String／＊ｓｕｂｅｘｔｅｎｄｓ＊／＞转换为Map&lt;String,SubscriptionData&gt;,如果messageListenerInner为空，则设置为defaultMQPushConsumer的MessageListener</p>
<p>同时，如果消息消费模式为集群模式，还需要为该消费组对应一个重试主题。</p>
</li>
<li><p>如果消息消费模式为集群模式，并且当前的实例名为 DEFAULT，替换为当前客户端进程的PID + “#” + System.nanoTime()。</p>
</li>
<li><p>负载均衡相关实现。rebalanceImpl</p>
</li>
<li><p>创建pullAPIWrapper，消息拉取API封装类。</p>
</li>
<li><p>消费进度存储，如果是集群模式，使用远程存储 RemoteBrokerOffsetStore，如果是广播模式，则使用本地存储LocalFileOffsetStore，后文重点关注。</p>
</li>
<li><p>加载消息消费进度。</p>
</li>
<li><p>消息消费服务并启动。this.consumeMessageService.start();</p>
</li>
<li><p>向远程 Broker 服务器注册消费者。</p>
</li>
<li><p>更新订阅信息。this.updateTopicSubscribeInfoWhenSubscriptionChanged();</p>
</li>
<li><p>检测broker状态。this.mQClientFactory.checkClientInBroker();</p>
</li>
<li><p>发送心跳包。this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</p>
</li>
<li><p>重新负载。this.mQClientFactory.rebalanceImmediately();</p>
<p>最终调用org.apache.rocketmq.client.impl.consumer.RebalanceImpl#doRebalance</p>
</li>
</ol>
<h4 id="客户端定时任务"><a href="#客户端定时任务" class="headerlink" title="客户端定时任务"></a>客户端定时任务</h4><p>org.apache.rocketmq.client.impl.factory.MQClientInstance#startScheduledTask</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                      	<span class="comment">//每2分钟获取NameServer地址，内部使用http的get请求获取默认3秒超时</span></span><br><span class="line">                        MQClientInstance.<span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;ScheduledTask fetchNameServerAddr exception&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//每30秒更新topic信息</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.updateTopicRouteInfoFromNameServer();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask updateTopicRouteInfoFromNameServer exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每30S 进行Broker心跳检测</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.cleanOfflineBroker();</span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask sendHeartbeatToAllBroker exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="keyword">this</span>.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//默认每隔5秒持久化ConsumeOffset</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.persistAllConsumerOffset();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask persistAllConsumerOffset exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	 <span class="comment">//每分钟调整一次线程</span></span><br><span class="line">                    MQClientInstance.<span class="keyword">this</span>.adjustThreadPool();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask adjustThreadPool exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息拉取服务-org-apache-rocketmq-client-impl-consumer-PullMessageService"><a href="#消息拉取服务-org-apache-rocketmq-client-impl-consumer-PullMessageService" class="headerlink" title="消息拉取服务 org.apache.rocketmq.client.impl.consumer.PullMessageService"></a>消息拉取服务 org.apache.rocketmq.client.impl.consumer.PullMessageService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//从LinkedBlockingQueue&lt;PullRequest&gt;中获取request拉取消息</span></span><br><span class="line">        PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">        <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Pull Message Service Run Method exception&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MQConsumerInner consumer = <span class="keyword">this</span>.mQClientFactory.selectConsumer(pullRequest.getConsumerGroup());</span><br><span class="line">    <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        DefaultMQPushConsumerImpl impl = (DefaultMQPushConsumerImpl) consumer;</span><br><span class="line">        <span class="comment">//调用的是DefaultMQPushConsumerImpl的pullMessage</span></span><br><span class="line">        impl.pullMessage(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	log.warn(<span class="string">&quot;No matched consumer for the PullRequest &#123;&#125;, drop it&quot;</span>, pullRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正拉取消息：</p>
<p>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#pullMessage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">  <span class="keyword">if</span> (processQueue.isDropped()) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;the pull request[&#123;&#125;] is dropped.&quot;</span>, pullRequest.toString());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//检查当前状态是否running</span></span><br><span class="line">    <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;pullMessage exception, consumer state not ok&quot;</span>, e);</span><br><span class="line">    <span class="comment">//延后3秒再执行，其实就是延后3秒后再把pullRequest放入org.apache.rocketmq.client.impl.consumer.PullMessageService.pullRequestQueue队列里</span></span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//暂停状态延后1秒</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isPause()) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;consumer was paused, execute pull request later. instanceName=&#123;&#125;, group=&#123;&#125;&quot;</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getInstanceName(), <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//流量控制</span></span><br><span class="line">  <span class="keyword">long</span> cachedMessageCount = processQueue.getMsgCount().get();</span><br><span class="line">  <span class="keyword">long</span> cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">  <span class="comment">//缓存消息数量大于1000</span></span><br><span class="line">  <span class="keyword">if</span> (cachedMessageCount &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue()) &#123;</span><br><span class="line">    <span class="comment">//延后50毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      log.warn(</span><br><span class="line">        <span class="string">&quot;the cached message count exceeds the threshold &#123;&#125;, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//缓存消息大小超过100MB</span></span><br><span class="line">  <span class="keyword">if</span> (cachedMessageSizeInMiB &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue()) &#123;</span><br><span class="line">    <span class="comment">//延后50毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">    <span class="keyword">if</span> ((queueFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      log.warn(</span><br><span class="line">        <span class="string">&quot;the cached message size exceeds the threshold &#123;&#125; MiB, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, count=&#123;&#125;, size=&#123;&#125; MiB, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.consumeOrderly) &#123; <span class="comment">//非顺序消息</span></span><br><span class="line">    <span class="comment">//消费队列所存范围lastqueueOffset-firstqueueOffset &gt; 2000</span></span><br><span class="line">    <span class="keyword">if</span> (processQueue.getMaxSpan() &gt; <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) &#123;</span><br><span class="line">      <span class="comment">//延后50毫秒</span></span><br><span class="line">      <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span><br><span class="line">      <span class="keyword">if</span> ((queueMaxSpanFlowControlTimes++ % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        log.warn(</span><br><span class="line">          <span class="string">&quot;the queue&#x27;s messages, span too long, so do flow control, minOffset=&#123;&#125;, maxOffset=&#123;&#125;, maxSpan=&#123;&#125;, pullRequest=&#123;&#125;, flowControlTimes=&#123;&#125;&quot;</span>,</span><br><span class="line">          processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span><br><span class="line">          pullRequest, queueMaxSpanFlowControlTimes);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (processQueue.isLocked()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pullRequest.isPreviouslyLocked()) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = -<span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          offset = <span class="keyword">this</span>.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">          <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">          log.error(<span class="string">&quot;Failed to compute pull offset, pullResult: &#123;&#125;&quot;</span>, pullRequest, e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> brokerBusy = offset &lt; pullRequest.getNextOffset();</span><br><span class="line">        log.info(<span class="string">&quot;the first time to pull message, so fix offset from broker. pullRequest: &#123;&#125; NewOffset: &#123;&#125; brokerBusy: &#123;&#125;&quot;</span>,</span><br><span class="line">                 pullRequest, offset, brokerBusy);</span><br><span class="line">        <span class="keyword">if</span> (brokerBusy) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: &#123;&#125; NewOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                   pullRequest, offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pullRequest.setPreviouslyLocked(<span class="keyword">true</span>);</span><br><span class="line">        pullRequest.setNextOffset(offset);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">      log.info(<span class="string">&quot;pull message later because not locked in broker, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//通过topic获取订阅信息</span></span><br><span class="line">  <span class="keyword">final</span> SubscriptionData subscriptionData = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionData) &#123;</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    log.warn(<span class="string">&quot;find the consumer&#x27;s subscription failed, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//拉取消息回调</span></span><br><span class="line">  PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//对消息体解码成并执行消息过滤</span></span><br><span class="line">        pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                                                                                     subscriptionData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">          <span class="keyword">case</span> FOUND:</span><br><span class="line">            <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">            <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                                                                               pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                                                                  pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line">              <span class="comment">//将拉取到的消息放入消费队列中：就是将拉取的消息，放入到ProcessQueue的msgTreeMap容器中。</span></span><br><span class="line">              <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">              <span class="comment">//消费消息服务提交，提交消息会被ConsumeRequest包装提交到消费端消费线程池消费</span></span><br><span class="line">              DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                pullResult.getMsgFoundList(),</span><br><span class="line">                processQueue,</span><br><span class="line">                pullRequest.getMessageQueue(),</span><br><span class="line">                dispatchToConsume);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                                                       DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">              log.warn(</span><br><span class="line">                <span class="string">&quot;[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;&quot;</span>,</span><br><span class="line">                pullResult.getNextBeginOffset(),</span><br><span class="line">                firstMsgOffset,</span><br><span class="line">                prevRequestOffset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">          <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">            log.warn(<span class="string">&quot;the pull request offset illegal, &#123;&#125; &#123;&#125;&quot;</span>,</span><br><span class="line">                     pullRequest.toString(), pullResult.toString());</span><br><span class="line">            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">            pullRequest.getProcessQueue().setDropped(<span class="keyword">true</span>);</span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executeTaskLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span><br><span class="line">                                                                          pullRequest.getNextOffset(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                  DefaultMQPushConsumerImpl.<span class="keyword">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                  log.warn(<span class="string">&quot;fix the pull request offset, &#123;&#125;&quot;</span>, pullRequest);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  log.error(<span class="string">&quot;executeTaskLater Exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;execute the pull request exception&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> commitOffsetEnable = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">long</span> commitOffsetValue = <span class="number">0L</span>;</span><br><span class="line">  <span class="keyword">if</span> (MessageModel.CLUSTERING == <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">    <span class="comment">//如果是集群消费模式，从内存中获取MessageQueue的commitlog偏移量。</span></span><br><span class="line">    commitOffsetValue = <span class="keyword">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">    <span class="keyword">if</span> (commitOffsetValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      commitOffsetEnable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String subExpression = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> classFilter = <span class="keyword">false</span>;</span><br><span class="line">  SubscriptionData sd = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">  <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</span><br><span class="line">      subExpression = sd.getSubString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    classFilter = sd.isClassFilterMode();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//构建拉取消息系统Flag: 是否支持comitOffset,suspend,subExpression,classFilter</span></span><br><span class="line">  <span class="keyword">int</span> sysFlag = PullSysFlag.buildSysFlag(</span><br><span class="line">    commitOffsetEnable, <span class="comment">// commitOffset</span></span><br><span class="line">    <span class="keyword">true</span>, <span class="comment">// suspend</span></span><br><span class="line">    subExpression != <span class="keyword">null</span>, <span class="comment">// subscription</span></span><br><span class="line">    classFilter <span class="comment">// class filter</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//消息拉取核心api执行</span></span><br><span class="line">    <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">      pullRequest.getMessageQueue(), <span class="comment">//消息消费队列</span></span><br><span class="line">      subExpression, <span class="comment">//tag过滤表达式</span></span><br><span class="line">      subscriptionData.getExpressionType(), <span class="comment">//tag</span></span><br><span class="line">      subscriptionData.getSubVersion(), <span class="comment">//版本其实就是时间戳</span></span><br><span class="line">      pullRequest.getNextOffset(),</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(), <span class="comment">//批量拉取大小，32</span></span><br><span class="line">      sysFlag, <span class="comment">// 系统标记</span></span><br><span class="line">      commitOffsetValue,<span class="comment">//当前消息队列的MessageQueue的commitlog偏移量</span></span><br><span class="line">      BROKER_SUSPEND_MAX_TIME_MILLIS, <span class="comment">//允许broker暂停时间，15s</span></span><br><span class="line">      CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, <span class="comment">//超时时间，30s</span></span><br><span class="line">      CommunicationMode.ASYNC, <span class="comment">// 异步</span></span><br><span class="line">      pullCallback <span class="comment">//pull消息回调</span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;pullKernelImpl exception&quot;</span>, e);</span><br><span class="line">    <span class="keyword">this</span>.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消费端消费线程池"><a href="#消费端消费线程池" class="headerlink" title="消费端消费线程池"></a>消费端消费线程池</h4><p>非顺序：org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#consumeExecutor</p>
<p>顺序：org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService#consumeExecutor</p>
<h4 id="消费任务类"><a href="#消费任务类" class="headerlink" title="消费任务类:"></a>消费任务类:</h4><p>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService.ConsumeRequest</p>
<p>org.apache.rocketmq.client.impl.consumer.ConsumeMessageOrderlyService.ConsumeRequest</p>
<p><strong>ConsumeRequest的run方法会调用我们注册的自定义consumeMessage方法。</strong></p>
<h4 id="顺序消费实现原理"><a href="#顺序消费实现原理" class="headerlink" title="顺序消费实现原理"></a>顺序消费实现原理</h4><p>ConsumeMessageOrderlyService.ConsumeRequest的run方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;run, the message queue not be able to consume, because it&#x27;s dropped. &#123;&#125;&quot;</span>, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">//以消息队列为粒度获取锁对象，也就是说同一时间每个消费队列只能由一个线程执行，保证同一消费队列消息的有序性</span></span><br><span class="line">  <span class="comment">//如果要使用全局顺序消费，那么对应主题只能允许存在一个队列（不建议使用！！！无法发挥多线程优势，并发处理能力降低）</span></span><br><span class="line">  <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">  <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">   			<span class="comment">//……</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MessageQueueLock内部就个map存储消息队列与锁对象关系。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;MessageQueue, Object&gt; mqLockTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;MessageQueue, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fetchLockObject</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        Object objLock = <span class="keyword">this</span>.mqLockTable.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == objLock) &#123;</span><br><span class="line">            objLock = <span class="keyword">new</span> Object();</span><br><span class="line">            Object prevLock = <span class="keyword">this</span>.mqLockTable.putIfAbsent(mq, objLock);</span><br><span class="line">            <span class="keyword">if</span> (prevLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                objLock = prevLock;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> objLock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="消费重试核心"><a href="#消费重试核心" class="headerlink" title="消费重试核心"></a>消费重试核心</h4><p>org.apache.rocketmq.client.impl.consumer.ConsumeMessageConcurrentlyService#processConsumeResult</p>
<p>根据消费结果，设置ackIndex 的值，成功：ackIndex = consumeRequest.getMsgs().size() - 1; 失败：ackIndex = -1<br>如果是消费失败，根据消费模式（集群消费还是广播消费），广播模式，就遍历打印日志，集群模式调用 sendMessageBack。<br>发送成功，重试机制由 broker 处理。发送发失败的，客户端会进行重试：调用如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">    consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">    <span class="comment">//重新提交发送消费失败的延后5s消费</span></span><br><span class="line">    <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), 					             consumeRequest.getMessageQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sendMessageBack</strong>：发送的RequestCode为CONSUMER_SEND_MSG_BACK=36</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap topic with namespace before sending back message.</span></span><br><span class="line">    msg.setTopic(<span class="keyword">this</span>.defaultMQPushConsumer.withNamespace(msg.getTopic()));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;sendMessageBack exception, group: &quot;</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">&quot; msg: &quot;</span> + msg.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>broker处理核心代码位置：org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncConsumerSendMsgBack</p>
<p>延迟级别设置：<strong>如果消息的延迟级别为0,则 3 + 消息重试的次数。即第一次重试的延时时间为10s</strong>,如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes （=<span class="number">16</span>）</span><br><span class="line">      || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果消息次数超过最大限制或延迟级别小于0，设置消息的主题为 DLQ（死信队列） + 消费组名称</span></span><br><span class="line"></span><br><span class="line">    newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">    queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">    topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic,</span><br><span class="line">                                                                                                   DLQ_NUMS_PER_GROUP,</span><br><span class="line">                                                                                                   PermName.PERM_WRITE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">      response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">      response.setRemark(<span class="string">&quot;topic[&quot;</span> + newTopic + <span class="string">&quot;] not exist&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> CompletableFuture.completedFuture(response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == delayLevel) &#123;</span><br><span class="line">      <span class="comment">//如果消息的延迟级别为0,则 3 + 消息重试的次数。即第一次重试的延时时间为10s</span></span><br><span class="line">      delayLevel = <span class="number">3</span> + msgExt.getReconsumeTimes();</span><br><span class="line">    &#125;</span><br><span class="line">    msgExt.setDelayTimeLevel(delayLevel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注：对于需要延迟执行的消息，在存入 commitlog 之前，会将主题修改为SCHEDULE_TOPIC_XXXX，会被延迟任务 ScheduleMessageService 延迟拉取。ScheduleMessageService 在执行过程中，会再次存入 commitlog 文件中放入之前，会清空延迟等级，并恢复主题与队列，这样，就能被消费者所消费，因为消费者在启动时就订阅了该消费组的重试主题（org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#copySubscription）</p>
<p><strong>延迟等级与时间关系加载</strong>：org.apache.rocketmq.store.schedule.ScheduleMessageService#parseDelayLevel </p>
<h3 id="集群模式消费者offset偏移量维护"><a href="#集群模式消费者offset偏移量维护" class="headerlink" title="集群模式消费者offset偏移量维护"></a>集群模式消费者offset偏移量维护</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//treemap保存当前还在处理队列中的消息</span></span><br><span class="line"><span class="comment">//移除已经处理的批处理消息：org.apache.rocketmq.client.impl.consumer.ProcessQueue#removeMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">removeMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.treeMapLock.writeLock().lockInterruptibly();</span><br><span class="line">      <span class="keyword">this</span>.lastConsumeTimestamp = now;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//该处理队列最大的偏移量+1</span></span><br><span class="line">          result = <span class="keyword">this</span>.queueOffsetMax + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">int</span> removedCnt = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">            MessageExt prev = msgTreeMap.remove(msg.getQueueOffset());</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">              removedCnt--;</span><br><span class="line">              msgSize.addAndGet(<span class="number">0</span> - msg.getBody().length);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          msgCount.addAndGet(removedCnt);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!msgTreeMap.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//还有消息在处理队列中，返回处理队列中最小的偏移量，优点：防止消息丢失（也就是没有消费到）缺点：会造成消息重复消费。</span></span><br><span class="line">            result = msgTreeMap.firstKey();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.treeMapLock.writeLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;removeMessage exception&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/prestigeding/article/details/78888290?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162601099216780274159744%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162601099216780274159744&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~hot_rank-10-78888290.first_rank_v2_pc_rank_v29&utm_term=rocketmq%E6%BA%90%E7%A0%81&spm=1018.2226.3001.4187">源码分析RocketMQ</a></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a></div><div class="post_share"><div class="social-share" data-image="https://s3.ax1x.com/2020/12/01/D4plnJ.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/25/GoLang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://s1.ax1x.com/2020/09/17/wfnWJH.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/03/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/"><img class="next-cover" src="https://s1.ax1x.com/2020/09/26/0iRQxA.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RocketMQ快速上手</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/03/中间件/RocketMQ/" title="RocketMQ快速上手"><img class="cover" src="https://s1.ax1x.com/2020/09/26/0iRQxA.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-03</div><div class="title">RocketMQ快速上手</div></div></a></div><div><a href="/2021/05/21/中间件/Kafka/" title="Kafka入门"><img class="cover" src="https://s1.ax1x.com/2020/09/17/wfnWJH.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-21</div><div class="title">Kafka入门</div></div></a></div><div><a href="/2020/09/25/中间件/rabbitMq/" title="RabbitMQ入门"><img class="cover" src="https://s1.ax1x.com/2020/09/17/wfP0Bj.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">RabbitMQ入门</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://s3.ax1x.com/2020/12/01/D4plnJ.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By CZM</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'k2GMUzIrob4GbB5vtonkzLSO-gzGzoHsz',
      appKey: '6k8wcGzpepgvksNzrQlYU2W1',
      placeholder: '记得留下你的痕迹……',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>