<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Kubernetes学习笔记 | 菜鸟明De博客</title><meta name="description" content="Kubernetes(k8s)​        Kubernetes 是个软件系统，它允许你在其上很容易地部署管理容器化的应用，它依赖于 Linux 容器的特性来运行应用， 无须知道这些应用的内部详情也不需要手动将这些应用部署到每台机器。因为这些应用运行在容器里，它们不会影响运行在同一台服务器上的其他应用 ，当你是为完全不同的组织机构运行应用时，这就很关键了 。这对于云供应商来说是至关重要的，因为"><meta name="keywords" content="部署"><meta name="author" content="CZM,2723081630@qq.com"><meta name="copyright" content="CZM"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://czmderepository.gitee.io/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Kubernetes学习笔记"><meta property="og:url" content="https://czmderepository.gitee.io/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="菜鸟明De博客"><meta property="og:description" content="Kubernetes(k8s)​        Kubernetes 是个软件系统，它允许你在其上很容易地部署管理容器化的应用，它依赖于 Linux 容器的特性来运行应用， 无须知道这些应用的内部详情也不需要手动将这些应用部署到每台机器。因为这些应用运行在容器里，它们不会影响运行在同一台服务器上的其他应用 ，当你是为完全不同的组织机构运行应用时，这就很关键了 。这对于云供应商来说是至关重要的，因为"><meta property="og:image" content="https://s1.ax1x.com/2020/09/17/wfnWJH.jpg"><meta property="article:published_time" content="2021-12-05T09:33:00.000Z"><meta property="article:modified_time" content="2022-01-08T08:54:53.560Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: {"text":"小帅哥,爱你,过浪险,欢迎您,过压贴,光临本园,加油,努力,酷炫低调奢华,拼搏,forever,爱你","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-01-08 16:54:53'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/09/17/wRG4fS.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">56</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-k8s"><span class="toc-number">1.</span> <span class="toc-text">Kubernetes(k8s)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.</span> <span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">集群架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF"><span class="toc-number">1.2.1.</span> <span class="toc-text">控制面板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">工作节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">运行应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF%E6%80%8E%E6%A0%B7%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">描述信息怎样成为一个运行的容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E6%9C%BAk8s"><span class="toc-number">1.4.</span> <span class="toc-text">创建单机k8s</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8swap%E5%88%86%E5%8C%BA"><span class="toc-number">1.4.1.</span> <span class="toc-text">禁用swap分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85kubectl"><span class="toc-number">1.4.2.</span> <span class="toc-text">安装kubectl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85minikube"><span class="toc-number">1.4.3.</span> <span class="toc-text">安装minikube</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2"><span class="toc-number">1.4.4.</span> <span class="toc-text">部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4minikube%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.5.</span> <span class="toc-text">清除minikube数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%9B%86%E7%BE%A4"><span class="toc-number">1.4.6.</span> <span class="toc-text">删除集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E9%9B%86%E7%BE%A4"><span class="toc-number">1.4.7.</span> <span class="toc-text">停止集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8rc%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.8.</span> <span class="toc-text">使用rc创建应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%BA%94%E7%94%A8"><span class="toc-number">1.4.9.</span> <span class="toc-text">删除应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.10.</span> <span class="toc-text">详细信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAnginx%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.11.</span> <span class="toc-text">创建nginx服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97"><span class="toc-number">1.4.12.</span> <span class="toc-text">打印日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod"><span class="toc-number">1.5.</span> <span class="toc-text">pod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pod%E9%97%B4%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.1.</span> <span class="toc-text">pod间网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91pod%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">向pod发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Label%E6%A0%87%E7%AD%BE"><span class="toc-number">1.5.3.</span> <span class="toc-text">Label标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.6.1.</span> <span class="toc-text">指定命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88-liveness-probe"><span class="toc-number">1.7.</span> <span class="toc-text">存活探针 (liveness probe)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A2%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.1.</span> <span class="toc-text">探测机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88"><span class="toc-number">1.8.</span> <span class="toc-text">就绪探针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReplicationController%EF%BC%88rc%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">ReplicationController（rc）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.1.</span> <span class="toc-text">协调流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E9%83%A8%E5%88%86"><span class="toc-number">1.9.2.</span> <span class="toc-text">三个主要部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rc%E4%B8%8Epod%E5%85%B3%E7%B3%BB"><span class="toc-number">1.9.3.</span> <span class="toc-text">rc与pod关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9rc%E4%B8%ADpod%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.9.4.</span> <span class="toc-text">修改rc中pod模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">1.9.5.</span> <span class="toc-text">扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4rc%E4%BF%9D%E6%8C%81pod%E8%BF%90%E8%A1%8C"><span class="toc-number">1.9.6.</span> <span class="toc-text">删除rc保持pod运行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReplicaSet-rs"><span class="toc-number">1.10.</span> <span class="toc-text">ReplicaSet(rs)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.10.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#operator-%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">operator (运算符）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DaemonSet%EF%BC%88ds%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">DaemonSet（ds）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service%E6%9C%8D%E5%8A%A1%EF%BC%88SVC%EF%BC%89"><span class="toc-number">1.12.</span> <span class="toc-text">Service服务（SVC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.12.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-FQDN-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.12.2.</span> <span class="toc-text">通过 FQDN 连接服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.12.3.</span> <span class="toc-text">访问外部服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%88%AB%E5%90%8D"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">外部服务创建别名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.12.4.</span> <span class="toc-text">暴露服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">三种方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.13.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#END"><span class="toc-number">1.14.</span> <span class="toc-text">END</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://s1.ax1x.com/2020/09/17/wfnWJH.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">菜鸟明De博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Kubernetes学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-05T09:33:00.000Z" title="发表于 2021-12-05 17:33:00">2021-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-08T08:54:53.560Z" title="更新于 2022-01-08 16:54:53">2022-01-08</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Kubernetes-k8s"><a href="#Kubernetes-k8s" class="headerlink" title="Kubernetes(k8s)"></a>Kubernetes(k8s)</h1><p>​        <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/home/">Kubernetes</a> 是个软件系统，它允许你在其上很容易地部署管理容器化的应用，它依赖于 <a href="/2021/02/07/%E9%83%A8%E7%BD%B2/docker/">Linux 容器的特性</a>来运行应用， 无须知道这些应用的内部详情也不需要手动将这些应用部署到每台机器。因为这些应用运行在容器里，它们不会影响运行在同一台服务器上的其他应用 ，当你是为完全不同的组织机构运行应用时，这就很关键了 。这对于云供应商来说是至关重要的，因为它们在追求高硬件可用的同时也必须保障所承载应用完全隔离。</p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><p>​        整个系统由一个主节点和若干个工作节点组成开发者把一个应用列表提交到主节点，Kubernetes会将它们部署到集群的工作节点。组件被部署在哪个节点对于开发者和系统管理员来说都不用关心。</p>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211205202340757.png" alt="image-20211205202340757"></p>
<h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><p>​        在硬件级别，一个Kubernetes 集群由很多节点组成，这些节点被分成以下两种类型：</p>
<ul>
<li>主节点 ，它承载 Kubernetes 控制和管理整个集群系统的控制面板。</li>
<li>工作节点，它们运行用户实际部署的应用。</li>
</ul>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211205202535863.png" alt="image-20211205202535863"></p>
<h3 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h3><p>​        控制面板用于控制集群并使它工作。它包含多个组件，组件可以运行在单个主节点上或者通过副本分别部署在多个主节点以确保高可用性。这些组件是</p>
<ul>
<li><code>Kubernetes API 服务器</code>：你和其他控制面板组件都要和它通信。</li>
<li><code>Scheculer</code> ：它调度你的应用（为应用的每个可部署组件分配一个工作节点）。</li>
<li><code>Controller Manager</code>：它执行集群级别的功能，如复制组件、持续跟踪工作节点处理节点失败。</li>
<li><code>etcd</code>：一个可靠的分布式数据存储，它能持久化存储集群配置。</li>
</ul>
<blockquote>
<p>控制面板的组件持有并控制集群状态，但是它们不运行你的应用程序。这是由工作节点完成的。工作节点上的组件都需要运行在同一 个节点上， 控制平面的组件可以被简单地分割在多台服务器上。为了保证高可用性， 控制平面的每个组件可以有多个实例。<code>etcd</code>和API服务器的多个实例可以同时并行工作（<strong>etcd</strong> 使用 <strong>RAFT</strong> 一致性算法来保证数据一致性）， 但是， 调度器和控制器管理器在给定时间内只能有一个实例起作用 ，其他实例处于待命模式。</p>
<p>注：多个调度器：可以在集群中运行多个调度器而非单个。 然后， 对每一个 <strong>pod,</strong> 可以通过在 <strong>pod</strong>特性中设置<strong>schedulerName</strong> 属性指定调度器来调度特定的 <strong>pod</strong>。未设置该属性的 <strong>pod</strong> 由 默认调度器<strong>default-scheduler</strong> 调度。</p>
</blockquote>
<h3 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h3><p>​        工作节点是运行容器化应用的机器。运行、监控和 理应用服务的任务是由以下组件完成的</p>
<ul>
<li><code>Docker</code> 、<code>rtk</code>或<code>其他的容器类型</code>。</li>
<li><code>Kubelet</code>: 它与 API 务器通信，并管理它所在节点的容器。</li>
<li><code>Kubernetes Service Proxy</code> (kube-proxy)，它负责组件之间的负载均衡网络流量。</li>
</ul>
<blockquote>
<p><code>rtk</code>:</p>
<p>Docker是第一个使容器成为主流的容器平台。 Docker本身并不提供进程隔离，实际上容器隔离是在Linux内核之上使用诸如Linux命名空间和cgroups之类的内核特性完成的， Docker仅简化了这些特性的使用。在Docker成功后， 开放容器计划(OCI)就开始围绕容器格式和运行时创建了开放工业标准。 Docker是计划的一部分， rkt (发音为”rock-it”)则是另外一个Linux容器引擎。和Docker一样， rkt也是一个运行容器的平台， 它强调安全性、 可构建性并遵从开放标准。 它使用OCI容器镜像， 甚至可以运行常规的Docker容器镜像。</p>
</blockquote>
<h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><p>​        为了在 Kubernetes 中运行应用，首先需要将应用打包进一个或多个容器镜像，再将那些镜像推送到镜像仓库，然后将应用的描述发布到<code> Kubenetes API 服务器</code>。</p>
<blockquote>
<p><code>应用的描述</code>包括诸如容器镜像或者包含应用程序组件的容器镜像、这些组件如何相互关联，以及哪些组件需要同时运行在同一个节点上和哪些组件不需要同时运行等信息。此外，该描述还包括哪些组件为内部或外部客户提供服务且应该通过单个 IP地址暴露 ，并使其他组件可以发现</p>
</blockquote>
<h3 id="描述信息怎样成为一个运行的容器"><a href="#描述信息怎样成为一个运行的容器" class="headerlink" title="描述信息怎样成为一个运行的容器"></a>描述信息怎样成为一个运行的容器</h3><p>​        当API 服务器处理应用的描述时，调度器调度指定组的容器到可用的工作节点上，调度是基于每组所需的计算资    源，以及调度时每个节点未分配的资源。然后，那些节点上的 Kubelet 指示容器运行时（例如 Docker ）拉取所需的镜像并运行容器。</p>
<blockquote>
<p>在 Kubernetes 中部署应用程序如下图所示，应用描述符列出了四个容器，并将它们分为 组（这些集合被称为 pod ） 前两个pod只包含一个容器，而最后一个包含两个。这意味着两个容器都需要协作运行 ，不应该相互隔离。在每个pod 旁边，还可以看到一个数字，表示需要并行运行的每个 pod 副本数量。在向 Kubernetes 提交描述符之后，它将把每个 pod 的指定副本数调度到可用的工作节点上。节点上的 Kubelets 将告知Docker从镜像仓库中拉取容器镜像井运行容器。<img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211205233952199.png" alt="image-20211205233952199"></p>
</blockquote>
<h2 id="创建单机k8s"><a href="#创建单机k8s" class="headerlink" title="创建单机k8s"></a>创建单机k8s</h2><h3 id="禁用swap分区"><a href="#禁用swap分区" class="headerlink" title="禁用swap分区"></a>禁用swap分区</h3><p>Kubernetes 1.8开始要求关闭系统的Swap，可暂时关闭或永久禁用，使用 # free -m 确认swap是否为开启状态</p>
<ol>
<li>swapoff -a # 暂时关闭</li>
<li>vim /etc/fstab # 注释掉swap那一行(SWAP 自动挂载)，可永久禁用swap分区</li>
</ol>
<h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><p>​        kubectl用于运行Kubernetes集群命令的管理工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用curl下载</span></span><br><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.4/bin/linux/amd64/kubectl</span><br><span class="line"><span class="comment"># 可执行权限</span></span><br><span class="line">chmod +x ./kubectl</span><br><span class="line"><span class="comment"># 将二进制文件移到 PATH 中</span></span><br><span class="line">mv ./kubectl /usr/<span class="built_in">local</span>/bin/kubectl</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>kubectl常用命令</strong></p>
<p>kubectl run hello-minikube –image=k8s.gcr.io/echoserver:1.4 –port=8080 # 创建pod容器</p>
<p>kubectl create -f 【××.yaml】# 以配置文件形式创建pod容器</p>
<p>kubectl exec 【podname】 –  【命令】#指定pod内部执行指定命令</p>
<p>kubectl get po -A # 查看pod状态</p>
<p>kubectl get nodes # 列出集群节点</p>
<p>kubectl describe node 【nodeName】#查看节点更多详细信息</p>
<p>kubectl cluster-info #展示集群信息</p>
<p>kubectl delete all –all  #删除所有资源， <strong>all</strong> 指定正在删除所有资源类型， <strong>–all</strong> 选项指定将删除所有资源实例而不是按名称指定它们。使用 <strong>all</strong> 关键字删除所有内容并不是真的完全删除所有内容。 一些资源（如Secret）会被保留下来， 并且需要被明确指定删除。</p>
</blockquote>
<h3 id="安装minikube"><a href="#安装minikube" class="headerlink" title="安装minikube"></a>安装minikube</h3><p>注：<strong>Minikube</strong> 是一个构建单节点集群的工具，对千测试Kubenetes和本地开发应用都非常有用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.24.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; mv minikube /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">minikube start --vm-driver=docker --registry-mirror=https://registry.docker-cn.com</span><br><span class="line">--memory=1800mb</span><br><span class="line"><span class="comment"># --registry-mirror参数，指明从docker中国区的镜像下载数据。</span></span><br><span class="line"><span class="comment"># --memory限制内容使用</span></span><br><span class="line"><span class="comment"># --insecure-registry私有仓库镜像</span></span><br><span class="line"><span class="comment"># 若报错 The &quot;docker&quot; driver should not be used with root privileges.</span></span><br><span class="line"><span class="comment"># 不允许root身份执行，请切换用户并将该用户添加到docker用户组</span></span><br><span class="line"><span class="comment"># 若拉取k8s.gcr.io/kube-apiserver:v1.22.3出错，则用阿里云镜像</span></span><br><span class="line">minikube start --vm-driver=docker --image-repository=registry.aliyuncs.com/google_containers --memory=1800mb --insecure-registry=192.168.38.128:5000</span><br></pre></td></tr></table></figure>

<h3 id="清除minikube数据"><a href="#清除minikube数据" class="headerlink" title="清除minikube数据"></a>清除minikube数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.minikube</span><br></pre></td></tr></table></figure>

<blockquote>
<p>minikube config set memory 4096 # minikube默认情况下仅分配2GB的RAM，需扩内存可使用此命令</p>
<p>minikube dashboard # 访问minikube集群中运行的Kubernetes仪表板</p>
<p>minikube service hello-minikube # 使用minikube可在浏览器中轻松打开此开放节点</p>
<p>minikube start -p cluster2 # 启动第二个本地集群（注意：裸机启动（本次实验环境）不适用）</p>
<p>minikube stop # 停止本地集群</p>
<p>minikube delete # 删除本地集群</p>
</blockquote>
<h3 id="删除集群"><a href="#删除集群" class="headerlink" title="删除集群"></a>删除集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube delete</span><br></pre></td></tr></table></figure>

<h3 id="停止集群"><a href="#停止集群" class="headerlink" title="停止集群"></a>停止集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube stop</span><br></pre></td></tr></table></figure>

<h3 id="使用rc创建应用"><a href="#使用rc创建应用" class="headerlink" title="使用rc创建应用"></a>使用rc创建应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旧版--generator（已经弃用） 让Kubenetes 创建ReplicationController, 而不是 deployment</span></span><br><span class="line">kubectl run kubia --image=192.168.38.128:5000/kubia  --port=8080 --generator=run/v1 replicationcontroller <span class="string">&quot;kubia&quot;</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新版：使用yaml文件创建</span></span><br><span class="line">kubia-rc.yaml</span><br><span class="line"><span class="comment"># apiVersion: v1 # Kubernetes API版本</span></span><br><span class="line"><span class="comment"># kind: ReplicationController # 描述资源类型</span></span><br><span class="line"><span class="comment"># metadata:		# 元数据（名称、标签和注解等）</span></span><br><span class="line"><span class="comment">#   name: kubia # 名称</span></span><br><span class="line"><span class="comment"># spec:		#pod 规格／内容（pod 的容器列表、 volume 等）</span></span><br><span class="line"><span class="comment">#   replicas: 1  #pod实例的目标数目</span></span><br><span class="line"><span class="comment">#   selector:</span></span><br><span class="line"><span class="comment">#     app: kubia #pod选择器决定了RC的操作对象</span></span><br><span class="line"><span class="comment">#   template:    #创建pod所用模板</span></span><br><span class="line"><span class="comment">#     metadata:</span></span><br><span class="line"><span class="comment">#       labels:</span></span><br><span class="line"><span class="comment">#         app: kubia</span></span><br><span class="line"><span class="comment">#     spec:</span></span><br><span class="line"><span class="comment">#       containers:</span></span><br><span class="line"><span class="comment">#       - name: kubia</span></span><br><span class="line"><span class="comment">#         image: 192.168.38.128:5000/kubia</span></span><br><span class="line"><span class="comment">#         ports:</span></span><br><span class="line"><span class="comment">#         - containerPort: 8080</span></span><br><span class="line">kubectl create -f kubia-rc.yaml</span><br><span class="line"></span><br><span class="line">[czm@localhost ~]$ kubectl get pods</span><br><span class="line"><span class="comment"># -o wide选项显示其他列</span></span><br><span class="line"><span class="comment"># -o yaml/json 以yaml/json展示pod的完整描述信息</span></span><br><span class="line"><span class="comment"># --show-labels 显示pod所有标签 / -L bale1,label2,……仅显示指定标签</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia   1/1     Running   0          47s</span><br></pre></td></tr></table></figure>

<h3 id="删除应用"><a href="#删除应用" class="headerlink" title="删除应用"></a>删除应用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rc kubia</span><br><span class="line"><span class="comment"># 不指定rc（ReplicationController）pod会参重新创建</span></span><br><span class="line"><span class="comment"># rc的创建不会直接创建pod，而是先建一个ReplicationController，然后再由ReplicationController创建pod，只要删除由该ReplicationController创建的pod，它便会立即创建一个新的pod，如果想要删除该pod，需要删除这个ReplicationController</span></span><br></pre></td></tr></table></figure>

<h3 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[czm@control-plane app]$ kubectl describe pod nginx</span><br><span class="line">Name:         nginx</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/192.168.58.2</span><br><span class="line">Start Time:   Tue, 07 Dec 2021 18:57:39 +0800</span><br><span class="line">Labels:       app=myapp</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>每个 pod 都有自己的 IP 地址，但是这个地址是集群 内部的，不能从集群外部访问 。要让 pod 能够从外部访问 需要通过服务对象公开它， 创建 特殊 LoadBalancer 类型的服务。通过LoadBalancer类型的服务，将创建一个外部的负载均衡，可以通过负载均衡的公共 IP 访问 pod</p>
<blockquote>
<h3 id="创建nginx服务"><a href="#创建nginx服务" class="headerlink" title="创建nginx服务"></a>创建<code>nginx</code>服务</h3><p><code>nginx-rc.yaml </code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">     <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">   	<span class="attr">containers:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">       <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">       <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">       <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[czm@control-plane app]$ kubectl create -f nginx-rc.yaml</span><br><span class="line">nginx created</span><br><span class="line">[czm@control-plane app]$ kubectl expose pod nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">[czm@control-plane app]$ kubectl get services</span><br><span class="line">NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP        9h</span><br><span class="line">nginx        NodePort    10.100.4.38   &lt;none&gt;        80:30624/TCP   62m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问服务</span></span><br><span class="line">[czm@control-plane ~]$ minikube service nginx</span><br><span class="line">|-----------|-------|-------------|---------------------------|</span><br><span class="line">| NAMESPACE | NAME  | TARGET PORT |            URL            |</span><br><span class="line">|-----------|-------|-------------|---------------------------|</span><br><span class="line">| default   | nginx |          80 | http://192.168.58.2:30624 |</span><br><span class="line">|-----------|-------|-------------|---------------------------|</span><br><span class="line">🎉  正通过默认浏览器打开服务 default/nginx...</span><br><span class="line">This tool has been deprecated, use <span class="string">&#x27;gio open&#x27;</span> instead.</span><br><span class="line">See <span class="string">&#x27;gio help open&#x27;</span> <span class="keyword">for</span> more info.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211208010529364.png" alt="image-20211208010529364"></p>
</blockquote>
<h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pod日志</span></span><br><span class="line">kubectl logs [podName]</span><br><span class="line"><span class="comment">#日志管理工具journalctl是centos7上专有的日志管理工具，该工具是从message这个文件里读取信息。Systemd统一管理所有Unit的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。minikube启动失败可以通过此查看</span></span><br><span class="line">journalctl -f</span><br></pre></td></tr></table></figure>

<h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><p>​        pod是一组并置的容器， 代表了Kubenetes中的基本构建模块（部署单元）。将多个进程聚集在一个单独的容器中，并将它们作为一个单元进行管理，这就是 <strong>pod</strong> 背后的根本原理。<strong>Kubenetes</strong> 通过配置 <strong>Docker</strong> 来让一个 <strong>pod</strong> 内的所有容器共享相同的 <strong>Linux</strong> 命名空间，一个 <strong>pod</strong> 中的所有容器都在相同的 <strong>network</strong> 和 <strong>UTS</strong> 命名空间下运行， 共享相同的主机名和网络接口。 同样地， 这些容器也都在相同的 <strong>IPC</strong> 命名空间下运行， 因此能够通过 <strong>IPC</strong> 进行通信。 在最新的 <strong>Kubernetes</strong> 和 <strong>Docker</strong> 版本中， 它们也能够共享相同的 <strong>PID</strong> 命名空间（默认是未激活）</p>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211207195731891.png" alt="一个pod绝不会跨越多个工作节点"></p>
<h3 id="pod间网络"><a href="#pod间网络" class="headerlink" title="pod间网络"></a>pod间网络</h3><p>​        <strong>Kubernetes</strong> 集群中的所有 <strong>pod</strong> 都在同一个共享网络地址空间中（如下图所示)， 它们之间没有 <strong>NAT</strong> (网络地址转换） 网关，每个 <strong>pod</strong> 都可以通过其他 <strong>pod</strong> 的 IP 地址来实现相互访问。 当两个 pod 彼此之间发送网络数据包时， 它们都会将对方的<strong>实际 IP地址</strong>看作数据包中的源 <strong>IP</strong>。</p>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211208004339687.png" alt="平面网络"></p>
<h3 id="向pod发送请求"><a href="#向pod发送请求" class="headerlink" title="向pod发送请求"></a>向pod发送请求</h3><ol>
<li><p>通过创建service进行访问。</p>
</li>
<li><p>执行<code>kubectl port-forward </code>转发本地端口转发到指定pod端口（测试常用）。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[czm@control-plane app]$ kubectl port-forward nginx 8000:80</span><br><span class="line">Forwarding from 127.0.0.1:8000 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8000 -&gt; 80</span><br><span class="line">Handling connection <span class="keyword">for</span> 8000</span><br><span class="line">Handling connection <span class="keyword">for</span> 8000</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><p>​        标记一类pod或拥有特定资源node节点，标签选择器允许我们选择标记有特定标签的pod子集， 并对这些pod执行操作。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加标签</span></span><br><span class="line">kubectl label po 【podName】 【标签名=标签值】</span><br><span class="line"><span class="comment"># 修改标签值</span></span><br><span class="line">kubectl label po 【podName】 【标签名=标签值】 --overwrite</span><br><span class="line"><span class="comment"># 列出包含env标签的所有pod</span></span><br><span class="line">kubectl get po -1 env</span><br><span class="line"><span class="comment"># 列出没有env标签的所有pod</span></span><br><span class="line">kubectl get po -1 <span class="string">&#x27;!env&#x27;</span></span><br><span class="line"><span class="comment"># 选择带有env标签且值为prod或devel的pod</span></span><br><span class="line">kubectl get po env <span class="keyword">in</span> (prod, devel)</span><br><span class="line"><span class="comment"># 选择带有env标签， 但其值不是prod或devel的pod</span></span><br><span class="line">kubectl get po env notin (prod, devel)</span><br><span class="line"><span class="comment"># 删除env标签是prod的所有pod</span></span><br><span class="line">kubectl delete po - 1 env=prod</span><br></pre></td></tr></table></figure>

<p><strong>将pod调度到特定节点</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为一类节点添加标签，并在pod的yaml文件中添加如下配置</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line"> <span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="string">标签key:</span> <span class="string">标签值</span></span><br></pre></td></tr></table></figure>

<p>注：除标签外，pod和其他对象还可以包含注解。注解也是键值对，但与标签不同，注解并不是为了保存标识信息而存在的，它们不能像标签一样用于对对象进行分组。当我们可以通过标签选择器选择对象时，就不存在注解选择器这样的东西。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>​        Kubernetes命名空间简单地为对象名称提供了一个作用域，不同的命名空间可以包含同名的资源。namespace 使我们能够将不属于一组的资源分到不重叠的组中（如按用户进行分组）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出集群中的所有命名空间</span></span><br><span class="line">kubectl get ns</span><br><span class="line"><span class="comment"># 列出只属于default命名空间的pod（可以使用-n来代替 --namespace）</span></span><br><span class="line">kubectl get po --namespace default</span><br><span class="line"><span class="comment"># 创建czm命名空间</span></span><br><span class="line">kubectl create namespace czm</span><br><span class="line"><span class="comment"># 删除命名空间，所属的pod也会删除</span></span><br><span class="line">kubectl delete ns czm</span><br></pre></td></tr></table></figure>

<h3 id="指定命名空间"><a href="#指定命名空间" class="headerlink" title="指定命名空间"></a>指定命名空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建时指定</span></span><br><span class="line">kubectl create -f nginx.yaml -n czm</span><br><span class="line"><span class="comment"># 2. 直接yaml中指定</span></span><br><span class="line">metadata:</span><br><span class="line"> namespace: czm</span><br></pre></td></tr></table></figure>



<h2 id="存活探针-liveness-probe"><a href="#存活探针-liveness-probe" class="headerlink" title="存活探针 (liveness probe)"></a>存活探针 <strong>(liveness probe)</strong></h2><p>​    k8s通过存货探针检查容器是否还在运行。 可以为 <strong>pod</strong> 中的每个容器单独指定存活探针。 如果探测失败，k8s将定期执行探针并重新启动容器。探测任务由承载pod的节点上的<strong>Kubelet</strong> 执行。</p>
<h3 id="探测机制"><a href="#探测机制" class="headerlink" title="探测机制"></a>探测机制</h3><ul>
<li><p><strong>HTTP GET</strong>：对容器发起get请求，响应状态码是2xx或3xx, 则认为探测成功。如果服务器返回错误响应状态</p>
<p>  码或者根本没有响应，那么探测就被认为是失败的，容器将被重新启动。</p>
</li>
<li><p><strong>TCP</strong>：套接字探针尝试与容器指定端口建立TCP连接。如果连接成功建立，则探测成功。否则失败</p>
</li>
<li><p><strong>Exec</strong>：探针在容器内执行任意命令，并检查命令的退出状态码。如果状态码是 <strong>0</strong>, 则探测成功。所有其他状态码都被认为失败。</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span> </span><br><span class="line"> 	<span class="attr">containers:</span></span><br><span class="line">      <span class="attr">livenessProbe:</span> </span><br><span class="line">        <span class="attr">httpGet:</span> <span class="comment">#HTTP GET 存活探测针</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#探测路径</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span> <span class="comment">#端口</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">15</span> <span class="comment"># Kubernetes会在第—次探测前等待15秒</span></span><br></pre></td></tr></table></figure>

<h2 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h2><p>​        就绪探针的类型与存活探针一样三种。与存活探针不同的是如果容器未通过准备检 ，不会被终止或重新启动。启动容器时，可以为 bernetes 配置 等待时间，经过等待时间后才可以执行第一次准备就绪检查之后，它会周期性地调用探针（默认情况下每<strong>10</strong> 秒检查一次），并根据就绪探针的结果采取行动。如果某个 pod报告它尚未准备就绪，则会从该服务中删除该pod 。如果再次准备就绪，则重新添加 pod。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span> </span><br><span class="line">	<span class="attr">containers:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line">		<span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br><span class="line">		<span class="attr">readinessProbe:</span></span><br><span class="line">			<span class="attr">exec:</span>  </span><br><span class="line">				<span class="attr">command:</span> </span><br><span class="line">				<span class="bullet">-</span> <span class="string">ls</span> </span><br><span class="line">				<span class="bullet">-</span> <span class="string">/var/ready</span></span><br><span class="line"><span class="comment">#就绪探针将定期在容器内执行ls/var/ready命令。如果文件存在，则ls命令返回退出码0，则就绪探针将成功，否则返回非零的退出码，就绪探针失败。</span></span><br></pre></td></tr></table></figure>



<h2 id="ReplicationController（rc）"><a href="#ReplicationController（rc）" class="headerlink" title="ReplicationController（rc）"></a>ReplicationController（rc）</h2><p>​        rc是一种Kubenetes资源，可确保它的pod始终保持运行状态。rc会持续监控正在运行的pod列表， 并保证相应的pod的数目与期望相符。</p>
<p>注：上面kubia创建例子就是rc的应用。</p>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211208165527010.png" alt="image-20211208165527010"></p>
<h3 id="协调流程"><a href="#协调流程" class="headerlink" title="协调流程"></a>协调流程</h3><p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211208170753086.png" alt="协调流程"></p>
<h3 id="三个主要部分"><a href="#三个主要部分" class="headerlink" title="三个主要部分"></a>三个主要部分</h3><ul>
<li>label selector ( 标签选择器）， 用于确定rc作用域中有哪些pod</li>
<li>replica count (副本个数）， 指定应运行的pod 数量 </li>
<li>pod template (pod模板）， 用于创建新的pod 副本</li>
</ul>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211208171434826.png" alt="image-20211208171434826"></p>
<h3 id="rc与pod关系"><a href="#rc与pod关系" class="headerlink" title="rc与pod关系"></a>rc与pod关系</h3><p>​        rc与pod通过标签关联，对pod删除或添加相关标签可以将pod移出或移入rc的作用域。</p>
<h3 id="修改rc中pod模板"><a href="#修改rc中pod模板" class="headerlink" title="修改rc中pod模板"></a>修改rc中pod模板</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit rc 【rcName】</span><br><span class="line"><span class="comment"># 进入默认文本编辑器中打开ReplicationController的YAML配置进行编辑，对现有的pod没有影响。</span></span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行</span></span><br><span class="line">kubectl scale rc 【rcName】 --replicas=10</span><br><span class="line"><span class="comment"># 修改yaml</span></span><br><span class="line">kubectl edit rc 【rcName】<span class="comment">#进入编辑，修改spec.replicas值</span></span><br></pre></td></tr></table></figure>

<h3 id="删除rc保持pod运行"><a href="#删除rc保持pod运行" class="headerlink" title="删除rc保持pod运行"></a>删除rc保持pod运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete rc 【rcName】 --cascade=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 原rc作用域的pod独立运行</span></span><br></pre></td></tr></table></figure>

<h2 id="ReplicaSet-rs"><a href="#ReplicaSet-rs" class="headerlink" title="ReplicaSet(rs)"></a>ReplicaSet(rs)</h2><p>​        <strong>ReplicaSet</strong> （新一代的rc）的行为与<strong>ReplicationController</strong> 完全相同， 但<strong>pod</strong> 选择器的表达能力更强。 虽然 <strong>ReplicationController</strong> 的标签选择器只允许包含某个标签的匹配 <strong>pod,</strong> 但<strong>ReplicaSet</strong> 的选择器还允许匹配缺少某个标签的 <strong>pod,</strong> 或包含特定标签名的 <strong>pod,</strong> 不管其值如何。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/vlbeta2</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">	<span class="attr">name:</span> <span class="string">kubia</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">	<span class="attr">replicas:</span> <span class="number">3</span> </span><br><span class="line">	<span class="attr">selector:</span> </span><br><span class="line">		<span class="attr">matchLabels:</span> </span><br><span class="line">			<span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">        <span class="comment">#matchExpressions: </span></span><br><span class="line">        <span class="comment">#    - key: app		#要求rs的pod包含标签名为app，标签值必须为kubia</span></span><br><span class="line">        <span class="comment">#      operator: In</span></span><br><span class="line">        <span class="comment">#      values:</span></span><br><span class="line">        <span class="comment">#      	- kubia</span></span><br><span class="line">	<span class="attr">template:</span> </span><br><span class="line">		<span class="attr">metadata:</span></span><br><span class="line">			<span class="attr">labels:</span> </span><br><span class="line">				<span class="attr">app:</span> <span class="string">kubia</span> </span><br><span class="line">		<span class="attr">spec:</span> </span><br><span class="line">			<span class="attr">containers:</span> </span><br><span class="line">			<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia</span> </span><br><span class="line">			<span class="attr">image:</span> <span class="string">luksa/kubia</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="operator-运算符）"><a href="#operator-运算符）" class="headerlink" title="operator (运算符）"></a>operator (运算符）</h3><ul>
<li>In : Label的值必须与其中 一个指定的values 匹配。</li>
<li>Notln : Label的值与任何指定的values 不匹配。</li>
<li>Exists : pod 必须包含一个指定名称的标签（值不重要）。使用此运算符时，不应指定 values字段。</li>
<li>DoesNotExist : pod不得包含有指定名称的标签，values属性不得指定 。</li>
</ul>
<p>注：若指定多个表达式，则需要同时成立</p>
</blockquote>
<h2 id="DaemonSet（ds）"><a href="#DaemonSet（ds）" class="headerlink" title="DaemonSet（ds）"></a>DaemonSet（ds）</h2><p><strong>ReplicationController</strong> 和 <strong>ReplicaSet</strong> 将 <strong>pod</strong> 安排到随机集群节点， 而 <strong>DaemonSet</strong>确保每个节点都运行一个 <strong>DaemonSet</strong> 中定义的 <strong>pod</strong> 实例。DaemonSet 并没有期望的副本数的概念。它的工作是确保一个pod匹配它的选择器并在每个节点上运行 。如果<strong>节点下线</strong>， DaemonSet不会在其他地方重新创建pod。 但是， 当将 一个新节点添加到集群中时， DaemonSet会立刻部署一个新的pod实例 。</p>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211208215133588.png" alt="image-20211208215133588"></p>
<h2 id="Service服务（SVC）"><a href="#Service服务（SVC）" class="headerlink" title="Service服务（SVC）"></a>Service服务（SVC）</h2><p><strong>Kubernetes</strong> 服务是一种为一组功能相同的 <strong>pod</strong> 提供单一<strong>不变的接入点</strong>的资源。当服务存在时，它的 <strong>IP</strong> 地址和端口不会改变。 客户端通过 <strong>IP</strong> 地址和端口号建立连接，这些连接会被路由到提供该服务的任意一个 <strong>pod</strong> 上。与<code>rc</code>一样通过标签选择器决定哪些pod属于服务。</p>
<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211209141919554.png" alt="image-20211209141919554"></p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可直接使用kubectl expose创建，或通过如下yaml配置文件传递到Kubernetes API服务器来手动创建服务</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">vl</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">kubia</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">	<span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span> <span class="comment">#同一个客户端产生的所有请求每次都指向同一个pod，默认为None</span></span><br><span class="line">	<span class="attr">portS:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span>		<span class="comment">#端口名（在需要暴露多个端口时必须指定）</span></span><br><span class="line">		  <span class="attr">port:</span> <span class="number">80</span>			<span class="comment">#服务可用端口</span></span><br><span class="line">		  <span class="attr">targetPort:</span> <span class="number">8080</span>  <span class="comment">#服务将连接转发到容器的端口，也可以填对应端口名</span></span><br><span class="line">	<span class="attr">selector:</span> </span><br><span class="line">		<span class="attr">app:</span> <span class="string">kubia</span> 		<span class="comment">#具有app=kubia标签的pod属于该服务</span></span><br></pre></td></tr></table></figure>

<h3 id="通过-FQDN-连接服务"><a href="#通过-FQDN-连接服务" class="headerlink" title="通过 FQDN 连接服务"></a>通过 FQDN 连接服务</h3><p>​        每个服务从内部 DNS 服务器中获得DNS条目(pod 是否使用 部的 DNS 服务器是根据 pod中spec的dnsPolicy 属性来决定的)，客户端 pod 在知道服务名称的情况下可以通过全限定域名 (FQDN )来访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serviceName.default.svc.cluster.local </span><br><span class="line"><span class="comment"># serviceName对应于服务名称， default 表示服务在其中定义的命名空间，而 svc.cluster.local 是在所有集群本地服务名称中使用的可配置集群域后缀。</span></span><br><span class="line"><span class="comment">#根据每个pod容器DNS解析器配置的方式，可以将命名空间和svc.cluster.local后缀省略掉.</span></span><br></pre></td></tr></table></figure>

<h3 id="访问外部服务"><a href="#访问外部服务" class="headerlink" title="访问外部服务"></a>访问外部服务</h3><p>服务不仅可以将连接重定向到集群中的pod，也可以重定向到外部 IP 和端口。在集群中运行的客户端pod可以像连接到内部服务那样连接到外部服务</p>
<blockquote>
<p><strong>服务endpoint</strong></p>
<p>服务并不是和 <strong>pod</strong> 直接相连的。两者之间还有<strong>Endpoint</strong> 资源，可执行<code>kubectl describe</code>查看。<strong>Endpoint</strong> 资源就是暴露一个服务的 <strong>IP</strong> 地址和端口的列表。尽管服务在 <strong>spec</strong> 服务中定义了 <strong>pod</strong>选择器，但在重定向传入连接时不会直接使用它。选择器用于构建 <strong>IP</strong> 和端口列表，然后存储在 <strong>Endpoint</strong> 资源中。当客户端连接到服务时，服务代理选择这些 <strong>IP</strong> 和端口对中的一个，并将传入连接重定向到在该位置监听的服务器。</p>
</blockquote>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p><strong>服务配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">vl</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">	<span class="attr">name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span> 		<span class="comment">#服务中没有定义选择器</span></span><br><span class="line">	<span class="attr">ports:</span> </span><br><span class="line">	 <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>endpoint配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">vl</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">EndpointS</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">external-service</span> <span class="comment">#名称必须与服务名匹配</span></span><br><span class="line"><span class="attr">subsets:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">11.11</span><span class="number">.11</span><span class="number">.11</span> <span class="comment"># 服务将连接重定向到endpoint的IP地址</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">22.22</span><span class="number">.22</span><span class="number">.22</span></span><br><span class="line">		<span class="attr">ports:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#endpoint的目标端口</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211209164332171.png" alt="image-20211209164332171"></p>
<h4 id="外部服务创建别名"><a href="#外部服务创建别名" class="headerlink" title="外部服务创建别名"></a>外部服务创建别名</h4><p>除了手动配置服务的Endpoint来代替公开外部服务方法，有一种更简单的方法，就是通过其完全限定域名(FQDN)访问外部服务。要创建一个具有别名的外部服务的服务时，要将创建服务资源的一个type字段设置为ExternalName。</p>
<p><strong>服务配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">vl</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">	<span class="attr">name:</span> <span class="string">external-service</span> </span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">	<span class="attr">type:</span> <span class="string">ExternalName</span> </span><br><span class="line">	<span class="attr">externalName:</span> <span class="string">someapi.somecompany.com</span> <span class="comment">#实际调用的外部服务域名</span></span><br><span class="line">	<span class="attr">ports:</span> </span><br><span class="line">		<span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>服务创建完成后，pod可以通过external-service.default.svc.cluster.local域名（甚至是external-service)连接到外部服务。</p>
<h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><h4 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h4><ul>
<li>将服务的类型设置成NodePort：每个集群节点都会在<strong>节点</strong>上打开一个端口，对于NodePort服务， 每个集群节点在节点本身（因此得名叫NodePort)上打开一个端口，并将在该端口上接收到的流量重定向到基础服务。该服务仅在内部集群 <strong>IP</strong> 和端口上才可访间， 但也可通过所有节点上的专用端口访问。</li>
</ul>
<blockquote>
<p>NodePort服务定义</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">vl</span> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> </span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">	<span class="attr">name:</span> <span class="string">kubia-nodeport</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">	<span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">	<span class="attr">externalTrafficPorcy:</span> <span class="string">Local</span> <span class="comment"># 随机选择的pod在接收连接的同一节点上运行.如果没有本地pod存在， 则连接将挂起</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># 服务集群的IP端口号</span></span><br><span class="line">        <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 基础服务pod的目标端口</span></span><br><span class="line">        <span class="attr">nodePort:</span> <span class="number">30123</span> <span class="comment">#访问集群的端口，没有指定会随机选择一个端口</span></span><br><span class="line">    <span class="attr">selector:</span> </span><br><span class="line">	    <span class="attr">app:</span> <span class="string">kubia</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>将服务的类型设置成LoadBalancer：NodePort类型的一 种扩展，服务可以通过一个专用的负载均衡器来访问， 这是由Kubernetes中正在运行的云基础设施提供的。 负载均衡器将流量重定向到跨所有节点的节点端口。客户端通过负载均衡器的 <strong>IP</strong> 连接到服务。</li>
<li>创建一个Ingress资源控制器， 这是一个完全不同的机制，通过一 个IP地址公开多个服务——它运行在 <strong>HTTP</strong> 层（网络协议第<strong>7</strong> 层）上， 因此可以提供比工作在第4层的服务更多的功能。<span style="color:red;"> 每个 <strong>LoadBalancer</strong> 服务都需要自己的负载均衡器， 以及独有的公有 <strong>IP</strong> 地址， 而 <strong>Ingress</strong> 只需要一个公网 <strong>IP</strong> 就能为许多服务提供访问。 当客户端向 <strong>Ingress</strong> 发送 <strong>HTTP</strong> 请求时， <strong>Ingress</strong> 会根据请求的主机名和路径决定请求转发到的服务。</span></li>
</ul>
<blockquote>
<p><strong>示例</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/vlbetal</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span> </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">	<span class="attr">name :</span> <span class="string">kubia</span> </span><br><span class="line"><span class="attr">spec :</span> </span><br><span class="line">	<span class="attr">rules:</span> </span><br><span class="line">	<span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span>  </span><br><span class="line">	  <span class="attr">http:</span> </span><br><span class="line">		<span class="attr">paths:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">		  <span class="attr">backend:</span> <span class="comment"># 将所有请求主机kubia.example.com的http请求发送到kubia-nodeport服务的80端口</span></span><br><span class="line">			<span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">			<span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>列出所有Ingress</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ingresses</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/05/%E9%83%A8%E7%BD%B2/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211209234539866.png" alt="image-20211209234539866"></p>
<p>注：可以调用 kubectl apply - f ××.yaml 修改文件中指定的内容来更新 Ingress 资源，而不是通过删除并从新文件重新创建的方式</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/tutorials/services/source-ip/">客户端真实IP问题</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Kubernetes in Action 中文版》——<code>Marko Luksa</code></p>
<h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%83%A8%E7%BD%B2/">部署</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2020/09/17/wfnWJH.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/08/%E9%83%A8%E7%BD%B2/Git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"><img class="prev-cover" src="https://s1.ax1x.com/2020/09/17/wfnWJH.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git常用指令</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/19/GoLang/Go%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><img class="next-cover" src="https://s1.ax1x.com/2020/09/26/0igq0K.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Go内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/10/19/部署/打包vue项目部署到nginx/" title="打包vue项目部署到Nginx"><img class="cover" src="https://s1.ax1x.com/2020/09/17/wfuY6I.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-19</div><div class="title">打包vue项目部署到Nginx</div></div></a></div><div><a href="/2021/02/07/部署/docker/" title="docker学习笔记"><img class="cover" src="https://s1.ax1x.com/2020/09/17/wfu2n0.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-07</div><div class="title">docker学习笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(https://s1.ax1x.com/2020/09/17/wfnWJH.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By CZM</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'k2GMUzIrob4GbB5vtonkzLSO-gzGzoHsz',
      appKey: '6k8wcGzpepgvksNzrQlYU2W1',
      placeholder: '记得留下你的痕迹……',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/click_heart.js" async="async"></script><script src="/js/third-party/ClickShowText.js" async="async"></script></div></body></html>